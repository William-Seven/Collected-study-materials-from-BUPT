# 第 2 章、编译概述
![](Attachments/Pasted%20image%2020240924100030.png)

+ **语法分析阶段**可以发现关键字拼写错误、缺少运算对象、以及本应为常数，但却在数中出现了非数字字符的错误。

+ **语义分析阶段**可以发现实参与形参的类型不一致、所引用的变量没有定义的错误。

+ 数组下标越界的错误可以在**语义分析阶段**、或**执行时**被发现。
# 第 3 章、词法分析
![](Attachments/Pasted%20image%2020241103141121.png)


# 第 4 章、语法分析
## 自顶向下分析方法
## 递归下降分析
试图建立一个**最左推导序列**的过程

左递归文法，可能导致分析过程陷入死循环。

### 递归预测分析
一种确定的、不带回溯的递归下降分析方法

+ **递归调用预测分析对文法的要求**
 > 1. 不含左递归
 > 2. $FIRST (\alpha_i)\cap FIRST (\alpha_j)=\emptyset$（对于 $A\rightarrow \alpha_1|\alpha_2|...$）
 
+ **为文法构造转换图**
 > **改写文法**
 > > 消除直接左递归
 > > ![](Attachments/Pasted%20image%2020250102153824.png)
 > 
 > **对每一个非终结符号 A**：
 > > 创建一个初态和一个终态
 > > 对每个产生式 $A\rightarrow X_1X_2...X_n$ 创建一条从初态到终态的路径，有向边的标记依次为 $X_1,X_2,...,X_n$
 > 
 > **化简转换图**
 > > ![450](Attachments/Pasted%20image%2020250102153925.png)
 
### 非递归预测分析
![500](Attachments/Pasted%20image%2020241103151353.png)

#### 预测分析表的构造
+ **改写文法**
+ **FIRST集合及其构造**
 > ![](Attachments/Pasted%20image%2020241103152022.png)
 
+ **FOLLOW集合及其构造**
 > ![](Attachments/Pasted%20image%2020241103153504.png)
 > 注意：一开始要将$放进开始符号的集合中！
 
+ **预测分析表的构造**
 > ![](Attachments/Pasted%20image%2020241103153604.png)
 
 #### LL (1) 文法
+ **判断方法**
 > 不含**左递归**，不含左公因子![](Attachments/Pasted%20image%2020241103154540.png)
 
## 4.4 LR分析方法
+ **活前缀**
 > ![](Attachments/Pasted%20image%2020241103201216.png)
 
+ **LR 分析控制程序**
 > ![500](Attachments/Pasted%20image%2020241103201736.png) **见书 P 103**

### SLR(1)分析表的构造
+ **LR (0) 项目**
 >  ![500](Attachments/Pasted%20image%2020241103203240.png)
+ **拓广文法**
 > ![450](Attachments/Pasted%20image%2020241103203410.png)

+ **LR(0)有效项目、有效项目集、项目集规范族**
 > ![](Attachments/Pasted%20image%2020241103204731.png)
 
+ **转移函数 go**
 > ![500](Attachments/Pasted%20image%2020241103204858.png)
+ **构造文法G的LR(0)项目集规范族**
 > ![500](Attachments/Pasted%20image%2020241103205026.png)

+ **SLR (1) 文法**
 > 具有 SLR (1) 分析表
 > 或者说，冲突可以解决：
 > ![405](Attachments/Pasted%20image%2020241103210035.png)
 > **构造 SLR(1) 分析表**
 > > ![](Attachments/Pasted%20image%2020241103210833.png)

+ **LR(0) 文法**
 > LR(0)文法，项目集中：
 > (1) 要么所有元素都是移进-**待约**项目
 > (2) 要么只含有唯一的归约项目
 > 也就是**不存在冲突**
 > 
 > 而 SLR (1) 是可以存在多个归约项目+移进待约项目，只要冲突可以解决就行

### LR(1)分析表的构造
![500](Attachments/Pasted%20image%2020241103212602.png)

+ **LR(1)有效项目、有效项目集、项目集规范族**
 > ![](Attachments/Pasted%20image%2020241103213224.png)
+ **转移函数 go**
 > ![500](Attachments/Pasted%20image%2020241103214559.png)

+ **算法4.8 构造文法G的LR(1)项目集规范族**
 > ![](Attachments/Pasted%20image%2020241103214637.png)

+ **构造LR(1)分析表**
 > ![](Attachments/Pasted%20image%2020241103214955.png)

### LALR(1)分析表的构造
![](Attachments/Pasted%20image%2020241103223956.png)

+ **构造表**
 > ![](Attachments/Pasted%20image%2020241103224533.png)
 > 表的构造方式于 LR (1) 相同
 
 
针对 LR (1) 文法，进一步检查其项目集规范族中是否存在同心集。
若**不存在同心集**，则该文法是 LALR (1) 文法。
若**存在同心集**，则先合并同心集，然后检查合并之后的项目集中是否存在归约-归约冲突。
若不存在，则该文法是 LALR (1) 文法；否则，该文法是LR (1) 文法，但不是 LALR (1) 文法。

+ 一个文法是 LR (0) 文法，则它也是 SLR (1) 文法、LR (1) 文法和 LALR (1) 文法。
+ 一个文法是 SLR (1) 文法，则它也是 LR (1) 文法和 LALR (1) 文法。
+ 一个文法是 LALR (1) 文法，则它也是 LR (1) 文法。
+ 一个文法不是 LR (1) 文法，则它也不是 SLR (1) 文法、LALR (1) 文法或者 LR (0) 文法。
![400](Attachments/Pasted%20image%2020250102172829.png)
![](Attachments/Pasted%20image%2020241104204656.png)

# 第5章、语法制导翻译技术
## 5.1 语法制导翻译概述
+ **语法制导定义：**
 > 首先，根据翻译目标来确定每个产生式的语义；
 > 其次，根据产生式的含义，分析每个符号的语义；
 > 再次，把这些语义以属性的形式附加到相应的文法符号上（即把语义和语言结构联系起来）；
 > 最后，根据产生式的语义给出符号属性的求值规则（即**语义规则**），从而形成语法制导定义。

+ **翻译：**
 > 根据语法分析过程中所使用的产生式，执行与之相应的语义规则，完成符号属性值的计算，从而完成翻译

## 5.2 语法制导定义及翻译方案
1. **语法制导定义**
 > ![450](Attachments/Pasted%20image%2020241112101833.png) ![450](Attachments/Pasted%20image%2020241112102349.png)
 > **语义规则**
 > ![](Attachments/Pasted%20image%2020241112102715.png)
 > **综合属性**：分析树中，一个结点的某一**属性**由其子结点的属性确定
 > **继承属性**：分析树中，一个结点的**继承属性**值由该结点的父结点和/或它的兄弟结点的属性值决定
 
2. **依赖图**
 > 为每个属性设置一个结点
 > 如果属性b依赖于c，那么从属性c的结点有一条有向边连到属性b的结点。
 > **算法 5.1 构造依赖图**
 > ![450](Attachments/Pasted%20image%2020241112104934.png)

3. **计算次序**
 > ![450](Attachments/Pasted%20image%2020241112105326.png)

+ **语法制导翻译过程**
 > 最基本的文法用于**建立输入符号串的分析树**；
 > 为分析树构造**依赖图**；
 > 对依赖图进行**拓扑排序**；
 > 从这个序列得到语义规则的**计算顺序**；
 > 照此计算顺序**进行求值**，得到对输入符号串的翻译

4. **S属性定义和L属性定义**
 > **S属性定义**：仅涉及综合属性的语法制导定义
 > **L属性定义**：一个语法制导定义是L属性定义，如果与每个产生式 $A→X_1X_2…X_n$ 相应的每条语义规则计算的属性都是：
 > > A的**综合属性**，或是
 > > $X_j（1\leq j\leq n）$ 的**继承属性**，而该继承属性**仅依赖于**：
 > > > A的继承属性；
 > > > 产生式中 $X_j$ 左边的符号 $X_1、X_2、…、X_{j-1}$ 的属性。
 > 每一个S属性定义都是L属性定义
 > 
 > **属性计算顺序**
 > 深度优先遍历分析树
 > 进入结点前，计算其继承属性
 > 从结点返回时，计算其综合属性

5. **翻译方案**
 > 属性与文法符号相对应
 > 语义动作括在花括号中，并插入到产生式右部某个合适的位置上
 > ![](Attachments/Pasted%20image%2020241112112019.png)

## 5.3 S-属性定义的自底向上翻译
### 1 . 为表达式构造语法树的语法制导定义
+ **语法树**
 > 分析树的抽象（或压缩）形式。
 > **内部结点**表示**运算符号**，其**子结点**表示它的**运算分量**。
 > 也称为语法结构树或结构树。

+ **构造函数**
 > `makenode (op, left, right)`：建立一个运算符号结点，标号是 op；域left和right：指向其左右运算分量结点的指针。
 > `makeleaf (id, entry)`：建立一个标识符结点，标号是 id；域entry：指向该标识符在符号表中的相应条目的指针。
 > `makeleaf (num, val)`：建立一个数结点，标号为 num；域val：保存该数的值。![350](Attachments/Pasted%20image%2020241124205450.png)

+ **构造表达式语法树的语法制导定义**
 > 书上例子 5.6
 
+ **表达式的有向非循环图(dag)**
 > ![](Attachments/Pasted%20image%2020241124211232.png)

### 2 . S属性定义的自底向上实现
 > ![](Attachments/Pasted%20image%2020241124212049.png)
 > 规约过程见书上完整 P 157

## 5.4 L属性定义的自底向上翻译
1. 移走翻译方案中嵌入的语义规则
2. 直接使用分析栈中的继承属性
3. 变换继承属性的计算规则
4. 改写语法制导定义为S属性定义

---

# 第6章、语义分析
## 6.1 语义分析概述
+ **语义分析的任务**
 > （1）收集并保存上下文有关的信息；
 > （2）类型检查。

+ **类型检查**
 > 动态检查：目标程序运行时进行的检查
 > 静态检查：读入源程序但不执行源程序的情况下进行的检查

![](Attachments/Pasted%20image%2020241126100847.png)

## 6.2 符号表
+ **1. 符号表的建立和访问时机**
 > ![400](Attachments/Pasted%20image%2020241126101527.png)
+ **2. 符号表内容**
 > 
+ **3. 符号表操作**
 > ![450](Attachments/Pasted%20image%2020241126102345.png)
+ **4. 符号表组织** 
 > ![](Attachments/Pasted%20image%2020241126102808.png)
 
+ **栈式符号表及操作**
 > ![450](Attachments/Pasted%20image%2020241126104616.png)

+ **栈式哈希符号表及操作**
 
## 6.3 类型检查
+ **类型表达式的递归定义**
 > ![](Attachments/Pasted%20image%2020241126112630.png)
 
+ **类型等价**
 > **1. 结构等价**
 >> 两个类型表达式结构等价：
 >> 要么是同样的基本类型
 >> 要么是同样的构造器作用于结构等价的类型表达式。
 >> 两个类型表达式结构等价当且仅当它们完全相同。![450](Attachments/Pasted%20image%2020241126113920.png)
 >
 > **2. 名字等价**
 > ![500](Attachments/Pasted%20image%2020241126114923.png)
 
## 6.4 一个简单的类型检查程序
+ **1. 语言说明**
 > 说明：
 > ① 名字必须先声明后引用
 > ② 每个声明语句声明一个名字
 > ③ 过程声明允许嵌套
 > ④ 数组下标从1开始
+ **2. 符号表的建立**
 > ![450](Attachments/Pasted%20image%2020241126121314.png)
 > **1. 过程中声明语句的处理**
 > > ![450](Attachments/Pasted%20image%2020241203101505.png)
 > **2. 过程定义的处理**
 > > ![500](Attachments/Pasted%20image%2020241203105439.png)
 > **3. 记录声明的处理**
 > ![](Attachments/Pasted%20image%2020241203105846.png)

- **3. 表达式的类型检查**
 > 

- **4. 语句的类型检查**
 > ![](Attachments/Pasted%20image%2020241203110702.png)

- **5. 类型转换**
 >如果类型转换构建在类型体制中，由编译程序完成，这种类型转换是隐式的，称做**强制转换**。
 >如果类型转换必须由程序员显式地写在源程序中，则这种转换叫做**显式转换**。

# 第7章、运行环境
## 7 .1 程序运行时的存储组织
1. 过程与活动
2. 程序运行空间的划分
3. 活动记录与控制栈
 > ![400](Attachments/Pasted%20image%2020241210100341.png)
4. 名字的作用域及名字绑定
## 7 .2 存储分配策略
1. **静态存储分配**
 > ![](Attachments/Pasted%20image%2020241210095515.png)


2. **栈式存储分配**
 > ![450](Attachments/Pasted%20image%2020241210095556.png)


3. **堆式存储分配**

## 7 .3 非局部名字的访问
1. **程序块**
 > ![400](Attachments/Pasted%20image%2020241210100608.png)


2. 静态作用域规则下非局部名字的访问
 > 1. **非嵌套过程**
 > 静态局部变量，采用静态存储方式。并且保存了前次被调用后留下的值
 > 2. **嵌套过程**
 > 被调用过程活动记录的访问链指向 其直接外层过程的最新活动的活动记录！

3. 动态作用域规则下非局部名字的访问
 
## 7 .4 参数传递机制
参数传递机制：
**传值调用**、**引用调用**、**复制恢复**、**传名调用**

1. **传值调用（call-by-value）**
 > 最一般、最简单的参数传递方法。
 > 先计算出实参的值，然后将其右值传递给被调用过程。
 > 参数值在被调用过程执行时如同常数。
 > 用相应的实参的值替代过程体中出现的所有形参

![](Attachments/Pasted%20image%2020241210110220.png)

![400](Attachments/Pasted%20image%2020241210111552.png)

![400](Attachments/Pasted%20image%2020241210114205.png)

# 第9章、中间代码优化

## 9 .2 基本块及控制流图
- **基本块**
 > 具有原子性的一组连续语句序列。
 > 控制从第一条语句（入口语句）流入，从最后一条语句（出口语句）流出，中途没有停止或分支。
- **基本块的划分方法**
 > ![200](Attachments/Pasted%20image%2020241224095643.png)
![450](Attachments/Pasted%20image%2020241224101107.png)

## 9 .3 基本块优化
1. 常数合并及常数传播
   常数直接算出来

2. 删除公共表达式
   重复的计算表达式直接等于第一次计算的就行

3. 复制传播
   在 2 的基础上，直接使用第一次计算的

4. 削弱计算强度
   幂变成乘，乘变成加

5. 改变计算次序


## 9 .4 循环优化
1. 循环展开
   字面意思

2. 代码外提/频度削弱
   循环内的“常量计算”提到循环外面

3. 削弱计算强度
   同上

4. 删除归纳变量
   for 循环里的 i 和“依赖于”i 的变量，只需要留一个+删除死代码
# 第10章、目标代码生成
10.1 目标代码生成概述

## 10 .2 下次引用信息
- **算法（计算下次引用信息）**
 > ![450](Attachments/Pasted%20image%2020241224114034.png)

10.3 一个简单的代码生成程序
