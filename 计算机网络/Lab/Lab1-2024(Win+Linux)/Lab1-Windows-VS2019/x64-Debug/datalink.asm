; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33523.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__6A72211D_concurrencysal@h DB 01H
__CC30173B_sal@h DB 01H
__7EF21AAA_vadefs@h DB 01H
__657088F7_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__CDDAF8CA_errno@h DB 01H
__74F97FEA_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__A4E8AA12_datalink@h DB 01H
__3220CA03_stdarg@h DB 01H
__7935898B_lprintf@h DB 01H
__7A0070CF_protocol@h DB 01H
__333A739A_datalink@c DB 01H
msvcjmc	ENDS
PUBLIC	main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0DK@FAGGCAFG@Designed?5by?5Zhang?5Chenyang?0?5bui@ ; `string'
PUBLIC	??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ ; `string'
PUBLIC	??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CO@KGLHHPJC@Recv?5frame?5is?5not?5lower?5bound?0?5@ ; `string'
PUBLIC	??_C@_0CM@ILJEGABI@Put?5packet?5to?5network?5layer?5seq@ ; `string'
PUBLIC	??_C@_0BH@LFIEOPPF@Recv?5NAK?5?5?$CFd?5?9?9?$CFdbyte?6@ ; `string'
PUBLIC	??_C@_0CD@MEKNEOEC@?9?9?9?9?5DATA?5?$CFd?5timeout?0?5resend?5?9?9@ ; `string'
EXTRN	__report_rangecheckfailure:PROC
EXTRN	memcpy:PROC
EXTRN	lprintf:PROC
EXTRN	protocol_init:PROC
EXTRN	wait_for_event:PROC
EXTRN	enable_network_layer:PROC
EXTRN	disable_network_layer:PROC
EXTRN	get_packet:PROC
EXTRN	put_packet:PROC
EXTRN	recv_frame:PROC
EXTRN	send_frame:PROC
EXTRN	crc32:PROC
EXTRN	start_timer:PROC
EXTRN	stop_timer:PROC
EXTRN	start_ack_timer:PROC
EXTRN	stop_ack_timer:PROC
EXTRN	dbg_event:PROC
EXTRN	dbg_frame:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
phl_ready DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$between DD imagerel between
	DD	imagerel between+186
	DD	imagerel $unwind$between
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$put_frame DD imagerel put_frame
	DD	imagerel put_frame+113
	DD	imagerel $unwind$put_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send__frame DD imagerel send__frame
	DD	imagerel send__frame+399
	DD	imagerel $unwind$send__frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN41
	DD	imagerel $LN41+1510
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CD@MEKNEOEC@?9?9?9?9?5DATA?5?$CFd?5timeout?0?5resend?5?9?9@
CONST	SEGMENT
??_C@_0CD@MEKNEOEC@?9?9?9?9?5DATA?5?$CFd?5timeout?0?5resend?5?9?9@ DB '--'
	DB	'-- DATA %d timeout, resend ----', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LFIEOPPF@Recv?5NAK?5?5?$CFd?5?9?9?$CFdbyte?6@
CONST	SEGMENT
??_C@_0BH@LFIEOPPF@Recv?5NAK?5?5?$CFd?5?9?9?$CFdbyte?6@ DB 'Recv NAK  %d '
	DB	'--%dbyte', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ILJEGABI@Put?5packet?5to?5network?5layer?5seq@
CONST	SEGMENT
??_C@_0CM@ILJEGABI@Put?5packet?5to?5network?5layer?5seq@ DB 'Put packet t'
	DB	'o network layer seq:%d, ID: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KGLHHPJC@Recv?5frame?5is?5not?5lower?5bound?0?5@
CONST	SEGMENT
??_C@_0CO@KGLHHPJC@Recv?5frame?5is?5not?5lower?5bound?0?5@ DB 'Recv frame'
	DB	' is not lower bound, NAK sent back', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Recv DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@ DB 'Recv ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
CONST	SEGMENT
??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ DB '*'
	DB	'*** Receiver Error, Bad CRC Checksum', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@FAGGCAFG@Designed?5by?5Zhang?5Chenyang?0?5bui@
CONST	SEGMENT
??_C@_0DK@FAGGCAFG@Designed?5by?5Zhang?5Chenyang?0?5bui@ DB 'Designed by '
	DB	'Zhang Chenyang, build: May 18 2024  14:20:05', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@ DB 'Send NAK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@ DB 'Send ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Send DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
no_nak	DB	01H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	05cdH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	025054619H
	DD	0118231dH
	DD	0700b0929H
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	04930H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
main$rtcName$0 DB 069H
	DB	06eH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+1
main$rtcName$1 DB 06fH
	DB	075H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
main$rtcName$2 DB 061H
	DB	072H
	DB	072H
	DB	069H
	DB	076H
	DB	065H
	DB	064H
	DB	00H
main$rtcName$3 DB 061H
	DB	072H
	DB	067H
	DB	00H
main$rtcName$4 DB 066H
	DB	00H
	ORG $+2
main$rtcVarDesc DD 041b0H
	DD	0108H
	DQ	FLAT:main$rtcName$4
	DD	04184H
	DD	04H
	DQ	FLAT:main$rtcName$3
	DD	040e8H
	DD	020H
	DQ	FLAT:main$rtcName$2
	DD	020d0H
	DD	02000H
	DQ	FLAT:main$rtcName$1
	DD	0b0H
	DD	02000H
	DQ	FLAT:main$rtcName$0
	ORG $+240
main$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:main$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	043H
	DW	0176H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send__frame DD 025054a19H
	DD	011b2320H
	DD	070140043H
	DD	05013H
	DD	imagerel __GSHandlerCheck
	DD	0208H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
send__frame$rtcName$0 DB 073H
	DB	00H
	ORG $+14
send__frame$rtcVarDesc DD 030H
	DD	0108H
	DQ	FLAT:send__frame$rtcName$0
	ORG $+48
send__frame$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:send__frame$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$put_frame DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$between DD 025051b01H
	DD	0116231bH
	DD	0700f001fH
	DD	0500eH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT main
_TEXT	SEGMENT
ack_expected$ = 4
next_frame_to_send$ = 36
frame_expected$ = 68
too_far$ = 100
in_buf$ = 144
out_buf$ = 8368
arrived$ = 16584
nbuffered$ = 16644
i$8 = 16676
event$ = 16708
arg$ = 16740
f$ = 16784
len$ = 17076
$T9 = 18648
$T10 = 18680
tv203 = 18692
tv74 = 18692
tv178 = 18696
__$ArrayPad$ = 18704
argc$ = 18752
argv$ = 18760
main	PROC						; COMDAT

; 79   : int main(int argc, char** argv) {

$LN41:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	mov	eax, 18760				; 00004948H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 4298				; 000010caH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+18792]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__333A739A_datalink@c
	call	__CheckForDebuggerJustMyCode

; 80   :     seq_nr ack_expected = 0;        // 发送窗口下限

	mov	BYTE PTR ack_expected$[rbp], 0

; 81   :     seq_nr next_frame_to_send = 0;  // 发送窗口上限+1

	mov	BYTE PTR next_frame_to_send$[rbp], 0

; 82   :     seq_nr frame_expected = 0;      // 下一个准备接收的帧序号,接收窗口下限

	mov	BYTE PTR frame_expected$[rbp], 0

; 83   :     seq_nr too_far = NR_BUFS;       // 接收窗口上限+1

	mov	BYTE PTR too_far$[rbp], 32		; 00000020H

; 84   : 
; 85   :     packet in_buf[NR_BUFS];    // 接收窗口缓存
; 86   :     packet out_buf[NR_BUFS];   // 发送窗口缓存
; 87   :     boolean arrived[NR_BUFS];  // 表示in_buf的占用情况
; 88   :     seq_nr nbuffered = 0;      // 表示in_buf中已接收但未确认的帧个数

	mov	BYTE PTR nbuffered$[rbp], 0

; 89   : 
; 90   :     for (int i = 0; i < NR_BUFS; ++i)

	mov	DWORD PTR i$8[rbp], 0
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR i$8[rbp]
	inc	eax
	mov	DWORD PTR i$8[rbp], eax
$LN4@main:
	cmp	DWORD PTR i$8[rbp], 32			; 00000020H
	jge	SHORT $LN3@main

; 91   :         arrived[i] = 0;  // 接收缓冲全部初始化为空

	movsxd	rax, DWORD PTR i$8[rbp]
	mov	QWORD PTR $T9[rbp], rax
	cmp	QWORD PTR $T9[rbp], 32			; 00000020H
	jae	SHORT $LN37@main
	jmp	SHORT $LN38@main
$LN37@main:
	call	__report_rangecheckfailure
$LN38@main:
	mov	rax, QWORD PTR $T9[rbp]
	mov	BYTE PTR arrived$[rbp+rax], 0
	jmp	SHORT $LN2@main
$LN3@main:

; 92   : 
; 93   :     int event;    // 事件类型
; 94   :     int arg;      // 超时计时器的序号
; 95   :     Frame f;      // 接收到的数据帧
; 96   :     int len = 0;  // 接收到的数据帧的长度

	mov	DWORD PTR len$[rbp], 0

; 97   : 
; 98   :     protocol_init(argc, argv);  // 协议初始化

	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	protocol_init

; 99   :     lprintf("Designed by Zhang Chenyang, build: " __DATE__

	lea	rcx, OFFSET FLAT:??_C@_0DK@FAGGCAFG@Designed?5by?5Zhang?5Chenyang?0?5bui@
	call	lprintf

; 100  :             "  "__TIME__
; 101  :             "\n");
; 102  : 
; 103  :     disable_network_layer();

	call	disable_network_layer
$LN5@main:

; 104  : 
; 105  :     for (;;) {
; 106  :         // 等待事件发生
; 107  :         event = wait_for_event(&arg);

	lea	rcx, QWORD PTR arg$[rbp]
	call	wait_for_event
	mov	DWORD PTR event$[rbp], eax

; 108  : 
; 109  :         switch (event) {

	mov	eax, DWORD PTR event$[rbp]
	mov	DWORD PTR tv74[rbp], eax
	cmp	DWORD PTR tv74[rbp], 0
	je	SHORT $LN14@main
	cmp	DWORD PTR tv74[rbp], 1
	je	$LN17@main
	cmp	DWORD PTR tv74[rbp], 2
	je	$LN18@main
	cmp	DWORD PTR tv74[rbp], 3
	je	$LN32@main
	cmp	DWORD PTR tv74[rbp], 4
	je	$LN33@main
	jmp	$LN8@main
$LN14@main:

; 110  :             case NETWORK_LAYER_READY:
; 111  :                 get_packet(out_buf[next_frame_to_send % NR_BUFS]);                     // 获取待发送帧

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR out_buf$[rbp+rax]
	mov	rcx, rax
	call	get_packet

; 112  :                 nbuffered++;                                                           // 已发送帧增加

	movzx	eax, BYTE PTR nbuffered$[rbp]
	inc	al
	mov	BYTE PTR nbuffered$[rbp], al

; 113  :                 send__frame(FRAME_DATA, next_frame_to_send, frame_expected, out_buf);  // 发送数据帧

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, BYTE PTR next_frame_to_send$[rbp]
	mov	cl, 1
	call	send__frame

; 114  :                 inc(next_frame_to_send);                                               // 发送窗口上限向前滑动

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	cmp	eax, 63					; 0000003fH
	jge	SHORT $LN15@main
	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	inc	al
	mov	BYTE PTR next_frame_to_send$[rbp], al
	jmp	SHORT $LN16@main
$LN15@main:
	mov	BYTE PTR next_frame_to_send$[rbp], 0
$LN16@main:

; 115  :                 break;

	jmp	$LN8@main
$LN17@main:

; 116  : 
; 117  :             // 流量控制
; 118  :             case PHYSICAL_LAYER_READY:
; 119  :                 phl_ready = 1;  // 物理层已准备好

	mov	DWORD PTR phl_ready, 1

; 120  :                 break;

	jmp	$LN8@main
$LN18@main:

; 121  : 
; 122  :             case FRAME_RECEIVED:
; 123  :                 len = recv_frame((unsigned char*)&f, sizeof f);  // 接收数据帧 f

	mov	edx, 264				; 00000108H
	lea	rcx, QWORD PTR f$[rbp]
	call	recv_frame
	mov	DWORD PTR len$[rbp], eax

; 124  : 
; 125  :                 // 查错
; 126  :                 if (len < 6 || crc32((unsigned char*)&f, len) != 0) {

	cmp	DWORD PTR len$[rbp], 6
	jl	SHORT $LN20@main
	mov	edx, DWORD PTR len$[rbp]
	lea	rcx, QWORD PTR f$[rbp]
	call	crc32
	test	eax, eax
	je	SHORT $LN19@main
$LN20@main:

; 127  :                     dbg_event("**** Receiver Error, Bad CRC Checksum\n");

	lea	rcx, OFFSET FLAT:??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
	call	dbg_event

; 128  :                     // 收到错误帧，且没有发过NAK，则发送NAK
; 129  :                     // if (no_nak) {
; 130  :                     send__frame(FRAME_NAK, 0, frame_expected, out_buf);  // 第2,4个参数默认,frame_expected就是出错的帧,发送一个NAK帧

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 3
	call	send__frame

; 131  :                     //}
; 132  :                     break;  // 帧错误,丢弃

	jmp	$LN8@main
$LN19@main:

; 133  :                 }
; 134  : 
; 135  :                 // 收到单独的 ACK
; 136  :                 if (f.kind == FRAME_ACK)

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 2
	jne	SHORT $LN21@main

; 137  :                     dbg_frame("Recv ACK  %d\n", f.ack);

	movzx	eax, BYTE PTR f$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
	call	dbg_frame
$LN21@main:

; 138  : 
; 139  :                 // 收到数据帧
; 140  :                 if (f.kind == FRAME_DATA) {

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 1
	jne	$LN22@main

; 141  :                     dbg_frame("Recv DATA %d %d, ID %d\n", f.seq,

	movsx	eax, WORD PTR f$[rbp+3]
	movzx	ecx, BYTE PTR f$[rbp+1]
	movzx	edx, BYTE PTR f$[rbp+2]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	dbg_frame

; 142  :                               f.ack, *(short*)f.data);
; 143  : 
; 144  :                     // 收到的帧不是期望收到的帧且没有发过NAK
; 145  :                     if (f.seq != frame_expected && no_nak) {

	movzx	eax, BYTE PTR f$[rbp+2]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	cmp	eax, ecx
	je	SHORT $LN23@main
	movzx	eax, BYTE PTR no_nak
	test	eax, eax
	je	SHORT $LN23@main

; 146  :                         dbg_event("Recv frame is not lower bound, NAK sent back\n");

	lea	rcx, OFFSET FLAT:??_C@_0CO@KGLHHPJC@Recv?5frame?5is?5not?5lower?5bound?0?5@
	call	dbg_event

; 147  :                         send__frame(FRAME_NAK, 0, frame_expected, out_buf);  // 发送NAK帧

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 3
	call	send__frame
$LN23@main:

; 148  :                     }
; 149  : 
; 150  :                     // 判断接收到的帧是否在接收窗口上下界之间,并判断接收buffer中还有没有属于它的位置
; 151  :                     if (between(frame_expected, f.seq, too_far) && (arrived[f.seq % NR_BUFS] == 0)) {

	movzx	r8d, BYTE PTR too_far$[rbp]
	movzx	edx, BYTE PTR f$[rbp+2]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	call	between
	movzx	eax, al
	test	eax, eax
	je	$LN24@main
	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	movzx	eax, BYTE PTR arrived$[rbp+rax]
	test	eax, eax
	jne	$LN24@main

; 152  :                         arrived[f.seq % NR_BUFS] = 1;  // 将接收缓冲的对应位置占下

	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	mov	BYTE PTR arrived$[rbp+rax], 1

; 153  : 
; 154  :                         // len=PKT_LEN+3, len=len+4, len在PKT_LEN的基础上+7, 所以包长=len-7
; 155  :                         memcpy(in_buf[f.seq % NR_BUFS], f.data, len - 7);  // 将该包加入接收缓冲中

	mov	eax, DWORD PTR len$[rbp]
	sub	eax, 7
	cdqe
	mov	QWORD PTR tv178[rbp], rax
	movzx	ecx, BYTE PTR f$[rbp+2]
	mov	eax, ecx
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR in_buf$[rbp+rax]
	mov	rcx, QWORD PTR tv178[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR f$[rbp+3]
	mov	rcx, rax
	call	memcpy
$LN10@main:

; 156  : 
; 157  :                         while (arrived[frame_expected % NR_BUFS]) {  // 滑动更新接收窗口和接收缓冲区

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	movzx	eax, BYTE PTR arrived$[rbp+rax]
	test	eax, eax
	je	$LN11@main

; 158  :                             dbg_event("Put packet to network layer seq:%d, ID: %d\n", frame_expected, *(short*)(in_buf[frame_expected % NR_BUFS]));

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	movsx	eax, WORD PTR in_buf$[rbp+rax]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:??_C@_0CM@ILJEGABI@Put?5packet?5to?5network?5layer?5seq@
	call	dbg_event

; 159  :                             put_packet(in_buf[frame_expected % NR_BUFS], len - 7);  // 将缓冲区最早到达的帧上交网络层

	mov	eax, DWORD PTR len$[rbp]
	sub	eax, 7
	mov	DWORD PTR tv203[rbp], eax
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	mov	eax, ecx
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR in_buf$[rbp+rax]
	mov	ecx, DWORD PTR tv203[rbp]
	mov	edx, ecx
	mov	rcx, rax
	call	put_packet

; 160  :                             arrived[frame_expected % NR_BUFS] = 0;                  // 接收缓冲区空出这个位置

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	mov	QWORD PTR $T10[rbp], rax
	cmp	QWORD PTR $T10[rbp], 32			; 00000020H
	jae	SHORT $LN39@main
	jmp	SHORT $LN40@main
$LN39@main:
	call	__report_rangecheckfailure
$LN40@main:
	mov	rax, QWORD PTR $T10[rbp]
	mov	BYTE PTR arrived$[rbp+rax], 0

; 161  :                             no_nak = 1;                                             // 新的一帧没有发送过nak

	mov	BYTE PTR no_nak, 1

; 162  :                             inc(frame_expected);                                    // 滑动下界

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cmp	eax, 63					; 0000003fH
	jge	SHORT $LN25@main
	movzx	eax, BYTE PTR frame_expected$[rbp]
	inc	al
	mov	BYTE PTR frame_expected$[rbp], al
	jmp	SHORT $LN26@main
$LN25@main:
	mov	BYTE PTR frame_expected$[rbp], 0
$LN26@main:

; 163  :                             inc(too_far);                                           // 滑动上界

	movzx	eax, BYTE PTR too_far$[rbp]
	cmp	eax, 63					; 0000003fH
	jge	SHORT $LN27@main
	movzx	eax, BYTE PTR too_far$[rbp]
	inc	al
	mov	BYTE PTR too_far$[rbp], al
	jmp	SHORT $LN28@main
$LN27@main:
	mov	BYTE PTR too_far$[rbp], 0
$LN28@main:

; 164  :                             start_ack_timer(ACK_TIMER);                             // 开始ACK计时,准备返回ACK

	mov	ecx, 300				; 0000012cH
	call	start_ack_timer

; 165  :                         }

	jmp	$LN10@main
$LN11@main:
$LN24@main:
$LN22@main:

; 166  :                     }
; 167  :                 }
; 168  : 
; 169  :                 // 收到NAK
; 170  :                 if (f.kind == FRAME_NAK && between(ack_expected, (f.ack + 1) % (MAX_SEQ + 1), next_frame_to_send)) {

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 3
	jne	SHORT $LN29@main
	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	movzx	r8d, BYTE PTR next_frame_to_send$[rbp]
	movzx	edx, al
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	call	between
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@main

; 171  :                     dbg_frame("Recv NAK  %d --%dbyte\n", (f.ack + 1) % (MAX_SEQ + 1), len);

	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	mov	r8d, DWORD PTR len$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BH@LFIEOPPF@Recv?5NAK?5?5?$CFd?5?9?9?$CFdbyte?6@
	call	dbg_frame

; 172  :                     // 如果返回的NAK就是ack_expected,那就将这一帧重发一遍
; 173  :                     // f.ack表示接收方成功接收的最后一帧,(f.ack + 1) % (MAX_SEQ + 1)就是接收失败的那一帧
; 174  :                     send__frame(FRAME_DATA, (f.ack + 1) % (MAX_SEQ + 1), frame_expected, out_buf);

	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, al
	mov	cl, 1
	call	send__frame
$LN29@main:
$LN12@main:

; 175  :                 }
; 176  : 
; 177  :                 // 累计确认
; 178  :                 while (between(ack_expected, f.ack, next_frame_to_send)) {

	movzx	r8d, BYTE PTR next_frame_to_send$[rbp]
	movzx	edx, BYTE PTR f$[rbp+1]
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	call	between
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@main

; 179  :                     nbuffered--;               // 发送缓冲弹出确认接收的帧

	movzx	eax, BYTE PTR nbuffered$[rbp]
	dec	al
	mov	BYTE PTR nbuffered$[rbp], al

; 180  :                     stop_timer(ack_expected);  // 下限停止计时

	movzx	eax, BYTE PTR ack_expected$[rbp]
	mov	ecx, eax
	call	stop_timer

; 181  :                     inc(ack_expected);         // 发送窗口下限向前滑动

	movzx	eax, BYTE PTR ack_expected$[rbp]
	cmp	eax, 63					; 0000003fH
	jge	SHORT $LN30@main
	movzx	eax, BYTE PTR ack_expected$[rbp]
	inc	al
	mov	BYTE PTR ack_expected$[rbp], al
	jmp	SHORT $LN31@main
$LN30@main:
	mov	BYTE PTR ack_expected$[rbp], 0
$LN31@main:

; 182  :                 }

	jmp	SHORT $LN12@main
$LN13@main:

; 183  :                 break;

	jmp	SHORT $LN8@main
$LN32@main:

; 184  : 
; 185  :             case DATA_TIMEOUT:  // 超时未收到ack
; 186  :                 dbg_event("---- DATA %d timeout, resend ----\n", arg);

	mov	edx, DWORD PTR arg$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CD@MEKNEOEC@?9?9?9?9?5DATA?5?$CFd?5timeout?0?5resend?5?9?9@
	call	dbg_event

; 187  :                 send__frame(FRAME_DATA, arg, frame_expected, out_buf);  // 重发超时的那一帧

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, BYTE PTR arg$[rbp]
	mov	cl, 1
	call	send__frame

; 188  :                 break;

	jmp	SHORT $LN8@main
$LN33@main:

; 189  : 
; 190  :             case ACK_TIMEOUT:  // ACK 定时器超时
; 191  :                 send__frame(FRAME_ACK, 0, frame_expected, out_buf);

	lea	r9, QWORD PTR out_buf$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 2
	call	send__frame
$LN8@main:

; 192  :                 break;
; 193  :         }
; 194  : 
; 195  :         if (nbuffered < NR_BUFS && phl_ready)  // 发送窗口为NR_BUFS,缓冲满时暂停发送

	movzx	eax, BYTE PTR nbuffered$[rbp]
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN34@main
	cmp	DWORD PTR phl_ready, 0
	je	SHORT $LN34@main

; 196  :             enable_network_layer();

	call	enable_network_layer
	jmp	SHORT $LN35@main
$LN34@main:

; 197  :         else
; 198  :             disable_network_layer();

	call	disable_network_layer
$LN35@main:

; 199  :     }

	jmp	$LN5@main
$LN36@main:

; 200  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:main$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+18728]
	pop	rdi
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT send__frame
_TEXT	SEGMENT
s$ = 16
__$ArrayPad$ = 488
fk$ = 528
frame_nr$ = 536
frame_expected$ = 544
buffer$ = 552
send__frame PROC					; COMDAT

; 54   : static void send__frame(frame_kind fk, seq_nr frame_nr, seq_nr frame_expected, packet buffer[]) {

	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 536				; 00000218H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+568]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__333A739A_datalink@c
	call	__CheckForDebuggerJustMyCode

; 55   :     Frame s;
; 56   : 
; 57   :     s.kind = fk;

	movzx	eax, BYTE PTR fk$[rbp]
	mov	BYTE PTR s$[rbp], al

; 58   :     s.seq = frame_nr;

	movzx	eax, BYTE PTR frame_nr$[rbp]
	mov	BYTE PTR s$[rbp+2], al

; 59   :     s.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1);  // 捎带ACK

	movzx	eax, BYTE PTR frame_expected$[rbp]
	add	eax, 63					; 0000003fH
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	and	eax, 63					; 0000003fH
	sub	eax, edx
	mov	BYTE PTR s$[rbp+1], al

; 60   :     stop_ack_timer();                                    // ACK 已捎带，停止计时

	call	stop_ack_timer

; 61   : 
; 62   :     if (fk == FRAME_DATA) {

	movzx	eax, BYTE PTR fk$[rbp]
	cmp	eax, 1
	jne	SHORT $LN2@send__fram

; 63   :         memcpy(s.data, buffer[frame_nr % NR_BUFS], PKT_LEN);  // 将out_buf中对应该nr的内存复拷贝出来

	movzx	eax, BYTE PTR frame_nr$[rbp]
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, 256				; 00000100H
	mov	rdx, rax
	lea	rcx, QWORD PTR s$[rbp+3]
	call	memcpy

; 64   : 
; 65   :         dbg_frame("Send DATA %d %d, ID %d\n", s.seq, s.ack, *(short*)s.data);

	movsx	eax, WORD PTR s$[rbp+3]
	movzx	ecx, BYTE PTR s$[rbp+1]
	movzx	edx, BYTE PTR s$[rbp+2]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	dbg_frame

; 66   : 
; 67   :         put_frame((unsigned char*)&s, 3 + PKT_LEN);  // 在info后插入4字节CRC

	mov	edx, 259				; 00000103H
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame

; 68   :         start_timer(frame_nr, DATA_TIMER);           // 开始计时,等待ACK

	movzx	eax, BYTE PTR frame_nr$[rbp]
	mov	edx, 2000				; 000007d0H
	mov	ecx, eax
	call	start_timer
	jmp	SHORT $LN3@send__fram
$LN2@send__fram:

; 69   :     } else if (fk == FRAME_ACK) {

	movzx	eax, BYTE PTR fk$[rbp]
	cmp	eax, 2
	jne	SHORT $LN4@send__fram

; 70   :         dbg_frame("Send ACK  %d\n", s.ack);

	movzx	eax, BYTE PTR s$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@MEIGFFMO@Send?5ACK?5?5?$CFd?6@
	call	dbg_frame

; 71   :         put_frame((unsigned char*)&s, 2);  // 在ack后插入4字节crc

	mov	edx, 2
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame

; 72   :     } else {

	jmp	SHORT $LN5@send__fram
$LN4@send__fram:

; 73   :         dbg_frame("Send NAK  %d\n", frame_expected);  // 出错帧NAK的序号为上一个成功帧的序号f.ack的下一帧

	movzx	eax, BYTE PTR frame_expected$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@FJBKJNGC@Send?5NAK?5?5?$CFd?6@
	call	dbg_frame

; 74   :         no_nak = 0;

	mov	BYTE PTR no_nak, 0

; 75   :         put_frame((unsigned char*)&s, 2);  // 在ack后插入4字节crc

	mov	edx, 2
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame
$LN5@send__fram:
$LN3@send__fram:

; 76   :     }
; 77   : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:send__frame$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+504]
	pop	rdi
	pop	rbp
	ret	0
send__frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT put_frame
_TEXT	SEGMENT
frame$ = 224
len$ = 232
put_frame PROC						; COMDAT

; 42   : static void put_frame(unsigned char* frame, int len) {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__333A739A_datalink@c
	call	__CheckForDebuggerJustMyCode

; 43   :     *(unsigned int*)(frame + len) = crc32(frame, len);  // 添加32bit(4B)的校验位

	mov	edx, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR frame$[rbp]
	call	crc32
	movsxd	rcx, DWORD PTR len$[rbp]
	mov	rdx, QWORD PTR frame$[rbp]
	mov	DWORD PTR [rdx+rcx], eax

; 44   :     send_frame(frame, len + 4);

	mov	eax, DWORD PTR len$[rbp]
	add	eax, 4
	mov	edx, eax
	mov	rcx, QWORD PTR frame$[rbp]
	call	send_frame

; 45   :     phl_ready = 0;  // 每次发完,先假设物理层缓存已满

	mov	DWORD PTR phl_ready, 0

; 46   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
put_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT between
_TEXT	SEGMENT
tv82 = 192
a$ = 240
b$ = 248
c$ = 256
between	PROC						; COMDAT

; 35   : static boolean between(seq_nr a, seq_nr b, seq_nr c) {

	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__333A739A_datalink@c
	call	__CheckForDebuggerJustMyCode

; 36   :     return ((a <= b && b < c) || (c < a && b < c) || (c < a && a <= b));

	movzx	eax, BYTE PTR a$[rbp]
	movzx	ecx, BYTE PTR b$[rbp]
	cmp	eax, ecx
	jg	SHORT $LN3@between
	movzx	eax, BYTE PTR b$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	cmp	eax, ecx
	jl	SHORT $LN5@between
$LN3@between:
	movzx	eax, BYTE PTR c$[rbp]
	movzx	ecx, BYTE PTR a$[rbp]
	cmp	eax, ecx
	jge	SHORT $LN4@between
	movzx	eax, BYTE PTR b$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	cmp	eax, ecx
	jl	SHORT $LN5@between
$LN4@between:
	movzx	eax, BYTE PTR c$[rbp]
	movzx	ecx, BYTE PTR a$[rbp]
	cmp	eax, ecx
	jge	SHORT $LN6@between
	movzx	eax, BYTE PTR a$[rbp]
	movzx	ecx, BYTE PTR b$[rbp]
	cmp	eax, ecx
	jle	SHORT $LN5@between
$LN6@between:
	mov	DWORD PTR tv82[rbp], 0
	jmp	SHORT $LN7@between
$LN5@between:
	mov	DWORD PTR tv82[rbp], 1
$LN7@between:
	movzx	eax, BYTE PTR tv82[rbp]

; 37   : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
between	ENDP
_TEXT	ENDS
END
