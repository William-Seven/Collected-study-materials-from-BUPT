; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33523.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	log_file
PUBLIC	??_C@_0BB@JCEFLFJE@0123456789abcdef@		; `string'
_BSS	SEGMENT
log_file DQ	01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__D0DFFAC6_winpackagefamily@h DB 01H
__D0D0F397_winapifamily@h DB 01H
__94A3FDDD_sdkddkver@h DB 01H
__6A72211D_concurrencysal@h DB 01H
__CC30173B_sal@h DB 01H
__7EF21AAA_vadefs@h DB 01H
__657088F7_vcruntime@h DB 01H
__6B66097A_excpt@h DB 01H
__3220CA03_stdarg@h DB 01H
__1C9F390F_specstrings_undef@h DB 01H
__36A21E95_specstrings_strict@h DB 01H
__452FE810_sdv_driverspecs@h DB 01H
__30F344B3_driverspecs@h DB 01H
__BD886E18_specstrings@h DB 01H
__6569C2CA_corecrt@h DB 01H
__5DB64B66_corecrt_wctype@h DB 01H
__B2D2BA86_ctype@h DB 01H
__BF9C347F_kernelspecs@h DB 01H
__79C7FC57_basetsd@h DB 01H
__CDDAF8CA_errno@h DB 01H
__74F97FEA_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__D545DD43_guiddef@h DB 01H
__DF4F952E_pshpack4@h DB 01H
__7FCD0577_poppack@h DB 01H
__DBC2E99C_pshpack2@h DB 01H
__D6556C4A_pshpack8@h DB 01H
__D98457C5_pshpack1@h DB 01H
__614C4572_apiset@h DB 01H
__8500295D_ktmtypes@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__156BD51A_minwindef@h DB 01H
__F9B9A8F7_windef@h DB 01H
__BD2C4590_apisetcconv@h DB 01H
__18251742_minwinbase@h DB 01H
__23611203_apiquery2@h DB 01H
__C914CD48_processenv@h DB 01H
__996311FD_fileapi@h DB 01H
__41AEF397_fileapifromapp@h DB 01H
__65579FF3_debugapi@h DB 01H
__476FCB5A_utilapiset@h DB 01H
__089D2E42_handleapi@h DB 01H
__B16F04F5_errhandlingapi@h DB 01H
__81CCB02F_fibersapi@h DB 01H
__A9B4C5F0_namedpipeapi@h DB 01H
__C209F2C8_profileapi@h DB 01H
__34C22DC8_heapapi@h DB 01H
__8A238485_ioapiset@h DB 01H
__4826BA69_synchapi@h DB 01H
__6A31599C_interlockedapi@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__7BB37CFA_sysinfoapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__6D078C0D_enclaveapi@h DB 01H
__3663CE50_threadpoollegacyapiset@h DB 01H
__E16717D9_threadpoolapiset@h DB 01H
__4A6035CC_jobapi@h DB 01H
__62EEB553_jobapi2@h DB 01H
__9F22E7EF_wow64apiset@h DB 01H
__E86B4A9A_libloaderapi@h DB 01H
__EB536E54_securitybaseapi@h DB 01H
__E915C287_namespaceapi@h DB 01H
__C66F44F2_systemtopologyapi@h DB 01H
__B6175B28_processtopologyapi@h DB 01H
__9E4AD838_securityappcontainer@h DB 01H
__F599FDAE_realtimeapiset@h DB 01H
__D4435474_winerror@h DB 01H
__F94F31E6_timezoneapi@h DB 01H
__B3ED30D4_winbase@h DB 01H
__E9F7D11F_wingdi@h DB 01H
__AC21C382_tvout@h DB 01H
__DB057BA3_winuser@h DB 01H
__A1BAD304_datetimeapi@h DB 01H
__30E2BD27_winnls@h DB 01H
__B7FF4B97_stringapiset@h DB 01H
__66C87297_wincontypes@h DB 01H
__1317218F_consoleapi@h DB 01H
__8D62D26D_consoleapi2@h DB 01H
__8CA0B85A_consoleapi3@h DB 01H
__CE39E65B_wincon@h DB 01H
__F6801ACC_verrsrc@h DB 01H
__1CB844D9_winver@h DB 01H
__D0CFA71C_reason@h DB 01H
__F3D58382_winreg@h DB 01H
__34C28572_wnnc@h DB 01H
__0617DE59_winnetwk@h DB 01H
__93AC9EF8_cderr@h DB 01H
__3AE29FFA_dde@h DB 01H
__48250249_ddeml@h DB 01H
__4605C6DD_dlgs@h DB 01H
__C826BBA2_lzexpand@h DB 01H
__B8DFB118_mmsyscom@h DB 01H
__EDC2A662_mciapi@h DB 01H
__87B17D5B_mmiscapi@h DB 01H
__0C4862FC_mmiscapi2@h DB 01H
__83F5D08C_playsoundapi@h DB 01H
__CA3F1D44_mmeapi@h DB 01H
__BD2270BE_timeapi@h DB 01H
__397CAA2F_joystickapi@h DB 01H
__05A21AEE_mmsystem@h DB 01H
__6E1DF0B6_nb30@h DB 01H
__75098885_rpcdcep@h DB 01H
__D8AC8DD5_rpcdce@h DB 01H
__2F1118EF_rpcnsi@h DB 01H
__0DE10DFC_rpcnterr@h DB 01H
__4497164E_rpcasync@h DB 01H
__06CA6763_rpc@h DB 01H
__C32EC2F2_shellapi@h DB 01H
__B289ECB8_winperf@h DB 01H
__07EA6B7C_inaddr@h DB 01H
__9ED0251E_winsock@h DB 01H
__FD938996_bcrypt@h DB 01H
__4E32BFB9_ncrypt@h DB 01H
__815AA9AD_dpapi@h DB 01H
__0B2E95FF_wincrypt@h DB 01H
__288F6C52_winefs@h DB 01H
__B3F2ECA2_rpcnsip@h DB 01H
__AFB43543_rpcsal@h DB 01H
__16A21838_rpcndr@h DB 01H
__5314805F_wtypesbase@h DB 01H
__6EEE3703_wtypes@h DB 01H
__A7113148_winioctl@h DB 01H
__C595A37C_winsmcrd@h DB 01H
__42C56FB7_winscard@h DB 01H
__C4703BCA_prsht@h DB 01H
__D4D77F19_winspool@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__B8895AF3_limits@h DB 01H
__B49664B7_stdlib@h DB 01H
__B47185B4_unknwnbase@h DB 01H
__B64C33F8_objidlbase@h DB 01H
__EA871F04_cguid@h DB 01H
__C78732AB_combaseapi@h DB 01H
__744BF5DA_unknwn@h DB 01H
__66C491E7_objidl@h DB 01H
__A217658B_oaidl@h DB 01H
__8485F416_propidlbase@h DB 01H
__65805CE1_coml2api@h DB 01H
__C7AD586F_oleidl@h DB 01H
__CBE55221_servprov@h DB 01H
__5B1E268A_msxml@h DB 01H
__1B3D3678_urlmon@h DB 01H
__EC5BC72C_propidl@h DB 01H
__0DD0E8F8_objbase@h DB 01H
__6DA674A0_oleauto@h DB 01H
__F7931962_ole2@h DB 01H
__870E9EB1_commdlg@h DB 01H
__A118E6DC_stralign@h DB 01H
__8B10FA9F_winsvc@h DB 01H
__BEDBF511_mcx@h DB 01H
__D3BCC989_ime_cmodes@h DB 01H
__B1694579_imm@h DB 01H
__4D4D253D_windows@h DB 01H
__64F617E8_types@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__91D68F2D_math@h DB 01H
__7935898B_lprintf@h DB 01H
__EEE75003_lprintf@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_0BB@JCEFLFJE@0123456789abcdef@
CONST	SEGMENT
??_C@_0BB@JCEFLFJE@0123456789abcdef@ DB '0123456789abcdef', 00H ; `string'
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	lprintf
PUBLIC	__v_lprintf
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@		; `string'
PUBLIC	??_C@_0BB@GHIALFFI@0000000000000000@		; `string'
PUBLIC	??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_05MAGFAFAN@?$CInil?$CJ@			; `string'
PUBLIC	??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@	; `string'
PUBLIC	??_C@_06OJHGLDPL@?$CInull?$CJ@			; `string'
PUBLIC	??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02MDDDDAID@0x@				; `string'
PUBLIC	??_C@_02FGLHBECB@0X@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	__real@0000000000000000
EXTRN	__imp__errno:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	strcpy:PROC
EXTRN	__imp_strerror:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	get_ms:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+158
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+184
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lprintf DD imagerel $LN3
	DD	imagerel $LN3+178
	DD	imagerel $unwind$lprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__v_lprintf DD imagerel $LN84
	DD	imagerel $LN84+2319
	DD	imagerel $unwind$__v_lprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$skip_to DD imagerel skip_to
	DD	imagerel skip_to+100
	DD	imagerel $unwind$skip_to
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output DD imagerel output
	DD	imagerel output+660
	DD	imagerel $unwind$output
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_pad DD imagerel write_pad
	DD	imagerel write_pad+204
	DD	imagerel $unwind$write_pad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$int64_str DD imagerel int64_str
	DD	imagerel int64_str+435
	DD	imagerel $unwind$int64_str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_string DD imagerel output_string
	DD	imagerel output_string+625
	DD	imagerel $unwind$output_string
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_integer DD imagerel output_integer
	DD	imagerel output_integer+1077
	DD	imagerel $unwind$output_integer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_double DD imagerel output_double
	DD	imagerel output_double+769
	DD	imagerel $unwind$output_double
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$output_memory_block DD imagerel output_memory_block
	DD	imagerel output_memory_block+861
	DD	imagerel $unwind$output_memory_block
pdata	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLHBECB@0X@
CONST	SEGMENT
??_C@_02FGLHBECB@0X@ DB '0X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDDDDAID@0x@
CONST	SEGMENT
??_C@_02MDDDDAID@0x@ DB '0x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@ DB '(%d) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJHGLDPL@?$CInull?$CJ@
CONST	SEGMENT
??_C@_06OJHGLDPL@?$CInull?$CJ@ DB '(null)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@
CONST	SEGMENT
??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@ DB '%%%zd.%zd%c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAGFAFAN@?$CInil?$CJ@
CONST	SEGMENT
??_C@_05MAGFAFAN@?$CInil?$CJ@ DB '(nil)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB '                '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHIALFFI@0000000000000000@
CONST	SEGMENT
??_C@_0BB@GHIALFFI@0000000000000000@ DB '0000000000000000', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@
CONST	SEGMENT
??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@ DB '%03d.%03d ', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?sol@?1??output@@9@9 DD 01H				; `output'::`2'::sol
	ORG $+4
?char_set@?1??output_memory_block@@9@9 DQ FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef@ ; `output_memory_block'::`2'::char_set
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	044H
	DW	0344H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_memory_block DD 045054b19H
	DD	011c4321H
	DD	07015004dH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0258H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
output_memory_block$rtcName$0 DB 073H
	DB	074H
	DB	072H
	DB	00H
	ORG $+12
output_memory_block$rtcVarDesc DD 050H
	DD	0100H
	DQ	FLAT:output_memory_block$rtcName$0
	ORG $+48
output_memory_block$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:output_memory_block$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03dH
	DW	02e8H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_double DD 045054419H
	DD	011d4322H
	DD	070160061H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	02f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
output_double$rtcName$0 DB 066H
	DB	06dH
	DB	074H
	DB	00H
output_double$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+8
output_double$rtcVarDesc DD 0b0H
	DD	0100H
	DQ	FLAT:output_double$rtcName$1
	DD	050H
	DD	040H
	DQ	FLAT:output_double$rtcName$0
	ORG $+96
output_double$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:output_double$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	044H
	DW	041cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_integer DD 045054b19H
	DD	011c4321H
	DD	07015004bH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0240H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
output_integer$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+12
output_integer$rtcVarDesc DD 050H
	DD	080H
	DQ	FLAT:output_integer$rtcName$0
	ORG $+48
output_integer$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:output_integer$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_string DD 025052201H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$int64_str DD 025052201H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_pad DD 025051701H
	DD	01122317H
	DD	0700b0025H
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	027bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output DD 025054219H
	DD	01132318H
	DD	0700c003bH
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
output$rtcName$0 DB 074H
	DB	069H
	DB	06dH
	DB	065H
	DB	073H
	DB	074H
	DB	061H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+6
output$rtcVarDesc DD 068H
	DD	020H
	DQ	FLAT:output$rtcName$0
	ORG $+48
output$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:output$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$skip_to DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	07d6H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__v_lprintf DD 055054219H
	DD	01135318H
	DD	0700c0061H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	02f0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
__v_lprintf$rtcName$0 DB 073H
	DB	00H
	ORG $+2
__v_lprintf$rtcName$1 DB 063H
	DB	068H
	DB	00H
	ORG $+9
__v_lprintf$rtcVarDesc DD 0134H
	DD	01H
	DQ	FLAT:__v_lprintf$rtcName$1
	DD	0d8H
	DD	08H
	DQ	FLAT:__v_lprintf$rtcName$0
	ORG $+96
__v_lprintf$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:__v_lprintf$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	099H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lprintf DD 025054c19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
lprintf$rtcName$0 DB 061H
	DB	072H
	DB	067H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+8
lprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:lprintf$rtcName$0
	ORG $+48
lprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:lprintf$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	09fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 025054c19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 035052201H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 035052201H
	DD	011d3322H
	DD	070160023H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT output_memory_block
_TEXT	SEGMENT
str$ = 16
s$ = 296
len$ = 328
__$ArrayPad$ = 536
ptr$ = 576
n$ = 584
width$ = 592
precision$ = 600
flag$ = 608
pad$ = 616
output_memory_block PROC				; COMDAT

; 322  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 616				; 00000268H
	lea	rbp, QWORD PTR [rsp+64]
	lea	rdi, QWORD PTR [rsp+64]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+648]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 323  :     static const char *char_set = "0123456789abcdef";
; 324  :     char str[256], *s;
; 325  :     size_t len = 0;

	mov	QWORD PTR len$[rbp], 0

; 326  :     
; 327  :     if (ptr == NULL) 

	cmp	QWORD PTR ptr$[rbp], 0
	jne	SHORT $LN4@output_mem

; 328  :         return output_string("(null)", 6, 0, width, precision, flag, pad, ' ');

	mov	BYTE PTR [rsp+56], 32			; 00000020H
	movzx	eax, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR precision$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	edx, 6
	lea	rcx, OFFSET FLAT:??_C@_06OJHGLDPL@?$CInull?$CJ@
	call	output_string
	jmp	$LN1@output_mem
$LN4@output_mem:

; 329  : 
; 330  :     s = str; 

	lea	rax, QWORD PTR str$[rbp]
	mov	QWORD PTR s$[rbp], rax

; 331  :     if (flag & F_HASH) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN5@output_mem

; 332  :         s += sprintf(s, "(%d) ", n);

	mov	r8d, DWORD PTR n$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_05LKLPEAOK@?$CI?$CFd?$CJ?5@
	mov	rcx, QWORD PTR s$[rbp]
	call	sprintf
	cdqe
	mov	rcx, QWORD PTR s$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR s$[rbp], rax
$LN5@output_mem:

; 333  : 
; 334  :     if (n > (sizeof(str) - 32) / 3) 

	movsxd	rax, DWORD PTR n$[rbp]
	cmp	rax, 74					; 0000004aH
	jbe	SHORT $LN6@output_mem

; 335  :         width = precision = 0;

	mov	QWORD PTR precision$[rbp], 0
	mov	rax, QWORD PTR precision$[rbp]
	mov	QWORD PTR width$[rbp], rax
$LN6@output_mem:
$LN2@output_mem:

; 336  :         
; 337  :     while (n > 0) {

	cmp	DWORD PTR n$[rbp], 0
	jle	$LN3@output_mem

; 338  :         if (pad != '0' && *ptr < 0x10) 

	cmp	DWORD PTR pad$[rbp], 48			; 00000030H
	je	SHORT $LN7@output_mem
	mov	rax, QWORD PTR ptr$[rbp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 16
	jge	SHORT $LN7@output_mem

; 339  :             *s++ = char_set[*ptr];

	mov	rax, QWORD PTR ptr$[rbp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR s$[rbp]
	mov	rdx, QWORD PTR ?char_set@?1??output_memory_block@@9@9
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
	jmp	SHORT $LN8@output_mem
$LN7@output_mem:

; 340  :         else {
; 341  :             *s++ = char_set[*ptr / 16];

	mov	rax, QWORD PTR ptr$[rbp]
	movzx	eax, BYTE PTR [rax]
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	cdqe
	mov	rcx, QWORD PTR s$[rbp]
	mov	rdx, QWORD PTR ?char_set@?1??output_memory_block@@9@9
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax

; 342  :             *s++ = char_set[*ptr % 16];

	mov	rax, QWORD PTR ptr$[rbp]
	movzx	eax, BYTE PTR [rax]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	mov	rcx, QWORD PTR s$[rbp]
	mov	rdx, QWORD PTR ?char_set@?1??output_memory_block@@9@9
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
$LN8@output_mem:

; 343  :         }
; 344  : 
; 345  :         n--;

	mov	eax, DWORD PTR n$[rbp]
	dec	eax
	mov	DWORD PTR n$[rbp], eax

; 346  :         if (n > 0)

	cmp	DWORD PTR n$[rbp], 0
	jle	SHORT $LN9@output_mem

; 347  :             *s++ = ' ';

	mov	rax, QWORD PTR s$[rbp]
	mov	BYTE PTR [rax], 32			; 00000020H
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
$LN9@output_mem:

; 348  : 
; 349  :         ptr++;

	mov	rax, QWORD PTR ptr$[rbp]
	inc	rax
	mov	QWORD PTR ptr$[rbp], rax

; 350  :         if (s - str > sizeof(str) - 4) {

	lea	rax, QWORD PTR str$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, 252				; 000000fcH
	jbe	SHORT $LN10@output_mem

; 351  :             len += output_string(str, s - str, 0, width, precision, flag, pad, ' ');

	lea	rax, QWORD PTR str$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rsp+56], 32			; 00000020H
	movzx	ecx, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], cl
	mov	ecx, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR precision$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR str$[rbp]
	call	output_string
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax

; 352  :             s = str;

	lea	rax, QWORD PTR str$[rbp]
	mov	QWORD PTR s$[rbp], rax
$LN10@output_mem:

; 353  :         }
; 354  :     }

	jmp	$LN2@output_mem
$LN3@output_mem:

; 355  : 
; 356  :     if (s != str) 

	lea	rax, QWORD PTR str$[rbp]
	cmp	QWORD PTR s$[rbp], rax
	je	SHORT $LN11@output_mem

; 357  :         len += output_string(str, s - str, 0, width, precision, flag, pad, ' ');

	lea	rax, QWORD PTR str$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rsp+56], 32			; 00000020H
	movzx	ecx, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], cl
	mov	ecx, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR precision$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR str$[rbp]
	call	output_string
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax
$LN11@output_mem:

; 358  : 
; 359  :     return len;

	mov	rax, QWORD PTR len$[rbp]
$LN1@output_mem:

; 360  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:output_memory_block$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+552]
	pop	rdi
	pop	rbp
	ret	0
output_memory_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT output_double
_TEXT	SEGMENT
fmt$ = 16
buf$ = 112
s$ = 392
p$ = 424
prefix_len$ = 456
sz$ = 488
tv94 = 692
__$ArrayPad$ = 696
d$ = 736
type$ = 744
width$ = 752
precision$ = 760
flag$ = 768
pad$ = 776
output_double PROC					; COMDAT

; 270  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	movsd	QWORD PTR [rsp+8], xmm0
	push	rbp
	push	rdi
	sub	rsp, 776				; 00000308H
	lea	rbp, QWORD PTR [rsp+64]
	lea	rdi, QWORD PTR [rsp+64]
	mov	ecx, 130				; 00000082H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 271  :     char fmt[64], buf[256], *s, *p;
; 272  :     size_t prefix_len = 0, sz;

	mov	QWORD PTR prefix_len$[rbp], 0

; 273  : 
; 274  :     if (width == 0) 

	cmp	QWORD PTR width$[rbp], 0
	jne	SHORT $LN8@output_dou

; 275  :         width = 1;

	mov	QWORD PTR width$[rbp], 1
$LN8@output_dou:

; 276  :     if (!(flag & F_DOT)) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN9@output_dou

; 277  :         precision = 6;

	mov	QWORD PTR precision$[rbp], 6
$LN9@output_dou:

; 278  :     if (d < 0.0) 

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR d$[rbp]
	jbe	SHORT $LN10@output_dou

; 279  :         prefix_len = 1;

	mov	QWORD PTR prefix_len$[rbp], 1
$LN10@output_dou:

; 280  : 
; 281  :     s = buf + 1;

	lea	rax, QWORD PTR buf$[rbp+1]
	mov	QWORD PTR s$[rbp], rax

; 282  :     
; 283  :     sprintf(fmt, "%%%zd.%zd%c", width, precision, type);

	movsx	eax, BYTE PTR type$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR precision$[rbp]
	mov	r8, QWORD PTR width$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_0M@NELIGLGC@?$CF?$CF?$CFzd?4?$CFzd?$CFc@
	lea	rcx, QWORD PTR fmt$[rbp]
	call	sprintf

; 284  :     sprintf(s, fmt, d);

	movsd	xmm2, QWORD PTR d$[rbp]
	movq	r8, xmm2
	lea	rdx, QWORD PTR fmt$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	sprintf

; 285  :     
; 286  :     for (p = s; *p == ' '; p++);

	mov	rax, QWORD PTR s$[rbp]
	mov	QWORD PTR p$[rbp], rax
	jmp	SHORT $LN4@output_dou
$LN2@output_dou:
	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN4@output_dou:
	mov	rax, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@output_dou
	jmp	SHORT $LN2@output_dou
$LN3@output_dou:
$LN5@output_dou:

; 287  : 
; 288  :     for (;;) {
; 289  :         *s = *p;

	mov	rax, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 290  :         if (*p == '\0')

	mov	rax, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN11@output_dou

; 291  :             break;

	jmp	SHORT $LN6@output_dou
$LN11@output_dou:

; 292  :         s++;

	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax

; 293  :         p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax

; 294  :     } 

	jmp	SHORT $LN5@output_dou
$LN6@output_dou:

; 295  :     s = buf + 1;

	lea	rax, QWORD PTR buf$[rbp+1]
	mov	QWORD PTR s$[rbp], rax

; 296  :     sz = strlen(s);

	mov	rcx, QWORD PTR s$[rbp]
	call	strlen
	mov	QWORD PTR sz$[rbp], rax

; 297  : 
; 298  :     if ((flag & (F_PLUS | F_SPACE)) && d >= 0) {

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN12@output_dou
	movsd	xmm0, QWORD PTR d$[rbp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jb	SHORT $LN12@output_dou

; 299  :         prefix_len = 1;

	mov	QWORD PTR prefix_len$[rbp], 1

; 300  :         *(--s) = (flag & F_PLUS) ? '+' : ' ';

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN16@output_dou
	mov	DWORD PTR tv94[rbp], 43			; 0000002bH
	jmp	SHORT $LN17@output_dou
$LN16@output_dou:
	mov	DWORD PTR tv94[rbp], 32			; 00000020H
$LN17@output_dou:
	mov	rax, QWORD PTR s$[rbp]
	dec	rax
	mov	QWORD PTR s$[rbp], rax
	mov	rax, QWORD PTR s$[rbp]
	movzx	ecx, BYTE PTR tv94[rbp]
	mov	BYTE PTR [rax], cl

; 301  :         sz++;

	mov	rax, QWORD PTR sz$[rbp]
	inc	rax
	mov	QWORD PTR sz$[rbp], rax
$LN12@output_dou:

; 302  :     }
; 303  :     
; 304  :     if ((flag & F_HASH) && type == 'f' && strchr(s, '.') == NULL) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN13@output_dou
	movsx	eax, BYTE PTR type$[rbp]
	cmp	eax, 102				; 00000066H
	jne	SHORT $LN13@output_dou
	mov	edx, 46					; 0000002eH
	mov	rcx, QWORD PTR s$[rbp]
	call	strchr
	test	rax, rax
	jne	SHORT $LN13@output_dou

; 305  :         s[sz++] = '.';

	mov	rax, QWORD PTR sz$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR sz$[rbp]
	inc	rax
	mov	QWORD PTR sz$[rbp], rax
$LN13@output_dou:

; 306  :     
; 307  :     if (width < sz) 

	mov	rax, QWORD PTR sz$[rbp]
	cmp	QWORD PTR width$[rbp], rax
	jae	SHORT $LN14@output_dou

; 308  :         width = sz;

	mov	rax, QWORD PTR sz$[rbp]
	mov	QWORD PTR width$[rbp], rax
$LN14@output_dou:

; 309  :     flag &= ~F_DOT;

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, -65				; ffffffffffffffbfH
	mov	DWORD PTR flag$[rbp], eax

; 310  :    
; 311  :     return output_string(s, sz, prefix_len, width, precision, flag, pad, '0');

	mov	BYTE PTR [rsp+56], 48			; 00000030H
	movzx	eax, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR precision$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR width$[rbp]
	mov	r8, QWORD PTR prefix_len$[rbp]
	mov	rdx, QWORD PTR sz$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	output_string

; 312  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:output_double$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+712]
	pop	rdi
	pop	rbp
	ret	0
output_double ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT output_integer
_TEXT	SEGMENT
buf$ = 16
s$ = 168
sz$ = 200
prefix_len$ = 232
n$ = 264
is_negative$ = 292
tv159 = 500
tv137 = 504
__$ArrayPad$ = 512
num$ = 560
opt_long$ = 568
type$ = 576
width$ = 584
precision$ = 592
flag$ = 600
base$ = 608
prefix$ = 616
pad$ = 624
output_integer PROC					; COMDAT

; 202  : {

	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 600				; 00000258H
	lea	rbp, QWORD PTR [rsp+64]
	lea	rdi, QWORD PTR [rsp+64]
	mov	ecx, 86					; 00000056H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+632]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 203  :     char buf[128], *s;
; 204  :     size_t sz, prefix_len, n;
; 205  :     bool is_negative;
; 206  : 
; 207  :     if (precision > width) 

	mov	rax, QWORD PTR width$[rbp]
	cmp	QWORD PTR precision$[rbp], rax
	jbe	SHORT $LN2@output_int

; 208  :         width = precision;

	mov	rax, QWORD PTR precision$[rbp]
	mov	QWORD PTR width$[rbp], rax
$LN2@output_int:

; 209  :     
; 210  :     s = buf + 1;

	lea	rax, QWORD PTR buf$[rbp+1]
	mov	QWORD PTR s$[rbp], rax

; 211  :     if (type == 'p') {

	movsx	eax, BYTE PTR type$[rbp]
	cmp	eax, 112				; 00000070H
	jne	SHORT $LN3@output_int

; 212  :         if (num == 0) {

	cmp	QWORD PTR num$[rbp], 0
	jne	SHORT $LN4@output_int

; 213  :             s = "(nil)";

	lea	rax, OFFSET FLAT:??_C@_05MAGFAFAN@?$CInil?$CJ@
	mov	QWORD PTR s$[rbp], rax

; 214  :             return output_string(s, strlen(s), 0, width, precision, flag, ' ', ' ');

	mov	rcx, QWORD PTR s$[rbp]
	call	strlen
	mov	BYTE PTR [rsp+56], 32			; 00000020H
	mov	BYTE PTR [rsp+48], 32			; 00000020H
	mov	ecx, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR precision$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, QWORD PTR s$[rbp]
	call	output_string
	jmp	$LN1@output_int
$LN4@output_int:
$LN3@output_int:

; 215  :         } 
; 216  :     } 
; 217  : 
; 218  :     strcpy(s, prefix);

	mov	rdx, QWORD PTR prefix$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	strcpy

; 219  :     sz = strlen(s);

	mov	rcx, QWORD PTR s$[rbp]
	call	strlen
	mov	QWORD PTR sz$[rbp], rax

; 220  :     prefix_len = sz;

	mov	rax, QWORD PTR sz$[rbp]
	mov	QWORD PTR prefix_len$[rbp], rax

; 221  :      
; 222  :     is_negative = false;

	mov	DWORD PTR is_negative$[rbp], 0

; 223  :     if (flag & F_SIGN) {

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@output_int

; 224  :         if ((signed __int64)num < 0) {

	cmp	QWORD PTR num$[rbp], 0
	jge	SHORT $LN6@output_int

; 225  :             num = -(signed __int64)num;

	mov	rax, QWORD PTR num$[rbp]
	neg	rax
	mov	QWORD PTR num$[rbp], rax

; 226  :             is_negative = true;

	mov	DWORD PTR is_negative$[rbp], 1
$LN6@output_int:
$LN5@output_int:

; 227  :         }
; 228  :     } 
; 229  :     
; 230  :     if (opt_long == 1)

	cmp	DWORD PTR opt_long$[rbp], 1
	jne	SHORT $LN7@output_int

; 231  :         num &= (unsigned long)-1;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR num$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR num$[rbp], rax
	jmp	SHORT $LN8@output_int
$LN7@output_int:

; 232  :     else if (opt_long == 0)

	cmp	DWORD PTR opt_long$[rbp], 0
	jne	SHORT $LN9@output_int

; 233  :         num &= (unsigned int)-1;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR num$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR num$[rbp], rax
	jmp	SHORT $LN10@output_int
$LN9@output_int:

; 234  :     else if (opt_long == -1) 

	cmp	DWORD PTR opt_long$[rbp], -1
	jne	SHORT $LN11@output_int

; 235  :         num &= 0xffff;

	mov	rax, QWORD PTR num$[rbp]
	and	rax, 65535				; 0000ffffH
	mov	QWORD PTR num$[rbp], rax
	jmp	SHORT $LN12@output_int
$LN11@output_int:

; 236  :     else if (opt_long == -2) 

	cmp	DWORD PTR opt_long$[rbp], -2
	jne	SHORT $LN13@output_int

; 237  :         num &= 0xff;

	mov	rax, QWORD PTR num$[rbp]
	and	rax, 255				; 000000ffH
	mov	QWORD PTR num$[rbp], rax
$LN13@output_int:
$LN12@output_int:
$LN10@output_int:
$LN8@output_int:

; 238  : 
; 239  :     n = int64_str(s + sz, sizeof(buf) - sz - 1, num, base, flag & F_UPCASE);

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 2
	mov	ecx, 128				; 00000080H
	sub	rcx, QWORD PTR sz$[rbp]
	dec	rcx
	mov	rdx, QWORD PTR sz$[rbp]
	mov	r8, QWORD PTR s$[rbp]
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv137[rbp], rdx
	mov	BYTE PTR [rsp+32], al
	mov	r9d, DWORD PTR base$[rbp]
	mov	r8, QWORD PTR num$[rbp]
	mov	rdx, rcx
	mov	rax, QWORD PTR tv137[rbp]
	mov	rcx, rax
	call	int64_str
	mov	QWORD PTR n$[rbp], rax

; 240  : 
; 241  :     /* When 0 is printed with an explicit precision 0, the output is empty. */
; 242  :     if ((flag & F_DOT) && n == 1 && s[sz] == '0') {

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN14@output_int
	cmp	QWORD PTR n$[rbp], 1
	jne	SHORT $LN14@output_int
	mov	rax, QWORD PTR sz$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN14@output_int

; 243  :         if (precision == 0 || prefix_len > 0) 

	cmp	QWORD PTR precision$[rbp], 0
	je	SHORT $LN17@output_int
	cmp	QWORD PTR prefix_len$[rbp], 0
	jbe	SHORT $LN16@output_int
$LN17@output_int:

; 244  :             sz = 0;

	mov	QWORD PTR sz$[rbp], 0
$LN16@output_int:

; 245  :         prefix_len = 0;

	mov	QWORD PTR prefix_len$[rbp], 0

; 246  :     } else 

	jmp	SHORT $LN15@output_int
$LN14@output_int:

; 247  :         sz += n;

	mov	rax, QWORD PTR n$[rbp]
	mov	rcx, QWORD PTR sz$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR sz$[rbp], rax
$LN15@output_int:

; 248  :     
; 249  :     if (is_negative) {

	cmp	DWORD PTR is_negative$[rbp], 0
	je	SHORT $LN18@output_int

; 250  :         prefix_len = 1;

	mov	QWORD PTR prefix_len$[rbp], 1

; 251  :         *(--s) = '-';

	mov	rax, QWORD PTR s$[rbp]
	dec	rax
	mov	QWORD PTR s$[rbp], rax
	mov	rax, QWORD PTR s$[rbp]
	mov	BYTE PTR [rax], 45			; 0000002dH

; 252  :         sz++;

	mov	rax, QWORD PTR sz$[rbp]
	inc	rax
	mov	QWORD PTR sz$[rbp], rax
	jmp	SHORT $LN19@output_int
$LN18@output_int:

; 253  :     } else if ((flag & F_SIGN) && (flag & (F_PLUS | F_SPACE))) {

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN20@output_int
	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN20@output_int

; 254  :         prefix_len = 1;

	mov	QWORD PTR prefix_len$[rbp], 1

; 255  :         *(--s) = (flag & F_PLUS) ? '+' : ' ';

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN24@output_int
	mov	DWORD PTR tv159[rbp], 43		; 0000002bH
	jmp	SHORT $LN25@output_int
$LN24@output_int:
	mov	DWORD PTR tv159[rbp], 32		; 00000020H
$LN25@output_int:
	mov	rax, QWORD PTR s$[rbp]
	dec	rax
	mov	QWORD PTR s$[rbp], rax
	mov	rax, QWORD PTR s$[rbp]
	movzx	ecx, BYTE PTR tv159[rbp]
	mov	BYTE PTR [rax], cl

; 256  :         sz++;

	mov	rax, QWORD PTR sz$[rbp]
	inc	rax
	mov	QWORD PTR sz$[rbp], rax
$LN20@output_int:
$LN19@output_int:

; 257  :     } 
; 258  : 
; 259  :     if (precision > 0)

	cmp	QWORD PTR precision$[rbp], 0
	jbe	SHORT $LN21@output_int

; 260  :         pad = ' ';

	mov	BYTE PTR pad$[rbp], 32			; 00000020H
$LN21@output_int:

; 261  : 
; 262  :     if (sz - prefix_len > precision)

	mov	rax, QWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR sz$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	rax, QWORD PTR precision$[rbp]
	jbe	SHORT $LN22@output_int

; 263  :         precision = sz - prefix_len;

	mov	rax, QWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR sz$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR precision$[rbp], rax
$LN22@output_int:

; 264  : 
; 265  :     return output_string(s, sz, prefix_len, width, precision, flag, pad, '0');

	mov	BYTE PTR [rsp+56], 48			; 00000030H
	movzx	eax, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR precision$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR width$[rbp]
	mov	r8, QWORD PTR prefix_len$[rbp]
	mov	rdx, QWORD PTR sz$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	output_string
$LN1@output_int:

; 266  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:output_integer$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+536]
	pop	rdi
	pop	rbp
	ret	0
output_integer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT output_string
_TEXT	SEGMENT
prefix$ = 8
len$ = 40
str$ = 288
size$ = 296
prefix_len$ = 304
width$ = 312
precision$ = 320
flag$ = 328
pad$ = 336
precision_pad$ = 344
output_string PROC					; COMDAT

; 129  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 130  :     const char *prefix;
; 131  :     size_t len = 0;

	mov	QWORD PTR len$[rbp], 0

; 132  :  
; 133  :     if (width == 0 && precision == 0) {

	cmp	QWORD PTR width$[rbp], 0
	jne	SHORT $LN2@output_str
	cmp	QWORD PTR precision$[rbp], 0
	jne	SHORT $LN2@output_str

; 134  :         output(str, size); 

	mov	rdx, QWORD PTR size$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	call	output

; 135  :         return size;

	mov	rax, QWORD PTR size$[rbp]
	jmp	$LN1@output_str
$LN2@output_str:

; 136  :     }
; 137  :     
; 138  :     prefix = str;

	mov	rax, QWORD PTR str$[rbp]
	mov	QWORD PTR prefix$[rbp], rax

; 139  :     
; 140  :     if (prefix_len) {

	cmp	QWORD PTR prefix_len$[rbp], 0
	je	SHORT $LN3@output_str

; 141  :         str += prefix_len;

	mov	rax, QWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR str$[rbp], rax

; 142  :         size -= prefix_len;

	mov	rax, QWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR size$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR size$[rbp], rax

; 143  :         width -= prefix_len;

	mov	rax, QWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR width$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR width$[rbp], rax
$LN3@output_str:

; 144  :     }
; 145  :      
; 146  :     /* These are the cases for 1234 or "1234" respectively:
; 147  :         %.6u -> "001234"
; 148  :         %6u  -> "  1234"
; 149  :         %06u -> "001234"
; 150  :         %-6u -> "1234  "
; 151  :         %.6s -> "1234"
; 152  :         %6s  -> "  1234"
; 153  :         %06s -> "  1234"
; 154  :         %-6s -> "1234  "
; 155  :         %6.5u -> " 01234"
; 156  :         %6.5s -> "  1234"
; 157  :         In this code, for %6.5s, 6 is width, 5 is precision.
; 158  :         flag_dot means there was a '.' and precision is set.
; 159  :         flag_left means there was a '-'.
; 160  :         sz is 4 (strlen("1234")).
; 161  :         pad will be '0' for %06u, ' ' otherwise.
; 162  :         precision_pad is '0' for %u, ' ' for %s.
; 163  :     */
; 164  :     
; 165  :     if ((flag & F_DOT) && width == 0) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN4@output_str
	cmp	QWORD PTR width$[rbp], 0
	jne	SHORT $LN4@output_str

; 166  :         width = precision;

	mov	rax, QWORD PTR precision$[rbp]
	mov	QWORD PTR width$[rbp], rax
$LN4@output_str:

; 167  :     
; 168  :     if (!(flag & F_DOT)) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN5@output_str

; 169  :         precision = size;

	mov	rax, QWORD PTR size$[rbp]
	mov	QWORD PTR precision$[rbp], rax
$LN5@output_str:

; 170  : 
; 171  :     /* do left-side padding with spaces */
; 172  :     if (!(flag & F_LEFT) && pad == ' ') 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN6@output_str
	movsx	eax, BYTE PTR pad$[rbp]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@output_str

; 173  :         len += write_pad(width - precision, ' ');

	mov	rax, QWORD PTR precision$[rbp]
	mov	rcx, QWORD PTR width$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	edx, 32					; 00000020H
	mov	rcx, rax
	call	write_pad
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax
$LN6@output_str:

; 174  :     
; 175  :     if (prefix_len) {

	cmp	QWORD PTR prefix_len$[rbp], 0
	je	SHORT $LN7@output_str

; 176  :         output(prefix, prefix_len);

	mov	rdx, QWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR prefix$[rbp]
	call	output

; 177  :         len += prefix_len;

	mov	rax, QWORD PTR prefix_len$[rbp]
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax
$LN7@output_str:

; 178  :     }
; 179  : 
; 180  :     /* do left-side padding with '0' */
; 181  :     if (!(flag & F_LEFT) && pad == '0') 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN8@output_str
	movsx	eax, BYTE PTR pad$[rbp]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN8@output_str

; 182  :         len += write_pad(width - precision, '0');

	mov	rax, QWORD PTR precision$[rbp]
	mov	rcx, QWORD PTR width$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	edx, 48					; 00000030H
	mov	rcx, rax
	call	write_pad
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax
$LN8@output_str:

; 183  :     
; 184  :     /* do precision padding */
; 185  :     len += write_pad(precision - size, precision_pad);

	movsx	eax, BYTE PTR precision_pad$[rbp]
	mov	rcx, QWORD PTR size$[rbp]
	mov	rdx, QWORD PTR precision$[rbp]
	sub	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	write_pad
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax

; 186  :     
; 187  :     /* write actual string */
; 188  :     output(str, size); 

	mov	rdx, QWORD PTR size$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	call	output

; 189  :     len += size;

	mov	rax, QWORD PTR size$[rbp]
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax

; 190  : 
; 191  :     /* do right-side padding */
; 192  :     if (flag & F_LEFT) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN9@output_str

; 193  :         len += write_pad(width - precision, pad);

	movsx	eax, BYTE PTR pad$[rbp]
	mov	rcx, QWORD PTR precision$[rbp]
	mov	rdx, QWORD PTR width$[rbp]
	sub	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	write_pad
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax
$LN9@output_str:

; 194  : 
; 195  :     return len;

	mov	rax, QWORD PTR len$[rbp]
$LN1@output_str:

; 196  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
output_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT int64_str
_TEXT	SEGMENT
p$ = 8
j$ = 36
tv83 = 244
tv89 = 248
tv75 = 248
s$ = 288
size$ = 296
i$ = 304
base$ = 312
upcase$ = 320
int64_str PROC						; COMDAT

; 86   : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 87   :     char *p;
; 88   :     unsigned int j = 0;

	mov	DWORD PTR j$[rbp], 0

; 89   :     
; 90   :     s[--size] = 0; 

	mov	rax, QWORD PTR size$[rbp]
	dec	rax
	mov	QWORD PTR size$[rbp], rax
	mov	rax, QWORD PTR size$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax], 0

; 91   :     
; 92   :     p = s + size;

	mov	rax, QWORD PTR size$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rbp], rax

; 93   :     
; 94   :     if (base == 0 || base > 36) 

	cmp	DWORD PTR base$[rbp], 0
	je	SHORT $LN5@int64_str
	cmp	DWORD PTR base$[rbp], 36		; 00000024H
	jle	SHORT $LN4@int64_str
$LN5@int64_str:

; 95   :         base = 10;

	mov	DWORD PTR base$[rbp], 10
$LN4@int64_str:

; 96   :     
; 97   :     j = 0;

	mov	DWORD PTR j$[rbp], 0

; 98   :     if (i == 0) {

	cmp	QWORD PTR i$[rbp], 0
	jne	SHORT $LN6@int64_str

; 99   :         *(--p) = '0';

	mov	rax, QWORD PTR p$[rbp]
	dec	rax
	mov	QWORD PTR p$[rbp], rax
	mov	rax, QWORD PTR p$[rbp]
	mov	BYTE PTR [rax], 48			; 00000030H

; 100  :         j = 1;

	mov	DWORD PTR j$[rbp], 1
$LN6@int64_str:
$LN2@int64_str:

; 101  :     }
; 102  :     
; 103  :     while (p > s && i != 0) {

	mov	rax, QWORD PTR s$[rbp]
	cmp	QWORD PTR p$[rbp], rax
	jbe	$LN3@int64_str
	cmp	QWORD PTR i$[rbp], 0
	je	$LN3@int64_str

; 104  :         p--;

	mov	rax, QWORD PTR p$[rbp]
	dec	rax
	mov	QWORD PTR p$[rbp], rax

; 105  :         *p = (char)(i % base + '0');

	movsxd	rax, DWORD PTR base$[rbp]
	mov	QWORD PTR tv75[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR i$[rbp]
	mov	rcx, QWORD PTR tv75[rbp]
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR p$[rbp]
	mov	BYTE PTR [rcx], al

; 106  :         if (*p > '9') 

	mov	rax, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jle	SHORT $LN7@int64_str

; 107  :             *p += (upcase ? 'A' : 'a') - '9' - 1;

	movsx	eax, BYTE PTR upcase$[rbp]
	test	eax, eax
	je	SHORT $LN9@int64_str
	mov	DWORD PTR tv83[rbp], 65			; 00000041H
	jmp	SHORT $LN10@int64_str
$LN9@int64_str:
	mov	DWORD PTR tv83[rbp], 97			; 00000061H
$LN10@int64_str:
	mov	rax, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, DWORD PTR tv83[rbp]
	lea	eax, DWORD PTR [rax+rcx-58]
	mov	rcx, QWORD PTR p$[rbp]
	mov	BYTE PTR [rcx], al
$LN7@int64_str:

; 108  :         i /= base;

	movsxd	rax, DWORD PTR base$[rbp]
	mov	QWORD PTR tv89[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR i$[rbp]
	mov	rcx, QWORD PTR tv89[rbp]
	div	rcx
	mov	QWORD PTR i$[rbp], rax

; 109  :         j++;

	mov	eax, DWORD PTR j$[rbp]
	inc	eax
	mov	DWORD PTR j$[rbp], eax

; 110  :     }

	jmp	$LN2@int64_str
$LN3@int64_str:

; 111  : 
; 112  :     memmove(s, p, j + 1);

	mov	eax, DWORD PTR j$[rbp]
	inc	eax
	mov	eax, eax
	mov	r8d, eax
	mov	rdx, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	memmove

; 113  : 
; 114  :     return j;

	mov	eax, DWORD PTR j$[rbp]

; 115  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
int64_str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT write_pad
_TEXT	SEGMENT
pad$ = 8
n$ = 40
len$ = 288
pad_ch$ = 296
write_pad PROC						; COMDAT

; 64   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 65   :     const char *pad;
; 66   :     size_t n;
; 67   : 
; 68   :     if ((int)len <= 0) 

	cmp	DWORD PTR len$[rbp], 0
	jg	SHORT $LN5@write_pad

; 69   :         return 0;

	xor	eax, eax
	jmp	$LN1@write_pad
$LN5@write_pad:

; 70   : 
; 71   :     if (pad_ch == '0')

	cmp	DWORD PTR pad_ch$[rbp], 48		; 00000030H
	jne	SHORT $LN6@write_pad

; 72   :         pad = "0000000000000000";

	lea	rax, OFFSET FLAT:??_C@_0BB@GHIALFFI@0000000000000000@
	mov	QWORD PTR pad$[rbp], rax
	jmp	SHORT $LN7@write_pad
$LN6@write_pad:

; 73   :     else
; 74   :         pad = "                ";

	lea	rax, OFFSET FLAT:??_C@_0BB@FHAPCDKO@?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
	mov	QWORD PTR pad$[rbp], rax
$LN7@write_pad:

; 75   : 
; 76   :     for (n = 0; len > 15; len -= 16, n += 16) 

	mov	QWORD PTR n$[rbp], 0
	jmp	SHORT $LN4@write_pad
$LN2@write_pad:
	mov	rax, QWORD PTR len$[rbp]
	sub	rax, 16
	mov	QWORD PTR len$[rbp], rax
	mov	rax, QWORD PTR n$[rbp]
	add	rax, 16
	mov	QWORD PTR n$[rbp], rax
$LN4@write_pad:
	cmp	QWORD PTR len$[rbp], 15
	jbe	SHORT $LN3@write_pad

; 77   :         output(pad, 16);

	mov	edx, 16
	mov	rcx, QWORD PTR pad$[rbp]
	call	output
	jmp	SHORT $LN2@write_pad
$LN3@write_pad:

; 78   : 
; 79   :     if (len > 0) 

	cmp	QWORD PTR len$[rbp], 0
	jbe	SHORT $LN8@write_pad

; 80   :         n += output(pad, len); 

	mov	rdx, QWORD PTR len$[rbp]
	mov	rcx, QWORD PTR pad$[rbp]
	call	output
	mov	rcx, QWORD PTR n$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR n$[rbp], rax
$LN8@write_pad:

; 81   : 
; 82   :     return n;

	mov	rax, QWORD PTR n$[rbp]
$LN1@write_pad:

; 83   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
write_pad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT output
_TEXT	SEGMENT
ms$ = 4
n$ = 36
timestamp$ = 72
head$ = 136
tail$ = 168
end$ = 200
tv146 = 404
tv76 = 404
tv70 = 404
tv71 = 408
__$ArrayPad$ = 416
str$ = 464
len$ = 472
output	PROC						; COMDAT

; 44   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 472				; 000001d8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+504]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 45   : 	static bool sol = true; /* start of line */
; 46   : 	unsigned int ms, n;
; 47   : 	char timestamp[32];
; 48   : 	const char *head, *tail, *end = str + len;

	mov	rax, QWORD PTR len$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$[rbp], rax

; 49   : 
; 50   : 	for (head = tail = str; tail < end; head = tail) {

	mov	rax, QWORD PTR str$[rbp]
	mov	QWORD PTR tail$[rbp], rax
	mov	rax, QWORD PTR tail$[rbp]
	mov	QWORD PTR head$[rbp], rax
	jmp	SHORT $LN4@output
$LN2@output:
	mov	rax, QWORD PTR tail$[rbp]
	mov	QWORD PTR head$[rbp], rax
$LN4@output:
	mov	rax, QWORD PTR end$[rbp]
	cmp	QWORD PTR tail$[rbp], rax
	jae	$LN3@output
$LN5@output:

; 51   : 		while (tail < end && *tail++ != '\n');

	mov	rax, QWORD PTR end$[rbp]
	cmp	QWORD PTR tail$[rbp], rax
	jae	SHORT $LN6@output
	mov	rax, QWORD PTR tail$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv70[rbp], eax
	mov	rax, QWORD PTR tail$[rbp]
	inc	rax
	mov	QWORD PTR tail$[rbp], rax
	cmp	DWORD PTR tv70[rbp], 10
	je	SHORT $LN17@output
	mov	DWORD PTR tv71[rbp], 1
	jmp	SHORT $LN18@output
$LN17@output:
	mov	DWORD PTR tv71[rbp], 0
$LN18@output:
	cmp	DWORD PTR tv71[rbp], 0
	je	SHORT $LN6@output
	jmp	SHORT $LN5@output
$LN6@output:

; 52   : 		if (sol) {

	cmp	DWORD PTR ?sol@?1??output@@9@9, 0
	je	$LN13@output

; 53   : 			ms = get_ms();

	call	get_ms
	mov	DWORD PTR ms$[rbp], eax

; 54   : 			n = sprintf(timestamp, "%03d.%03d ", ms / 1000, ms % 1000);

	xor	edx, edx
	mov	eax, DWORD PTR ms$[rbp]
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	eax, edx
	mov	DWORD PTR tv76[rbp], eax
	xor	edx, edx
	mov	eax, DWORD PTR ms$[rbp]
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	ecx, DWORD PTR tv76[rbp]
	mov	r9d, ecx
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_0L@BJFLMDDL@?$CF03d?4?$CF03d?5@
	lea	rcx, QWORD PTR timestamp$[rbp]
	call	sprintf
	mov	DWORD PTR n$[rbp], eax
$LN9@output:

; 55   : 			tee_output(timestamp, n);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	ecx, DWORD PTR n$[rbp]
	mov	r9, rax
	mov	r8d, ecx
	mov	edx, 1
	lea	rcx, QWORD PTR timestamp$[rbp]
	call	QWORD PTR __imp_fwrite
	cmp	QWORD PTR log_file, 0
	je	SHORT $LN14@output
	mov	eax, DWORD PTR n$[rbp]
	mov	r9, QWORD PTR log_file
	mov	r8d, eax
	mov	edx, 1
	lea	rcx, QWORD PTR timestamp$[rbp]
	call	QWORD PTR __imp_fwrite
$LN14@output:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN9@output
$LN13@output:
$LN12@output:

; 56   : 		}
; 57   : 		tee_output(head, tail - head);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR head$[rbp]
	mov	rdx, QWORD PTR tail$[rbp]
	sub	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, rcx
	mov	edx, 1
	mov	rcx, QWORD PTR head$[rbp]
	call	QWORD PTR __imp_fwrite
	cmp	QWORD PTR log_file, 0
	je	SHORT $LN15@output
	mov	rax, QWORD PTR head$[rbp]
	mov	rcx, QWORD PTR tail$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR log_file
	mov	r8, rax
	mov	edx, 1
	mov	rcx, QWORD PTR head$[rbp]
	call	QWORD PTR __imp_fwrite
$LN15@output:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN12@output

; 58   : 		sol = tail[-1] == '\n';

	mov	eax, 1
	imul	rax, rax, -1
	mov	rcx, QWORD PTR tail$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 10
	jne	SHORT $LN19@output
	mov	DWORD PTR tv146[rbp], 1
	jmp	SHORT $LN20@output
$LN19@output:
	mov	DWORD PTR tv146[rbp], 0
$LN20@output:
	mov	eax, DWORD PTR tv146[rbp]
	mov	DWORD PTR ?sol@?1??output@@9@9, eax

; 59   : 	}

	jmp	$LN2@output
$LN3@output:

; 60   : 	return len;

	mov	rax, QWORD PTR len$[rbp]

; 61   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:output$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+440]
	pop	rdi
	pop	rbp
	ret	0
output	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT skip_to
_TEXT	SEGMENT
i$ = 4
format$ = 256
skip_to	PROC						; COMDAT

; 31   : static unsigned long skip_to(const char *format) {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 32   :     unsigned long i;
; 33   :     for (i = 0; format[i] && format[i] != '%'; ++i);

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@skip_to
$LN2@skip_to:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@skip_to:
	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@skip_to
	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN3@skip_to
	jmp	SHORT $LN2@skip_to
$LN3@skip_to:

; 34   :     return i;

	mov	eax, DWORD PTR i$[rbp]

; 35   : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
skip_to	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT __v_lprintf
_TEXT	SEGMENT
len$ = 8
l$ = 40
n$ = 68
err$ = 100
s$ = 136
ptr$ = 168
flag$ = 196
ch$ = 228
pad$ = 260
opt_long$ = 292
base$ = 324
width$ = 360
precision$ = 392
num$ = 424
prefix$ = 456
tv154 = 660
tv82 = 660
tv193 = 664
tv168 = 664
tv83 = 664
__$ArrayPad$ = 672
format$ = 720
arg_ptr$ = 728
__v_lprintf PROC					; COMDAT

; 363  : {

$LN84:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 776				; 00000308H
	lea	rbp, QWORD PTR [rsp+80]
	lea	rdi, QWORD PTR [rsp+80]
	mov	ecx, 126				; 0000007eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+808]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 364  :     size_t len = 0, l;

	mov	QWORD PTR len$[rbp], 0

; 365  :     signed int n;
; 366  :     int err = errno;

	call	QWORD PTR __imp__errno
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR err$[rbp], eax
$LN73@v_lprintf:
$LN2@v_lprintf:

; 367  :     char *s;
; 368  :     unsigned char *ptr;
; 369  :     int flag;
; 370  :     char ch, pad;
; 371  :     
; 372  :     signed int opt_long;
; 373  : 
; 374  :     unsigned int base;
; 375  :     size_t width, precision;
; 376  :     
; 377  :     __int64 num;
; 378  :     char *prefix;
; 379  : 
; 380  :     while (*format) {

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@v_lprintf

; 381  :         
; 382  :         n = skip_to(format);

	mov	rcx, QWORD PTR format$[rbp]
	call	skip_to
	mov	DWORD PTR n$[rbp], eax

; 383  :         if (n) {

	cmp	DWORD PTR n$[rbp], 0
	je	SHORT $LN6@v_lprintf

; 384  :             output(format, n); 

	movsxd	rax, DWORD PTR n$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR format$[rbp]
	call	output

; 385  :             len += n;

	movsxd	rax, DWORD PTR n$[rbp]
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax

; 386  :             format += n;

	movsxd	rax, DWORD PTR n$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR format$[rbp], rax
$LN6@v_lprintf:

; 387  :         }
; 388  :         
; 389  :         if (*format != '%') 

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN7@v_lprintf

; 390  :             continue;

	jmp	SHORT $LN2@v_lprintf
$LN7@v_lprintf:

; 391  :         
; 392  :         pad = ' ';

	mov	BYTE PTR pad$[rbp], 32			; 00000020H

; 393  :         flag = 0;

	mov	DWORD PTR flag$[rbp], 0

; 394  :         opt_long = 0;

	mov	DWORD PTR opt_long$[rbp], 0

; 395  :         prefix = "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR prefix$[rbp], rax

; 396  :         
; 397  :         width = 0;

	mov	QWORD PTR width$[rbp], 0

; 398  :         precision = 0;

	mov	QWORD PTR precision$[rbp], 0

; 399  :         num = 0;

	mov	QWORD PTR num$[rbp], 0

; 400  :         
; 401  :         ++format;

	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax
$LN81@v_lprintf:
$LN80@v_lprintf:
$LN79@v_lprintf:
$LN78@v_lprintf:
$LN77@v_lprintf:
$LN76@v_lprintf:
$LN75@v_lprintf:
$LN74@v_lprintf:
$next_option$85:

; 402  :         
; 403  : next_option:
; 404  :         switch (ch = *format++) {

	mov	rax, QWORD PTR format$[rbp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR ch$[rbp], al
	movsx	eax, BYTE PTR ch$[rbp]
	mov	DWORD PTR tv82[rbp], eax
	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax
	mov	eax, DWORD PTR tv82[rbp]
	mov	DWORD PTR tv83[rbp], eax
	cmp	DWORD PTR tv83[rbp], 122		; 0000007aH
	ja	$LN65@v_lprintf
	movsxd	rax, DWORD PTR tv83[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN82@v_lprintf[rcx+rax]
	mov	eax, DWORD PTR $LN83@v_lprintf[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN8@v_lprintf:

; 405  :         case 0:
; 406  :             return -1;

	mov	rax, -1
	jmp	$LN1@v_lprintf

; 407  :             break;

	jmp	$LN4@v_lprintf
$LN9@v_lprintf:

; 408  :             
; 409  :         /* FLAGS */
; 410  :         case '#':
; 411  :             flag |= F_HASH;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 4
	mov	DWORD PTR flag$[rbp], eax

; 412  :             goto next_option;

	jmp	$next_option$85
$LN10@v_lprintf:

; 413  : 
; 414  :         case 'h':
; 415  :             --opt_long;

	mov	eax, DWORD PTR opt_long$[rbp]
	dec	eax
	mov	DWORD PTR opt_long$[rbp], eax

; 416  :             goto next_option;

	jmp	$LN74@v_lprintf
$LN11@v_lprintf:
$LN12@v_lprintf:

; 417  :             
; 418  :         case 'q':     
; 419  :         case 'L':
; 420  :             ++opt_long;

	mov	eax, DWORD PTR opt_long$[rbp]
	inc	eax
	mov	DWORD PTR opt_long$[rbp], eax
$LN13@v_lprintf:
$LN14@v_lprintf:

; 421  :         case 'z':
; 422  :         case 'l':
; 423  :             ++opt_long;

	mov	eax, DWORD PTR opt_long$[rbp]
	inc	eax
	mov	DWORD PTR opt_long$[rbp], eax

; 424  :             goto next_option;

	jmp	$LN75@v_lprintf
$LN15@v_lprintf:

; 425  :             
; 426  :         case '-':
; 427  :             flag |= F_LEFT;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 8
	mov	DWORD PTR flag$[rbp], eax

; 428  :             goto next_option;

	jmp	$LN76@v_lprintf
$LN16@v_lprintf:

; 429  :             
; 430  :         case ' ':
; 431  :             flag |= F_SPACE;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 16
	mov	DWORD PTR flag$[rbp], eax

; 432  :             goto next_option;

	jmp	$LN77@v_lprintf
$LN17@v_lprintf:

; 433  :             
; 434  :         case '+':
; 435  :             flag |= F_PLUS;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR flag$[rbp], eax

; 436  :             goto next_option;

	jmp	$LN78@v_lprintf
$LN18@v_lprintf:
$LN19@v_lprintf:
$LN20@v_lprintf:
$LN21@v_lprintf:
$LN22@v_lprintf:
$LN23@v_lprintf:
$LN24@v_lprintf:
$LN25@v_lprintf:
$LN26@v_lprintf:
$LN27@v_lprintf:

; 437  :             
; 438  :         case '0':
; 439  :         case '1':
; 440  :         case '2':
; 441  :         case '3':
; 442  :         case '4':
; 443  :         case '5':
; 444  :         case '6':
; 445  :         case '7':
; 446  :         case '8':
; 447  :         case '9':
; 448  :             if (flag & F_DOT) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN28@v_lprintf

; 449  :                 return -1;

	mov	rax, -1
	jmp	$LN1@v_lprintf
$LN28@v_lprintf:

; 450  :             width = strtoul(format - 1, (char **)&s, 10);

	mov	rax, QWORD PTR format$[rbp]
	dec	rax
	mov	r8d, 10
	lea	rdx, QWORD PTR s$[rbp]
	mov	rcx, rax
	call	QWORD PTR __imp_strtoul
	mov	eax, eax
	mov	QWORD PTR width$[rbp], rax

; 451  :             if (width > MAX_WIDTH) 

	cmp	QWORD PTR width$[rbp], 10240		; 00002800H
	jbe	SHORT $LN29@v_lprintf

; 452  :                 return -1;

	mov	rax, -1
	jmp	$LN1@v_lprintf
$LN29@v_lprintf:

; 453  :             if (ch == '0' && !(flag & F_LEFT)) 

	movsx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN30@v_lprintf
	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN30@v_lprintf

; 454  :                 pad = '0';

	mov	BYTE PTR pad$[rbp], 48			; 00000030H
$LN30@v_lprintf:

; 455  :             format = s;

	mov	rax, QWORD PTR s$[rbp]
	mov	QWORD PTR format$[rbp], rax

; 456  :             goto next_option;

	jmp	$LN79@v_lprintf
$LN31@v_lprintf:

; 457  :             
; 458  :         case '*': 
; 459  :             if ((n = va_arg(arg_ptr, int)) < 0) {

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR n$[rbp], eax
	cmp	DWORD PTR n$[rbp], 0
	jge	SHORT $LN32@v_lprintf

; 460  :                 flag |= F_LEFT;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 8
	mov	DWORD PTR flag$[rbp], eax

; 461  :                 n = -n;

	mov	eax, DWORD PTR n$[rbp]
	neg	eax
	mov	DWORD PTR n$[rbp], eax
$LN32@v_lprintf:

; 462  :             }
; 463  :             if ((width = (unsigned long)n) > MAX_WIDTH) 

	mov	eax, DWORD PTR n$[rbp]
	mov	QWORD PTR width$[rbp], rax
	cmp	QWORD PTR width$[rbp], 10240		; 00002800H
	jbe	SHORT $LN33@v_lprintf

; 464  :                 return -1;

	mov	rax, -1
	jmp	$LN1@v_lprintf
$LN33@v_lprintf:

; 465  :             goto next_option; 

	jmp	$LN80@v_lprintf
$LN34@v_lprintf:

; 466  :             
; 467  :         case '.':
; 468  :             flag |= F_DOT;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR flag$[rbp], eax

; 469  :             if (*format == '*') {

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN35@v_lprintf

; 470  :                 n = va_arg(arg_ptr, int);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	eax, DWORD PTR [rax-8]
	mov	DWORD PTR n$[rbp], eax

; 471  :                 ++format;

	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax

; 472  :             } else {

	jmp	SHORT $LN36@v_lprintf
$LN35@v_lprintf:

; 473  :                 n = strtol(format, (char**)&s, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	call	QWORD PTR __imp_strtol
	mov	DWORD PTR n$[rbp], eax

; 474  :                 format = s;

	mov	rax, QWORD PTR s$[rbp]
	mov	QWORD PTR format$[rbp], rax
$LN36@v_lprintf:

; 475  :             }
; 476  :             precision = n < 0 ? 0 : n;

	cmp	DWORD PTR n$[rbp], 0
	jge	SHORT $LN67@v_lprintf
	mov	DWORD PTR tv154[rbp], 0
	jmp	SHORT $LN68@v_lprintf
$LN67@v_lprintf:
	mov	eax, DWORD PTR n$[rbp]
	mov	DWORD PTR tv154[rbp], eax
$LN68@v_lprintf:
	movsxd	rax, DWORD PTR tv154[rbp]
	mov	QWORD PTR precision$[rbp], rax

; 477  :             if (precision > MAX_WIDTH) 

	cmp	QWORD PTR precision$[rbp], 10240	; 00002800H
	jbe	SHORT $LN37@v_lprintf

; 478  :                 return -1;

	mov	rax, -1
	jmp	$LN1@v_lprintf
$LN37@v_lprintf:

; 479  :             goto next_option;

	jmp	$LN81@v_lprintf
$LN38@v_lprintf:

; 480  :             
; 481  :         /* print a char or % */
; 482  :         case 'c':
; 483  :             ch = (char)va_arg(arg_ptr, int);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	movzx	eax, BYTE PTR [rax-8]
	mov	BYTE PTR ch$[rbp], al
$LN39@v_lprintf:

; 484  :         case '%':
; 485  :             output(&ch, 1); 

	mov	edx, 1
	lea	rcx, QWORD PTR ch$[rbp]
	call	output

; 486  :             ++len;

	mov	rax, QWORD PTR len$[rbp]
	inc	rax
	mov	QWORD PTR len$[rbp], rax

; 487  :             break;

	jmp	$LN4@v_lprintf
$LN40@v_lprintf:
$LN41@v_lprintf:

; 488  :                        
; 489  :         /* print a string */
; 490  :         case 'm':
; 491  :         case 's':
; 492  :             s = ch == 'm' ? strerror(err) : va_arg(arg_ptr, char *);

	movsx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN69@v_lprintf
	mov	ecx, DWORD PTR err$[rbp]
	call	QWORD PTR __imp_strerror
	mov	QWORD PTR tv168[rbp], rax
	jmp	SHORT $LN70@v_lprintf
$LN69@v_lprintf:
	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR tv168[rbp], rax
$LN70@v_lprintf:
	mov	rax, QWORD PTR tv168[rbp]
	mov	QWORD PTR s$[rbp], rax

; 493  :             if (s == NULL) 

	cmp	QWORD PTR s$[rbp], 0
	jne	SHORT $LN42@v_lprintf

; 494  :                 s = "(null)";

	lea	rax, OFFSET FLAT:??_C@_06OJHGLDPL@?$CInull?$CJ@
	mov	QWORD PTR s$[rbp], rax
$LN42@v_lprintf:

; 495  :             l = strlen(s);

	mov	rcx, QWORD PTR s$[rbp]
	call	strlen
	mov	QWORD PTR l$[rbp], rax

; 496  :             if ((flag & F_DOT) && l > precision) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN43@v_lprintf
	mov	rax, QWORD PTR precision$[rbp]
	cmp	QWORD PTR l$[rbp], rax
	jbe	SHORT $LN43@v_lprintf

; 497  :                 l = precision;

	mov	rax, QWORD PTR precision$[rbp]
	mov	QWORD PTR l$[rbp], rax
$LN43@v_lprintf:

; 498  :             flag &= ~F_DOT;

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, -65				; ffffffffffffffbfH
	mov	DWORD PTR flag$[rbp], eax

; 499  :             len += output_string(s, l, 0, width, 0, flag, ' ', ' ');

	mov	BYTE PTR [rsp+56], 32			; 00000020H
	mov	BYTE PTR [rsp+48], 32			; 00000020H
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR width$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR l$[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	call	output_string
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax

; 500  :             break;

	jmp	$LN4@v_lprintf
$LN44@v_lprintf:

; 501  :              
; 502  :         /* print an integer value */
; 503  :         case 'b':
; 504  :             base = 2;

	mov	DWORD PTR base$[rbp], 2

; 505  :             goto print_num;

	jmp	$print_num$86
$LN45@v_lprintf:

; 506  :             
; 507  :         case 'p':
; 508  :             prefix = "0x";

	lea	rax, OFFSET FLAT:??_C@_02MDDDDAID@0x@
	mov	QWORD PTR prefix$[rbp], rax

; 509  :             opt_long = sizeof(void *) / sizeof(long);

	mov	DWORD PTR opt_long$[rbp], 2
$LN46@v_lprintf:

; 510  :         case 'X':
; 511  :             if (ch == 'X')

	movsx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN47@v_lprintf

; 512  :                 flag |= F_UPCASE;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 2
	mov	DWORD PTR flag$[rbp], eax
$LN47@v_lprintf:
$LN48@v_lprintf:

; 513  :         case 'x':
; 514  :             base = 16;

	mov	DWORD PTR base$[rbp], 16

; 515  :             if (flag & F_HASH) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN49@v_lprintf

; 516  :                 prefix = ch == 'X' ? "0X" : "0x";

	movsx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN71@v_lprintf
	lea	rax, OFFSET FLAT:??_C@_02FGLHBECB@0X@
	mov	QWORD PTR tv193[rbp], rax
	jmp	SHORT $LN72@v_lprintf
$LN71@v_lprintf:
	lea	rax, OFFSET FLAT:??_C@_02MDDDDAID@0x@
	mov	QWORD PTR tv193[rbp], rax
$LN72@v_lprintf:
	mov	rax, QWORD PTR tv193[rbp]
	mov	QWORD PTR prefix$[rbp], rax
$LN49@v_lprintf:

; 517  :             goto print_num;

	jmp	SHORT $print_num$86
$LN50@v_lprintf:
$LN51@v_lprintf:

; 518  :             
; 519  :         case 'd':
; 520  :         case 'i': 
; 521  :             flag |= F_SIGN;

	mov	eax, DWORD PTR flag$[rbp]
	or	eax, 1
	mov	DWORD PTR flag$[rbp], eax
$LN52@v_lprintf:

; 522  :         case 'u':
; 523  :             base = 10;

	mov	DWORD PTR base$[rbp], 10

; 524  :             goto print_num;

	jmp	SHORT $print_num$86
$LN53@v_lprintf:

; 525  :             
; 526  :         case 'o':
; 527  :             base = 8;

	mov	DWORD PTR base$[rbp], 8

; 528  :             if (flag & F_HASH) 

	mov	eax, DWORD PTR flag$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN54@v_lprintf

; 529  :                 prefix = "0";

	lea	rax, OFFSET FLAT:??_C@_01GBGANLPD@0@
	mov	QWORD PTR prefix$[rbp], rax
$LN54@v_lprintf:
$print_num$86:

; 530  : print_num:
; 531  :             if (opt_long > 0) {

	cmp	DWORD PTR opt_long$[rbp], 0
	jle	SHORT $LN55@v_lprintf

; 532  :                 if (opt_long > 1)

	cmp	DWORD PTR opt_long$[rbp], 1
	jle	SHORT $LN57@v_lprintf

; 533  :                     num = va_arg(arg_ptr, __int64);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR num$[rbp], rax
	jmp	SHORT $LN58@v_lprintf
$LN57@v_lprintf:

; 534  :                 else
; 535  :                     num = (__int64)va_arg(arg_ptr, long);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	movsxd	rax, DWORD PTR [rax-8]
	mov	QWORD PTR num$[rbp], rax
$LN58@v_lprintf:

; 536  :             } else 

	jmp	SHORT $LN56@v_lprintf
$LN55@v_lprintf:

; 537  :                 num = (__int64)va_arg(arg_ptr, int);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	movsxd	rax, DWORD PTR [rax-8]
	mov	QWORD PTR num$[rbp], rax
$LN56@v_lprintf:

; 538  : 
; 539  :             len += output_integer(num, opt_long, ch, 

	movzx	eax, BYTE PTR pad$[rbp]
	mov	BYTE PTR [rsp+64], al
	mov	rax, QWORD PTR prefix$[rbp]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR base$[rbp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR precision$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR width$[rbp]
	movzx	r8d, BYTE PTR ch$[rbp]
	mov	edx, DWORD PTR opt_long$[rbp]
	mov	rcx, QWORD PTR num$[rbp]
	call	output_integer
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax

; 540  :                 width, precision, flag, base, prefix, pad);
; 541  :             break;

	jmp	$LN4@v_lprintf
$LN59@v_lprintf:
$LN60@v_lprintf:
$LN61@v_lprintf:
$LN62@v_lprintf:
$LN63@v_lprintf:

; 542  :   
; 543  :         /* print a floating point value */
; 544  :         case 'g':
; 545  :         case 'F':  
; 546  :         case 'f':
; 547  :         case 'e':
; 548  :         case 'E':
; 549  :             len += output_double(va_arg(arg_ptr, double), ch, 

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	movsx	eax, BYTE PTR pad$[rbp]
	mov	rcx, QWORD PTR arg_ptr$[rbp]
	movsd	xmm0, QWORD PTR [rcx-8]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR precision$[rbp]
	mov	r8, QWORD PTR width$[rbp]
	movzx	edx, BYTE PTR ch$[rbp]
	call	output_double
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax

; 550  :                 width, precision, flag, pad);
; 551  :             break;

	jmp	SHORT $LN4@v_lprintf
$LN64@v_lprintf:

; 552  : 
; 553  :         /* print a memory block */
; 554  :         case 'M': 
; 555  :             ptr = va_arg(arg_ptr, unsigned char *);

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR ptr$[rbp], rax

; 556  :             len += output_memory_block(ptr, va_arg(arg_ptr, int), 

	mov	rax, QWORD PTR arg_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR arg_ptr$[rbp], rax
	movsx	eax, BYTE PTR pad$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR flag$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR precision$[rbp]
	mov	r8, QWORD PTR width$[rbp]
	mov	rax, QWORD PTR arg_ptr$[rbp]
	mov	edx, DWORD PTR [rax-8]
	mov	rcx, QWORD PTR ptr$[rbp]
	call	output_memory_block
	mov	rcx, QWORD PTR len$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR len$[rbp], rax
$LN65@v_lprintf:
$LN4@v_lprintf:

; 557  :                 width, precision, flag, pad); 
; 558  :             break; 
; 559  : 
; 560  :         default:
; 561  :             break;
; 562  :         }
; 563  :     }

	jmp	$LN73@v_lprintf
$LN3@v_lprintf:

; 564  :     return len;

	mov	rax, QWORD PTR len$[rbp]
$LN1@v_lprintf:

; 565  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-80]
	lea	rdx, OFFSET FLAT:__v_lprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+696]
	pop	rdi
	pop	rbp
	ret	0
	npad	1
$LN83@v_lprintf:
	DD	$LN8@v_lprintf
	DD	$LN16@v_lprintf
	DD	$LN9@v_lprintf
	DD	$LN39@v_lprintf
	DD	$LN31@v_lprintf
	DD	$LN17@v_lprintf
	DD	$LN15@v_lprintf
	DD	$LN34@v_lprintf
	DD	$LN18@v_lprintf
	DD	$LN19@v_lprintf
	DD	$LN20@v_lprintf
	DD	$LN21@v_lprintf
	DD	$LN22@v_lprintf
	DD	$LN23@v_lprintf
	DD	$LN24@v_lprintf
	DD	$LN25@v_lprintf
	DD	$LN26@v_lprintf
	DD	$LN27@v_lprintf
	DD	$LN63@v_lprintf
	DD	$LN60@v_lprintf
	DD	$LN12@v_lprintf
	DD	$LN64@v_lprintf
	DD	$LN46@v_lprintf
	DD	$LN44@v_lprintf
	DD	$LN38@v_lprintf
	DD	$LN50@v_lprintf
	DD	$LN62@v_lprintf
	DD	$LN61@v_lprintf
	DD	$LN59@v_lprintf
	DD	$LN10@v_lprintf
	DD	$LN51@v_lprintf
	DD	$LN14@v_lprintf
	DD	$LN40@v_lprintf
	DD	$LN53@v_lprintf
	DD	$LN45@v_lprintf
	DD	$LN11@v_lprintf
	DD	$LN41@v_lprintf
	DD	$LN52@v_lprintf
	DD	$LN48@v_lprintf
	DD	$LN13@v_lprintf
	DD	$LN65@v_lprintf
$LN82@v_lprintf:
	DB	0
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	1
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	2
	DB	40					; 00000028H
	DB	3
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	4
	DB	5
	DB	40					; 00000028H
	DB	6
	DB	7
	DB	40					; 00000028H
	DB	8
	DB	9
	DB	10
	DB	11
	DB	12
	DB	13
	DB	14
	DB	15
	DB	16
	DB	17
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	18
	DB	19
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	20
	DB	21
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	22
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	23
	DB	24
	DB	25
	DB	26
	DB	27
	DB	28
	DB	29
	DB	30
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	31
	DB	32					; 00000020H
	DB	40					; 00000028H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	40					; 00000028H
	DB	36					; 00000024H
	DB	40					; 00000028H
	DB	37					; 00000025H
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	38					; 00000026H
	DB	40					; 00000028H
	DB	39					; 00000027H
__v_lprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\lprintf.c
;	COMDAT lprintf
_TEXT	SEGMENT
n$ = 8
arg_ptr$ = 40
__$ArrayPad$ = 248
format$ = 288
lprintf	PROC						; COMDAT

; 568  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EEE75003_lprintf@c
	call	__CheckForDebuggerJustMyCode

; 569  :     size_t n;
; 570  :     va_list arg_ptr;
; 571  : 
; 572  :     va_start(arg_ptr, format);

	lea	rax, QWORD PTR format$[rbp+8]
	mov	QWORD PTR arg_ptr$[rbp], rax

; 573  : 	n = __v_lprintf(format, arg_ptr);

	mov	rdx, QWORD PTR arg_ptr$[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	call	__v_lprintf
	mov	QWORD PTR n$[rbp], rax

; 574  :     va_end(arg_ptr);

	mov	QWORD PTR arg_ptr$[rbp], 0

; 575  : 
; 576  :     return n;

	mov	rax, QWORD PTR n$[rbp]

; 577  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:lprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
lprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 248
_Buffer$ = 288
_Format$ = 296
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rbp]
	mov	rcx, QWORD PTR _Buffer$[rbp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rbp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 1779 :         return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 1780 :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rbp]
	mov	r8, QWORD PTR _Format$[rbp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rbp]
	call	_vsnprintf_l

; 1460 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 4
tv74 = 212
_Buffer$ = 256
_BufferCount$ = 264
_Format$ = 272
_Locale$ = 280
_ArgList$ = 288
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rbp]
	mov	r8, QWORD PTR _BufferCount$[rbp]
	mov	rdx, QWORD PTR _Buffer$[rbp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rbp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rbp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rbp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rbp]
	mov	DWORD PTR tv74[rbp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rbp]

; 1397 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A2143F22_corecrt_stdio_config@h
	call	__CheckForDebuggerJustMyCode

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
