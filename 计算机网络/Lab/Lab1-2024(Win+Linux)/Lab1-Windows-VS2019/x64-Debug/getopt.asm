; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33523.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	optarg
PUBLIC	optind
PUBLIC	opterr
PUBLIC	optopt
_BSS	SEGMENT
optarg	DQ	01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__6A72211D_concurrencysal@h DB 01H
__CC30173B_sal@h DB 01H
__7EF21AAA_vadefs@h DB 01H
__657088F7_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__CDDAF8CA_errno@h DB 01H
__74F97FEA_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__B8895AF3_limits@h DB 01H
__B49664B7_stdlib@h DB 01H
__CF7D97E7_getopt@h DB 01H
__58AF4E6F_getopt@c DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
optind	DD	01H
opterr	DD	01H
optopt	DD	03fH
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	getopt_int
PUBLIC	getopt_int_only
PUBLIC	_getopt_internal
PUBLIC	getopt
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@		; `string'
PUBLIC	??_C@_02BAABKJLB@?9?9@				; `string'
PUBLIC	??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@ ; `string'
PUBLIC	??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@ ; `string'
PUBLIC	??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@ ; `string'
PUBLIC	??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@ ; `string'
PUBLIC	??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@ ; `string'
PUBLIC	??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@ ; `string'
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_getenv:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
nextchar DQ	01H DUP (?)
__getopt_initialized DD 01H DUP (?)
ordering DD	01H DUP (?)
first_nonopt DD	01H DUP (?)
last_nonopt DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+103
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+184
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getopt_int DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$getopt_int
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getopt_int_only DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$getopt_int_only
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_getopt_internal DD imagerel $LN85
	DD	imagerel $LN85+3389
	DD	imagerel $unwind$_getopt_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getopt DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$getopt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exchange DD imagerel exchange
	DD	imagerel exchange+578
	DD	imagerel $unwind$exchange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_getopt_initialize DD imagerel _getopt_initialize
	DD	imagerel _getopt_initialize+240
	DD	imagerel $unwind$_getopt_initialize
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@
CONST	SEGMENT
??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@ DB '%s: option'
	DB	' requires an argument -- %c', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@
CONST	SEGMENT
??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@ DB '%s: illeg'
	DB	'al option -- %c', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@
CONST	SEGMENT
??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@ DB '%'
	DB	's: unrecognized option `%c%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@
CONST	SEGMENT
??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@ DB '%'
	DB	's: unrecognized option `--%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@
CONST	SEGMENT
??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@ DB '%'
	DB	's: option `%s'' requires an argument', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@
CONST	SEGMENT
??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@ DB 09H
	DB	09H, 09H, 09H, 09H, '%s: option `%c%s'' doesn''t allow an argu'
	DB	'ment', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@
CONST	SEGMENT
??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@ DB 09H
	DB	09H, 09H, 09H, 09H, '%s: option `--%s'' doesn''t allow an argu'
	DB	'ment', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@
CONST	SEGMENT
??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@ DB '%s:'
	DB	' option `%s'' is ambiguous', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02BAABKJLB@?9?9@
CONST	SEGMENT
??_C@_02BAABKJLB@?9?9@ DB '--', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
CONST	SEGMENT
??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@ DB 'POSIXLY_CORRECT', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_getopt_initialize DD 025051c01H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exchange DD 025051301H
	DD	010e2313H
	DD	07007003dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getopt DD 035051c01H
	DD	0117331cH
	DD	07010001fH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_getopt_internal DD 035052101H
	DD	011c3321H
	DD	070150049H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getopt_int_only DD 035052101H
	DD	011c3321H
	DD	07015001fH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getopt_int DD 035052101H
	DD	011c3321H
	DD	07015001fH
	DD	05014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	09fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 025054c19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 035052201H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT _getopt_initialize
_TEXT	SEGMENT
argc$ = 224
argv$ = 232
optstring$ = 240
_getopt_initialize PROC					; COMDAT

; 225  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__58AF4E6F_getopt@c
	call	__CheckForDebuggerJustMyCode

; 226  :     /* Start processing options with ARGV-element 1 (since ARGV-element 0
; 227  :        is the program name); the sequence of previously skipped
; 228  :        non-option ARGV-elements is empty.  */
; 229  : 
; 230  :     first_nonopt = last_nonopt = optind;

	mov	eax, DWORD PTR optind
	mov	DWORD PTR last_nonopt, eax
	mov	eax, DWORD PTR last_nonopt
	mov	DWORD PTR first_nonopt, eax

; 231  : 
; 232  :     nextchar = NULL;

	mov	QWORD PTR nextchar, 0

; 233  : 
; 234  :     /* Determine how to handle the ordering of options and nonoptions.  */
; 235  : 
; 236  :     if (optstring[0] == '-')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR optstring$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN2@getopt_ini

; 237  :     {
; 238  : 	ordering = RETURN_IN_ORDER;

	mov	DWORD PTR ordering, 2

; 239  : 	++optstring;

	mov	rax, QWORD PTR optstring$[rbp]
	inc	rax
	mov	QWORD PTR optstring$[rbp], rax

; 240  :     }

	jmp	SHORT $LN3@getopt_ini
$LN2@getopt_ini:

; 241  :     else if (optstring[0] == '+')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR optstring$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN4@getopt_ini

; 242  :     {
; 243  : 	ordering = REQUIRE_ORDER;

	mov	DWORD PTR ordering, 0

; 244  : 	++optstring;

	mov	rax, QWORD PTR optstring$[rbp]
	inc	rax
	mov	QWORD PTR optstring$[rbp], rax

; 245  :     }

	jmp	SHORT $LN5@getopt_ini
$LN4@getopt_ini:

; 246  :     else if (getenv ("POSIXLY_CORRECT") != NULL)

	lea	rcx, OFFSET FLAT:??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
	call	QWORD PTR __imp_getenv
	test	rax, rax
	je	SHORT $LN6@getopt_ini

; 247  : 	ordering = REQUIRE_ORDER;

	mov	DWORD PTR ordering, 0
	jmp	SHORT $LN7@getopt_ini
$LN6@getopt_ini:

; 248  :     else
; 249  : 	ordering = PERMUTE;

	mov	DWORD PTR ordering, 1
$LN7@getopt_ini:
$LN5@getopt_ini:
$LN3@getopt_ini:

; 250  : 
; 251  :     return optstring;

	mov	rax, QWORD PTR optstring$[rbp]

; 252  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_getopt_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT exchange
_TEXT	SEGMENT
bottom$ = 4
middle$ = 36
top$ = 68
tem$ = 104
len$1 = 132
i$2 = 164
len$3 = 196
i$4 = 228
argv$ = 480
exchange PROC						; COMDAT

; 169  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 488				; 000001e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__58AF4E6F_getopt@c
	call	__CheckForDebuggerJustMyCode

; 170  :     int bottom = first_nonopt;

	mov	eax, DWORD PTR first_nonopt
	mov	DWORD PTR bottom$[rbp], eax

; 171  :     int middle = last_nonopt;

	mov	eax, DWORD PTR last_nonopt
	mov	DWORD PTR middle$[rbp], eax

; 172  :     int top = optind;

	mov	eax, DWORD PTR optind
	mov	DWORD PTR top$[rbp], eax
$LN2@exchange:

; 173  :     char *tem;
; 174  : 
; 175  :     /* Exchange the shorter segment with the far end of the inter segment.
; 176  :        That puts the shorter segment into the right place.
; 177  :        It leaves the inter segment in the right place overall,
; 178  :        but it consists of two parts that need to be swapped next.  */
; 179  : 
; 180  :     while (top > middle && middle > bottom)

	mov	eax, DWORD PTR middle$[rbp]
	cmp	DWORD PTR top$[rbp], eax
	jle	$LN3@exchange
	mov	eax, DWORD PTR bottom$[rbp]
	cmp	DWORD PTR middle$[rbp], eax
	jle	$LN3@exchange

; 181  :     {
; 182  : 	if (top - middle > middle - bottom)

	mov	eax, DWORD PTR middle$[rbp]
	mov	ecx, DWORD PTR top$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR bottom$[rbp]
	mov	edx, DWORD PTR middle$[rbp]
	sub	edx, ecx
	mov	ecx, edx
	cmp	eax, ecx
	jle	$LN10@exchange

; 183  : 	{
; 184  : 	    /* Bottom segment is the short one.  */
; 185  : 	    int len = middle - bottom;

	mov	eax, DWORD PTR bottom$[rbp]
	mov	ecx, DWORD PTR middle$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$1[rbp], eax

; 186  : 	    register int i;
; 187  : 
; 188  : 	    /* Swap it with the top part of the top segment.  */
; 189  : 	    for (i = 0; i < len; i++)

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN6@exchange
$LN4@exchange:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN6@exchange:
	mov	eax, DWORD PTR len$1[rbp]
	cmp	DWORD PTR i$2[rbp], eax
	jge	$LN5@exchange

; 190  : 	    {
; 191  : 		tem = argv[bottom + i];

	mov	eax, DWORD PTR i$2[rbp]
	mov	ecx, DWORD PTR bottom$[rbp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tem$[rbp], rax

; 192  : 		argv[bottom + i] = argv[top - (middle - bottom) + i];

	mov	eax, DWORD PTR bottom$[rbp]
	mov	ecx, DWORD PTR middle$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR top$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	add	eax, DWORD PTR i$2[rbp]
	cdqe
	mov	ecx, DWORD PTR i$2[rbp]
	mov	edx, DWORD PTR bottom$[rbp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR argv$[rbp]
	mov	r8, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 193  : 		argv[top - (middle - bottom) + i] = tem;

	mov	eax, DWORD PTR bottom$[rbp]
	mov	ecx, DWORD PTR middle$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR top$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	add	eax, DWORD PTR i$2[rbp]
	cdqe
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tem$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 194  : 	    }

	jmp	$LN4@exchange
$LN5@exchange:

; 195  : 	    /* Exclude the moved bottom segment from further swapping.  */
; 196  : 	    top -= len;

	mov	eax, DWORD PTR len$1[rbp]
	mov	ecx, DWORD PTR top$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR top$[rbp], eax

; 197  : 	}

	jmp	$LN11@exchange
$LN10@exchange:

; 198  : 	else
; 199  : 	{
; 200  : 	    /* Top segment is the short one.  */
; 201  : 	    int len = top - middle;

	mov	eax, DWORD PTR middle$[rbp]
	mov	ecx, DWORD PTR top$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR len$3[rbp], eax

; 202  : 	    register int i;
; 203  : 
; 204  : 	    /* Swap it with the bottom part of the bottom segment.  */
; 205  : 	    for (i = 0; i < len; i++)

	mov	DWORD PTR i$4[rbp], 0
	jmp	SHORT $LN9@exchange
$LN7@exchange:
	mov	eax, DWORD PTR i$4[rbp]
	inc	eax
	mov	DWORD PTR i$4[rbp], eax
$LN9@exchange:
	mov	eax, DWORD PTR len$3[rbp]
	cmp	DWORD PTR i$4[rbp], eax
	jge	SHORT $LN8@exchange

; 206  : 	    {
; 207  : 		tem = argv[bottom + i];

	mov	eax, DWORD PTR i$4[rbp]
	mov	ecx, DWORD PTR bottom$[rbp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR tem$[rbp], rax

; 208  : 		argv[bottom + i] = argv[middle + i];

	mov	eax, DWORD PTR i$4[rbp]
	mov	ecx, DWORD PTR middle$[rbp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	ecx, DWORD PTR i$4[rbp]
	mov	edx, DWORD PTR bottom$[rbp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR argv$[rbp]
	mov	r8, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 209  : 		argv[middle + i] = tem;

	mov	eax, DWORD PTR i$4[rbp]
	mov	ecx, DWORD PTR middle$[rbp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tem$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 210  : 	    }

	jmp	$LN7@exchange
$LN8@exchange:

; 211  : 	    /* Exclude the moved top segment from further swapping.  */
; 212  : 	    bottom += len;

	mov	eax, DWORD PTR len$3[rbp]
	mov	ecx, DWORD PTR bottom$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR bottom$[rbp], eax
$LN11@exchange:

; 213  : 	}
; 214  :     }

	jmp	$LN2@exchange
$LN3@exchange:

; 215  : 
; 216  :     /* Update records for the slots the non-options now occupy.  */
; 217  : 
; 218  :     first_nonopt += (optind - last_nonopt);

	mov	eax, DWORD PTR last_nonopt
	mov	ecx, DWORD PTR optind
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR first_nonopt
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR first_nonopt, eax

; 219  :     last_nonopt = optind;

	mov	eax, DWORD PTR optind
	mov	DWORD PTR last_nonopt, eax

; 220  : }

	lea	rsp, QWORD PTR [rbp+456]
	pop	rdi
	pop	rbp
	ret	0
exchange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT getopt
_TEXT	SEGMENT
argc$ = 224
argv$ = 232
optstring$ = 240
getopt	PROC						; COMDAT

; 784  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__58AF4E6F_getopt@c
	call	__CheckForDebuggerJustMyCode

; 785  :     return _getopt_internal (argc, argv, optstring,

	mov	DWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8, QWORD PTR optstring$[rbp]
	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	_getopt_internal

; 786  : 	    (const struct option *) 0, (int *) 0, 0);
; 787  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
getopt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT _getopt_internal
_TEXT	SEGMENT
print_errors$ = 4
nameend$1 = 40
p$2 = 72
pfound$3 = 104
exact$4 = 132
ambig$5 = 164
indfound$6 = 196
option_index$7 = 228
c$8 = 260
temp$9 = 296
tv429 = 500
tv403 = 500
tv381 = 500
tv334 = 500
tv294 = 500
tv431 = 504
tv405 = 504
tv383 = 504
tv368 = 504
tv316 = 504
tv296 = 504
tv279 = 504
tv246 = 504
tv224 = 504
tv180 = 504
tv320 = 512
tv250 = 512
argc$ = 560
argv$ = 568
optstring$ = 576
intopts$ = 584
intind$ = 592
int_only$ = 600
_getopt_internal PROC					; COMDAT

; 312  : {

$LN85:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 584				; 00000248H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__58AF4E6F_getopt@c
	call	__CheckForDebuggerJustMyCode

; 313  :     int print_errors = opterr;

	mov	eax, DWORD PTR opterr
	mov	DWORD PTR print_errors$[rbp], eax

; 314  :     if (optstring[0] == ':')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR optstring$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN10@getopt_int

; 315  : 	print_errors = 0;

	mov	DWORD PTR print_errors$[rbp], 0
$LN10@getopt_int:

; 316  : 
; 317  :     if (argc < 1)

	cmp	DWORD PTR argc$[rbp], 1
	jge	SHORT $LN11@getopt_int

; 318  : 	return -1;

	mov	eax, -1
	jmp	$LN1@getopt_int
$LN11@getopt_int:

; 319  : 
; 320  :     optarg = NULL;

	mov	QWORD PTR optarg, 0

; 321  : 
; 322  :     if (optind == 0 || !__getopt_initialized)

	cmp	DWORD PTR optind, 0
	je	SHORT $LN13@getopt_int
	cmp	DWORD PTR __getopt_initialized, 0
	jne	SHORT $LN12@getopt_int
$LN13@getopt_int:

; 323  :     {
; 324  : 	if (optind == 0)

	cmp	DWORD PTR optind, 0
	jne	SHORT $LN14@getopt_int

; 325  : 	    optind = 1;	/* Don't scan ARGV[0], the program name.  */

	mov	DWORD PTR optind, 1
$LN14@getopt_int:

; 326  : 	optstring = _getopt_initialize (argc, argv, optstring);

	mov	r8, QWORD PTR optstring$[rbp]
	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	_getopt_initialize
	mov	QWORD PTR optstring$[rbp], rax

; 327  : 	__getopt_initialized = 1;

	mov	DWORD PTR __getopt_initialized, 1
$LN12@getopt_int:

; 328  :     }
; 329  : 
; 330  :     /* Test whether ARGV[optind] points to a non-option argument.
; 331  :        Either it does not have option syntax, or there is an environment flag
; 332  :        from the shell indicating it is not an option.  The later information
; 333  :        is only used when the used in the GNU libc.  */
; 334  : #define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
; 335  : 
; 336  :     if (nextchar == NULL || *nextchar == '\0')

	cmp	QWORD PTR nextchar, 0
	je	SHORT $LN16@getopt_int
	mov	rax, QWORD PTR nextchar
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	$LN15@getopt_int
$LN16@getopt_int:

; 337  :     {
; 338  : 	/* Advance to the next ARGV-element.  */
; 339  : 
; 340  : 	/* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
; 341  : 	   moved back by the user (who may also have changed the arguments).  */
; 342  : 	if (last_nonopt > optind)

	mov	eax, DWORD PTR optind
	cmp	DWORD PTR last_nonopt, eax
	jle	SHORT $LN17@getopt_int

; 343  : 	    last_nonopt = optind;

	mov	eax, DWORD PTR optind
	mov	DWORD PTR last_nonopt, eax
$LN17@getopt_int:

; 344  : 	if (first_nonopt > optind)

	mov	eax, DWORD PTR optind
	cmp	DWORD PTR first_nonopt, eax
	jle	SHORT $LN18@getopt_int

; 345  : 	    first_nonopt = optind;

	mov	eax, DWORD PTR optind
	mov	DWORD PTR first_nonopt, eax
$LN18@getopt_int:

; 346  : 
; 347  : 	if (ordering == PERMUTE)

	cmp	DWORD PTR ordering, 1
	jne	$LN19@getopt_int

; 348  : 	{
; 349  : 	    /* If we have just processed some options following some non-options,
; 350  : 	       exchange them so that the options come first.  */
; 351  : 
; 352  : 	    if (first_nonopt != last_nonopt && last_nonopt != optind)

	mov	eax, DWORD PTR last_nonopt
	cmp	DWORD PTR first_nonopt, eax
	je	SHORT $LN20@getopt_int
	mov	eax, DWORD PTR optind
	cmp	DWORD PTR last_nonopt, eax
	je	SHORT $LN20@getopt_int

; 353  : 		exchange ((char **) argv);

	mov	rcx, QWORD PTR argv$[rbp]
	call	exchange
	jmp	SHORT $LN21@getopt_int
$LN20@getopt_int:

; 354  : 	    else if (last_nonopt != optind)

	mov	eax, DWORD PTR optind
	cmp	DWORD PTR last_nonopt, eax
	je	SHORT $LN22@getopt_int

; 355  : 		first_nonopt = optind;

	mov	eax, DWORD PTR optind
	mov	DWORD PTR first_nonopt, eax
$LN22@getopt_int:
$LN21@getopt_int:
$LN2@getopt_int:

; 356  : 
; 357  : 	    /* Skip any additional non-options
; 358  : 	       and extend the range of non-options previously skipped.  */
; 359  : 
; 360  : 	    while (optind < argc && NONOPTION_P)

	mov	eax, DWORD PTR argc$[rbp]
	cmp	DWORD PTR optind, eax
	jge	SHORT $LN3@getopt_int
	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN23@getopt_int
	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	test	eax, eax
	jne	SHORT $LN3@getopt_int
$LN23@getopt_int:

; 361  : 		optind++;

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax
	jmp	SHORT $LN2@getopt_int
$LN3@getopt_int:

; 362  : 	    last_nonopt = optind;

	mov	eax, DWORD PTR optind
	mov	DWORD PTR last_nonopt, eax
$LN19@getopt_int:

; 363  : 	}
; 364  : 
; 365  : 	/* The special ARGV-element `--' means premature end of options.
; 366  : 	   Skip it like a null option,
; 367  : 	   then exchange with previous non-options as if it were an option,
; 368  : 	   then skip everything else like a non-option.  */
; 369  : 
; 370  : 	if (optind != argc && !strcmp (argv[optind], "--"))

	mov	eax, DWORD PTR argc$[rbp]
	cmp	DWORD PTR optind, eax
	je	$LN24@getopt_int
	movsxd	rax, DWORD PTR optind
	lea	rdx, OFFSET FLAT:??_C@_02BAABKJLB@?9?9@
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN24@getopt_int

; 371  : 	{
; 372  : 	    optind++;

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax

; 373  : 
; 374  : 	    if (first_nonopt != last_nonopt && last_nonopt != optind)

	mov	eax, DWORD PTR last_nonopt
	cmp	DWORD PTR first_nonopt, eax
	je	SHORT $LN25@getopt_int
	mov	eax, DWORD PTR optind
	cmp	DWORD PTR last_nonopt, eax
	je	SHORT $LN25@getopt_int

; 375  : 		exchange ((char **) argv);

	mov	rcx, QWORD PTR argv$[rbp]
	call	exchange
	jmp	SHORT $LN26@getopt_int
$LN25@getopt_int:

; 376  : 	    else if (first_nonopt == last_nonopt)

	mov	eax, DWORD PTR last_nonopt
	cmp	DWORD PTR first_nonopt, eax
	jne	SHORT $LN27@getopt_int

; 377  : 		first_nonopt = optind;

	mov	eax, DWORD PTR optind
	mov	DWORD PTR first_nonopt, eax
$LN27@getopt_int:
$LN26@getopt_int:

; 378  : 	    last_nonopt = argc;

	mov	eax, DWORD PTR argc$[rbp]
	mov	DWORD PTR last_nonopt, eax

; 379  : 
; 380  : 	    optind = argc;

	mov	eax, DWORD PTR argc$[rbp]
	mov	DWORD PTR optind, eax
$LN24@getopt_int:

; 381  : 	}
; 382  : 
; 383  : 	/* If we have done all the ARGV-elements, stop the scan
; 384  : 	   and back over any non-options that we skipped and permuted.  */
; 385  : 
; 386  : 	if (optind == argc)

	mov	eax, DWORD PTR argc$[rbp]
	cmp	DWORD PTR optind, eax
	jne	SHORT $LN28@getopt_int

; 387  : 	{
; 388  : 	    /* Set the next-arg-index to point at the non-options
; 389  : 	       that we previously skipped, so the caller will digest them.  */
; 390  : 	    if (first_nonopt != last_nonopt)

	mov	eax, DWORD PTR last_nonopt
	cmp	DWORD PTR first_nonopt, eax
	je	SHORT $LN29@getopt_int

; 391  : 		optind = first_nonopt;

	mov	eax, DWORD PTR first_nonopt
	mov	DWORD PTR optind, eax
$LN29@getopt_int:

; 392  : 	    return -1;

	mov	eax, -1
	jmp	$LN1@getopt_int
$LN28@getopt_int:

; 393  : 	}
; 394  : 
; 395  : 	/* If we have come to a non-option and did not permute it,
; 396  : 	   either stop the scan or describe it to the caller and pass it by.  */
; 397  : 
; 398  : 	if (NONOPTION_P)

	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN31@getopt_int
	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	test	eax, eax
	jne	SHORT $LN30@getopt_int
$LN31@getopt_int:

; 399  : 	{
; 400  : 	    if (ordering == REQUIRE_ORDER)

	cmp	DWORD PTR ordering, 0
	jne	SHORT $LN32@getopt_int

; 401  : 		return -1;

	mov	eax, -1
	jmp	$LN1@getopt_int
$LN32@getopt_int:

; 402  : 	    optarg = argv[optind++];

	movsxd	rax, DWORD PTR optind
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR optarg, rax
	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax

; 403  : 	    return 1;

	mov	eax, 1
	jmp	$LN1@getopt_int
$LN30@getopt_int:

; 404  : 	}
; 405  : 
; 406  : 	/* We have found another option-ARGV-element.
; 407  : 	   Skip the initial punctuation.  */
; 408  : 
; 409  : 	nextchar = (argv[optind] + 1

	cmp	QWORD PTR intopts$[rbp], 0
	je	SHORT $LN81@getopt_int
	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN81@getopt_int
	mov	QWORD PTR tv180[rbp], 1
	jmp	SHORT $LN82@getopt_int
$LN81@getopt_int:
	mov	QWORD PTR tv180[rbp], 0
$LN82@getopt_int:
	movsxd	rax, DWORD PTR optind
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, QWORD PTR tv180[rbp]
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	QWORD PTR nextchar, rax
$LN15@getopt_int:

; 410  : 		+ (intopts != NULL && argv[optind][1] == '-'));
; 411  :     }
; 412  : 
; 413  :     /* Decode the current option-ARGV-element.  */
; 414  : 
; 415  :     /* Check whether the ARGV-element is a int option.
; 416  : 
; 417  :        If int_only and the ARGV-element has the form "-f", where f is
; 418  :        a valid short option, don't consider it an abbreviated form of
; 419  :        a int option that starts with f.  Otherwise there would be no
; 420  :        way to give the -f short option.
; 421  : 
; 422  :        On the other hand, if there's a int option "fubar" and
; 423  :        the ARGV-element is "-fu", do consider that an abbreviation of
; 424  :        the int option, just like "--fu", and not "-f" with arg "u".
; 425  : 
; 426  :        This distinction seems to be the most useful approach.  */
; 427  : 
; 428  :     if (intopts != NULL
; 429  : 	    && (argv[optind][1] == '-'

	cmp	QWORD PTR intopts$[rbp], 0
	je	$LN33@getopt_int
	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN34@getopt_int
	cmp	DWORD PTR int_only$[rbp], 0
	je	$LN33@getopt_int
	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	test	eax, eax
	jne	SHORT $LN35@getopt_int
	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	mov	edx, eax
	mov	rcx, QWORD PTR optstring$[rbp]
	call	strchr
	test	rax, rax
	jne	$LN33@getopt_int
$LN35@getopt_int:
$LN34@getopt_int:

; 430  : 		|| (int_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
; 431  :     {
; 432  : 	char *nameend;
; 433  : 	const struct option *p;
; 434  : 	const struct option *pfound = NULL;

	mov	QWORD PTR pfound$3[rbp], 0

; 435  : 	int exact = 0;

	mov	DWORD PTR exact$4[rbp], 0

; 436  : 	int ambig = 0;

	mov	DWORD PTR ambig$5[rbp], 0

; 437  : 	int indfound = -1;

	mov	DWORD PTR indfound$6[rbp], -1

; 438  : 	int option_index;
; 439  : 
; 440  : 	for (nameend = nextchar; *nameend && *nameend != '='; nameend++)

	mov	rax, QWORD PTR nextchar
	mov	QWORD PTR nameend$1[rbp], rax
	jmp	SHORT $LN6@getopt_int
$LN4@getopt_int:
	mov	rax, QWORD PTR nameend$1[rbp]
	inc	rax
	mov	QWORD PTR nameend$1[rbp], rax
$LN6@getopt_int:
	mov	rax, QWORD PTR nameend$1[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN5@getopt_int
	mov	rax, QWORD PTR nameend$1[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN5@getopt_int

; 441  : 	    /* Do nothing.  */ ;

	jmp	SHORT $LN4@getopt_int
$LN5@getopt_int:

; 442  : 
; 443  : 	/* Test all int options for either exact match
; 444  : 	   or abbreviated matches.  */
; 445  : 	for (p = intopts, option_index = 0; p->name; p++, option_index++)

	mov	rax, QWORD PTR intopts$[rbp]
	mov	QWORD PTR p$2[rbp], rax
	mov	DWORD PTR option_index$7[rbp], 0
	jmp	SHORT $LN9@getopt_int
$LN7@getopt_int:
	mov	rax, QWORD PTR p$2[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR p$2[rbp], rax
	mov	eax, DWORD PTR option_index$7[rbp]
	inc	eax
	mov	DWORD PTR option_index$7[rbp], eax
$LN9@getopt_int:
	mov	rax, QWORD PTR p$2[rbp]
	cmp	QWORD PTR [rax], 0
	je	$LN8@getopt_int

; 446  : 	    if (!strncmp (p->name, nextchar, nameend - nextchar))

	mov	rax, QWORD PTR nextchar
	mov	rcx, QWORD PTR nameend$1[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR nextchar
	mov	rax, QWORD PTR p$2[rbp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	jne	$LN36@getopt_int

; 447  : 	    {
; 448  : 		if ((unsigned int) (nameend - nextchar)
; 449  : 			== (unsigned int) strlen (p->name))

	mov	rax, QWORD PTR nextchar
	mov	rcx, QWORD PTR nameend$1[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv224[rbp], rax
	mov	rcx, QWORD PTR p$2[rbp]
	mov	rcx, QWORD PTR [rcx]
	call	strlen
	mov	rcx, QWORD PTR tv224[rbp]
	cmp	ecx, eax
	jne	SHORT $LN37@getopt_int

; 450  : 		{
; 451  : 		    /* Exact match found.  */
; 452  : 		    pfound = p;

	mov	rax, QWORD PTR p$2[rbp]
	mov	QWORD PTR pfound$3[rbp], rax

; 453  : 		    indfound = option_index;

	mov	eax, DWORD PTR option_index$7[rbp]
	mov	DWORD PTR indfound$6[rbp], eax

; 454  : 		    exact = 1;

	mov	DWORD PTR exact$4[rbp], 1

; 455  : 		    break;

	jmp	SHORT $LN8@getopt_int

; 456  : 		}

	jmp	SHORT $LN38@getopt_int
$LN37@getopt_int:

; 457  : 		else if (pfound == NULL)

	cmp	QWORD PTR pfound$3[rbp], 0
	jne	SHORT $LN39@getopt_int

; 458  : 		{
; 459  : 		    /* First nonexact match found.  */
; 460  : 		    pfound = p;

	mov	rax, QWORD PTR p$2[rbp]
	mov	QWORD PTR pfound$3[rbp], rax

; 461  : 		    indfound = option_index;

	mov	eax, DWORD PTR option_index$7[rbp]
	mov	DWORD PTR indfound$6[rbp], eax

; 462  : 		}

	jmp	SHORT $LN40@getopt_int
$LN39@getopt_int:

; 463  : 		else if (int_only
; 464  : 			|| pfound->has_arg != p->has_arg
; 465  : 			|| pfound->flag != p->flag
; 466  : 			|| pfound->val != p->val)

	cmp	DWORD PTR int_only$[rbp], 0
	jne	SHORT $LN42@getopt_int
	mov	rax, QWORD PTR pfound$3[rbp]
	mov	rcx, QWORD PTR p$2[rbp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN42@getopt_int
	mov	rax, QWORD PTR pfound$3[rbp]
	mov	rcx, QWORD PTR p$2[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN42@getopt_int
	mov	rax, QWORD PTR pfound$3[rbp]
	mov	rcx, QWORD PTR p$2[rbp]
	mov	ecx, DWORD PTR [rcx+24]
	cmp	DWORD PTR [rax+24], ecx
	je	SHORT $LN41@getopt_int
$LN42@getopt_int:

; 467  : 		    /* Second or later nonexact match found.  */
; 468  : 		    ambig = 1;

	mov	DWORD PTR ambig$5[rbp], 1
$LN41@getopt_int:
$LN40@getopt_int:
$LN38@getopt_int:
$LN36@getopt_int:

; 469  : 	    }

	jmp	$LN7@getopt_int
$LN8@getopt_int:

; 470  : 
; 471  : 	if (ambig && !exact)

	cmp	DWORD PTR ambig$5[rbp], 0
	je	$LN43@getopt_int
	cmp	DWORD PTR exact$4[rbp], 0
	jne	$LN43@getopt_int

; 472  : 	{
; 473  : 	    if (print_errors)

	cmp	DWORD PTR print_errors$[rbp], 0
	je	SHORT $LN44@getopt_int

; 474  : 	    {
; 475  : 		fprintf (stderr, _("%s: option `%s' is ambiguous\n"),

	movsxd	rax, DWORD PTR optind
	mov	QWORD PTR tv246[rbp], rax
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR tv250[rbp], rcx
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv246[rbp]
	mov	r9, QWORD PTR [rcx+rdx*8]
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv250[rbp]
	mov	r8, QWORD PTR [rcx+rdx]
	lea	rdx, OFFSET FLAT:??_C@_0BO@HAHAPHIK@?$CFs?3?5option?5?$GA?$CFs?8?5is?5ambiguous?6@
	mov	rcx, rax
	call	fprintf
$LN44@getopt_int:

; 476  : 			argv[0], argv[optind]);
; 477  : 	    }
; 478  : 	    nextchar += strlen (nextchar);

	mov	rcx, QWORD PTR nextchar
	call	strlen
	mov	rcx, QWORD PTR nextchar
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR nextchar, rax

; 479  : 	    optind++;

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax

; 480  : 	    optopt = 0;

	mov	DWORD PTR optopt, 0

; 481  : 	    return '?';

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN43@getopt_int:

; 482  : 	}
; 483  : 
; 484  : 	if (pfound != NULL)

	cmp	QWORD PTR pfound$3[rbp], 0
	je	$LN45@getopt_int

; 485  : 	{
; 486  : 	    option_index = indfound;

	mov	eax, DWORD PTR indfound$6[rbp]
	mov	DWORD PTR option_index$7[rbp], eax

; 487  : 	    optind++;

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax

; 488  : 	    if (*nameend)

	mov	rax, QWORD PTR nameend$1[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN46@getopt_int

; 489  : 	    {
; 490  : 		/* Don't test has_arg with >, because some C compilers don't
; 491  : 		   allow it to be used on enums.  */
; 492  : 		if (pfound->has_arg)

	mov	rax, QWORD PTR pfound$3[rbp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN48@getopt_int

; 493  : 		    optarg = nameend + 1;

	mov	rax, QWORD PTR nameend$1[rbp]
	inc	rax
	mov	QWORD PTR optarg, rax
	jmp	$LN49@getopt_int
$LN48@getopt_int:

; 494  : 		else
; 495  : 		{
; 496  : 		    if (print_errors)

	cmp	DWORD PTR print_errors$[rbp], 0
	je	$LN50@getopt_int

; 497  : 		    {
; 498  : 
; 499  : 			if (argv[optind - 1][1] == '-')

	mov	eax, DWORD PTR optind
	dec	eax
	cdqe
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN51@getopt_int

; 500  : 			{
; 501  : 			    /* --option */
; 502  : 			    fprintf (stderr, _("\

	mov	eax, 8
	imul	rax, rax, 0
	mov	QWORD PTR tv279[rbp], rax
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR pfound$3[rbp]
	mov	r9, QWORD PTR [rcx]
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv279[rbp]
	mov	r8, QWORD PTR [rcx+rdx]
	lea	rdx, OFFSET FLAT:??_C@_0DC@LPOFBBEH@?7?7?7?7?7?$CFs?3?5option?5?$GA?9?9?$CFs?8?5doesn?8t?5@
	mov	rcx, rax
	call	fprintf

; 503  : 					%s: option `--%s' doesn't allow an argument\n"),
; 504  : 				    argv[0], pfound->name);
; 505  : 			}

	jmp	SHORT $LN52@getopt_int
$LN51@getopt_int:

; 506  : 			else
; 507  : 			{
; 508  : 			    /* +option or -option */
; 509  : 			    fprintf (stderr, _("\

	mov	eax, DWORD PTR optind
	dec	eax
	cdqe
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	mov	DWORD PTR tv294[rbp], eax
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR tv296[rbp], rcx
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR pfound$3[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+32], rcx
	mov	ecx, DWORD PTR tv294[rbp]
	mov	r9d, ecx
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv296[rbp]
	mov	r8, QWORD PTR [rcx+rdx]
	lea	rdx, OFFSET FLAT:??_C@_0DC@MDOAIFB@?7?7?7?7?7?$CFs?3?5option?5?$GA?$CFc?$CFs?8?5doesn?8t?5@
	mov	rcx, rax
	call	fprintf
$LN52@getopt_int:
$LN50@getopt_int:

; 510  : 					%s: option `%c%s' doesn't allow an argument\n"),
; 511  : 				    argv[0], argv[optind - 1][0], pfound->name);
; 512  : 			}
; 513  : 
; 514  : 		    }
; 515  : 
; 516  : 		    nextchar += strlen (nextchar);

	mov	rcx, QWORD PTR nextchar
	call	strlen
	mov	rcx, QWORD PTR nextchar
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR nextchar, rax

; 517  : 
; 518  : 		    optopt = pfound->val;

	mov	rax, QWORD PTR pfound$3[rbp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR optopt, eax

; 519  : 		    return '?';

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN49@getopt_int:

; 520  : 		}
; 521  : 	    }

	jmp	$LN47@getopt_int
$LN46@getopt_int:

; 522  : 	    else if (pfound->has_arg == 1)

	mov	rax, QWORD PTR pfound$3[rbp]
	cmp	DWORD PTR [rax+8], 1
	jne	$LN53@getopt_int

; 523  : 	    {
; 524  : 		if (optind < argc)

	mov	eax, DWORD PTR argc$[rbp]
	cmp	DWORD PTR optind, eax
	jge	SHORT $LN54@getopt_int

; 525  : 		    optarg = argv[optind++];

	movsxd	rax, DWORD PTR optind
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR optarg, rax
	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax
	jmp	$LN55@getopt_int
$LN54@getopt_int:

; 526  : 		else
; 527  : 		{
; 528  : 		    if (print_errors)

	cmp	DWORD PTR print_errors$[rbp], 0
	je	SHORT $LN56@getopt_int

; 529  : 		    {
; 530  : 			fprintf (stderr,

	mov	eax, DWORD PTR optind
	dec	eax
	cdqe
	mov	QWORD PTR tv316[rbp], rax
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR tv320[rbp], rcx
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv316[rbp]
	mov	r9, QWORD PTR [rcx+rdx*8]
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv320[rbp]
	mov	r8, QWORD PTR [rcx+rdx]
	lea	rdx, OFFSET FLAT:??_C@_0CG@PLJDJCIA@?$CFs?3?5option?5?$GA?$CFs?8?5requires?5an?5arg@
	mov	rcx, rax
	call	fprintf
$LN56@getopt_int:

; 531  : 				_("%s: option `%s' requires an argument\n"),
; 532  : 				argv[0], argv[optind - 1]);
; 533  : 		    }
; 534  : 		    nextchar += strlen (nextchar);

	mov	rcx, QWORD PTR nextchar
	call	strlen
	mov	rcx, QWORD PTR nextchar
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR nextchar, rax

; 535  : 		    optopt = pfound->val;

	mov	rax, QWORD PTR pfound$3[rbp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR optopt, eax

; 536  : 		    return optstring[0] == ':' ? ':' : '?';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR optstring$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN83@getopt_int
	mov	DWORD PTR tv334[rbp], 58		; 0000003aH
	jmp	SHORT $LN84@getopt_int
$LN83@getopt_int:
	mov	DWORD PTR tv334[rbp], 63		; 0000003fH
$LN84@getopt_int:
	mov	eax, DWORD PTR tv334[rbp]
	jmp	$LN1@getopt_int
$LN55@getopt_int:
$LN53@getopt_int:
$LN47@getopt_int:

; 537  : 		}
; 538  : 	    }
; 539  : 	    nextchar += strlen (nextchar);

	mov	rcx, QWORD PTR nextchar
	call	strlen
	mov	rcx, QWORD PTR nextchar
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR nextchar, rax

; 540  : 	    if (intind != NULL)

	cmp	QWORD PTR intind$[rbp], 0
	je	SHORT $LN57@getopt_int

; 541  : 		*intind = option_index;

	mov	rax, QWORD PTR intind$[rbp]
	mov	ecx, DWORD PTR option_index$7[rbp]
	mov	DWORD PTR [rax], ecx
$LN57@getopt_int:

; 542  : 	    if (pfound->flag)

	mov	rax, QWORD PTR pfound$3[rbp]
	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN58@getopt_int

; 543  : 	    {
; 544  : 		*(pfound->flag) = pfound->val;

	mov	rax, QWORD PTR pfound$3[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR pfound$3[rbp]
	mov	ecx, DWORD PTR [rcx+24]
	mov	DWORD PTR [rax], ecx

; 545  : 		return 0;

	xor	eax, eax
	jmp	$LN1@getopt_int
$LN58@getopt_int:

; 546  : 	    }
; 547  : 	    return pfound->val;

	mov	rax, QWORD PTR pfound$3[rbp]
	mov	eax, DWORD PTR [rax+24]
	jmp	$LN1@getopt_int
$LN45@getopt_int:

; 548  : 	}
; 549  : 
; 550  : 	/* Can't find it as a int option.  If this is not getopt_int_only,
; 551  : 	   or the option starts with '--' or is not a valid short
; 552  : 	   option, then it's an error.
; 553  : 	   Otherwise interpret it as a short option.  */
; 554  : 	if (!int_only || argv[optind][1] == '-'
; 555  : 		|| my_index (optstring, *nextchar) == NULL)

	cmp	DWORD PTR int_only$[rbp], 0
	je	SHORT $LN60@getopt_int
	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN60@getopt_int
	mov	rax, QWORD PTR nextchar
	movsx	eax, BYTE PTR [rax]
	mov	edx, eax
	mov	rcx, QWORD PTR optstring$[rbp]
	call	strchr
	test	rax, rax
	jne	$LN59@getopt_int
$LN60@getopt_int:

; 556  : 	{
; 557  : 	    if (print_errors)

	cmp	DWORD PTR print_errors$[rbp], 0
	je	$LN61@getopt_int

; 558  : 	    {
; 559  : 
; 560  : 		if (argv[optind][1] == '-')

	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN62@getopt_int

; 561  : 		{
; 562  : 		    /* --option */
; 563  : 		    fprintf (stderr, _("%s: unrecognized option `--%s'\n"),

	mov	eax, 8
	imul	rax, rax, 0
	mov	QWORD PTR tv368[rbp], rax
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR nextchar
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv368[rbp]
	mov	r8, QWORD PTR [rcx+rdx]
	lea	rdx, OFFSET FLAT:??_C@_0CA@EHMECPBA@?$CFs?3?5unrecognized?5option?5?$GA?9?9?$CFs?8?6@
	mov	rcx, rax
	call	fprintf

; 564  : 			    argv[0], nextchar);
; 565  : 		}

	jmp	SHORT $LN63@getopt_int
$LN62@getopt_int:

; 566  : 		else
; 567  : 		{
; 568  : 		    /* +option or -option */
; 569  : 		    fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),

	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movsx	eax, BYTE PTR [rax+rcx]
	mov	DWORD PTR tv381[rbp], eax
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR tv383[rbp], rcx
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR nextchar
	mov	QWORD PTR [rsp+32], rcx
	mov	ecx, DWORD PTR tv381[rbp]
	mov	r9d, ecx
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv383[rbp]
	mov	r8, QWORD PTR [rcx+rdx]
	lea	rdx, OFFSET FLAT:??_C@_0CA@EBHJAKGL@?$CFs?3?5unrecognized?5option?5?$GA?$CFc?$CFs?8?6@
	mov	rcx, rax
	call	fprintf
$LN63@getopt_int:
$LN61@getopt_int:

; 570  : 			    argv[0], argv[optind][0], nextchar);
; 571  : 		}
; 572  : 
; 573  : 	    }
; 574  : 	    nextchar = (char *) "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR nextchar, rax

; 575  : 	    optind++;

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax

; 576  : 	    optopt = 0;

	mov	DWORD PTR optopt, 0

; 577  : 	    return '?';

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN59@getopt_int:
$LN33@getopt_int:

; 578  : 	}
; 579  :     }
; 580  : 
; 581  :     /* Look at and handle the next short option-character.  */
; 582  : 
; 583  :     {
; 584  : 	char c = *nextchar++;

	mov	rax, QWORD PTR nextchar
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR c$8[rbp], al
	mov	rax, QWORD PTR nextchar
	inc	rax
	mov	QWORD PTR nextchar, rax

; 585  : 	char *temp = my_index (optstring, c);

	movsx	eax, BYTE PTR c$8[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR optstring$[rbp]
	call	strchr
	mov	QWORD PTR temp$9[rbp], rax

; 586  : 
; 587  : 	/* Increment `optind' when we start to process its last character.  */
; 588  : 	if (*nextchar == '\0')

	mov	rax, QWORD PTR nextchar
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN64@getopt_int

; 589  : 	    ++optind;

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax
$LN64@getopt_int:

; 590  : 
; 591  : 	if (temp == NULL || c == ':')

	cmp	QWORD PTR temp$9[rbp], 0
	je	SHORT $LN66@getopt_int
	movsx	eax, BYTE PTR c$8[rbp]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN65@getopt_int
$LN66@getopt_int:

; 592  : 	{
; 593  : 	    if (print_errors)

	cmp	DWORD PTR print_errors$[rbp], 0
	je	SHORT $LN67@getopt_int

; 594  : 	    {
; 595  : 		    /* 1003.2 specifies the format of this message.  */
; 596  : 		    fprintf (stderr, _("%s: illegal option -- %c\n"), argv[0], c);

	movsx	eax, BYTE PTR c$8[rbp]
	mov	DWORD PTR tv403[rbp], eax
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR tv405[rbp], rcx
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	ecx, DWORD PTR tv403[rbp]
	mov	r9d, ecx
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv405[rbp]
	mov	r8, QWORD PTR [rcx+rdx]
	lea	rdx, OFFSET FLAT:??_C@_0BK@NLCMBLAE@?$CFs?3?5illegal?5option?5?9?9?5?$CFc?6@
	mov	rcx, rax
	call	fprintf
$LN67@getopt_int:

; 597  : 	    }
; 598  : 	    optopt = c;

	movsx	eax, BYTE PTR c$8[rbp]
	mov	DWORD PTR optopt, eax

; 599  : 	    return '?';

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN65@getopt_int:

; 600  : 	}
; 601  : #ifdef SPECIAL_TREATMENT_FOR_W
; 602  : 	/* Convenience. Treat POSIX -W foo same as int option --foo */
; 603  : 	if (temp[0] == 'W' && temp[1] == ';')
; 604  : 	{
; 605  : 	    char *nameend;
; 606  : 	    const struct option *p;
; 607  : 	    const struct option *pfound = NULL;
; 608  : 	    int exact = 0;
; 609  : 	    int ambig = 0;
; 610  : 	    int indfound = 0;
; 611  : 	    int option_index;
; 612  : 
; 613  : 	    /* This is an option that requires an argument.  */
; 614  : 	    if (*nextchar != '\0')
; 615  : 	    {
; 616  : 		optarg = nextchar;
; 617  : 		/* If we end this ARGV-element by taking the rest as an arg,
; 618  : 		   we must advance to the next element now.  */
; 619  : 		optind++;
; 620  : 	    }
; 621  : 	    else if (optind == argc)
; 622  : 	    {
; 623  : 		if (print_errors)
; 624  : 		{
; 625  : 		    /* 1003.2 specifies the format of this message.  */
; 626  : 		    fprintf (stderr, _("%s: option requires an argument -- %c\n"),
; 627  : 			    argv[0], c);
; 628  : 		}
; 629  : 		optopt = c;
; 630  : 		if (optstring[0] == ':')
; 631  : 		    c = ':';
; 632  : 		else
; 633  : 		    c = '?';
; 634  : 		return c;
; 635  : 	    }
; 636  : 	    else
; 637  : 		/* We already incremented `optind' once;
; 638  : 		   increment it again when taking next ARGV-elt as argument.  */
; 639  : 		optarg = argv[optind++];
; 640  : 
; 641  : 	    /* optarg is now the argument, see if it's in the
; 642  : 	       table of intopts.  */
; 643  : 
; 644  : 	    for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
; 645  : 		/* Do nothing.  */ ;
; 646  : 
; 647  : 	    /* Test all int options for either exact match
; 648  : 	       or abbreviated matches.  */
; 649  : 	    for (p = intopts, option_index = 0; p->name; p++, option_index++)
; 650  : 		if (!strncmp (p->name, nextchar, nameend - nextchar))
; 651  : 		{
; 652  : 		    if ((unsigned int) (nameend - nextchar) == strlen (p->name))
; 653  : 		    {
; 654  : 			/* Exact match found.  */
; 655  : 			pfound = p;
; 656  : 			indfound = option_index;
; 657  : 			exact = 1;
; 658  : 			break;
; 659  : 		    }
; 660  : 		    else if (pfound == NULL)
; 661  : 		    {
; 662  : 			/* First nonexact match found.  */
; 663  : 			pfound = p;
; 664  : 			indfound = option_index;
; 665  : 		    }
; 666  : 		    else
; 667  : 			/* Second or later nonexact match found.  */
; 668  : 			ambig = 1;
; 669  : 		}
; 670  : 	    if (ambig && !exact)
; 671  : 	    {
; 672  : 		if (print_errors)
; 673  : 		{
; 674  : 		    fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
; 675  : 			    argv[0], argv[optind]);
; 676  : 		}
; 677  : 		nextchar += strlen (nextchar);
; 678  : 		optind++;
; 679  : 		return '?';
; 680  : 	    }
; 681  : 	    if (pfound != NULL)
; 682  : 	    {
; 683  : 		option_index = indfound;
; 684  : 		if (*nameend)
; 685  : 		{
; 686  : 		    /* Don't test has_arg with >, because some C compilers don't
; 687  : 		       allow it to be used on enums.  */
; 688  : 		    if (pfound->has_arg)
; 689  : 			optarg = nameend + 1;
; 690  : 		    else
; 691  : 		    {
; 692  : 			if (print_errors)
; 693  : 			{
; 694  : 			    fprintf (stderr, _("\
; 695  : 					%s: option `-W %s' doesn't allow an argument\n"),
; 696  : 				    argv[0], pfound->name);
; 697  : 			}
; 698  : 
; 699  : 			nextchar += strlen (nextchar);
; 700  : 			return '?';
; 701  : 		    }
; 702  : 		}
; 703  : 		else if (pfound->has_arg == 1)
; 704  : 		{
; 705  : 		    if (optind < argc)
; 706  : 			optarg = argv[optind++];
; 707  : 		    else
; 708  : 		    {
; 709  : 			if (print_errors)
; 710  : 			{
; 711  : 			    fprintf (stderr,
; 712  : 				    _("%s: option `%s' requires an argument\n"),
; 713  : 				    argv[0], argv[optind - 1]);
; 714  : 			}
; 715  : 			nextchar += strlen (nextchar);
; 716  : 			return optstring[0] == ':' ? ':' : '?';
; 717  : 		    }
; 718  : 		}
; 719  : 		nextchar += strlen (nextchar);
; 720  : 		if (intind != NULL)
; 721  : 		    *intind = option_index;
; 722  : 		if (pfound->flag)
; 723  : 		{
; 724  : 		    *(pfound->flag) = pfound->val;
; 725  : 		    return 0;
; 726  : 		}
; 727  : 		return pfound->val;
; 728  : 	    }
; 729  : 	    nextchar = NULL;
; 730  : 	    return 'W';	/* Let the application handle it.   */
; 731  : 	}
; 732  : #endif
; 733  : 	if (temp[1] == ':')

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR temp$9[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	$LN68@getopt_int

; 734  : 	{
; 735  : 	    if (temp[2] == ':')

	mov	eax, 1
	imul	rax, rax, 2
	mov	rcx, QWORD PTR temp$9[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN69@getopt_int

; 736  : 	    {
; 737  : 		/* This is an option that accepts an argument optionally.  */
; 738  : 		if (*nextchar != '\0')

	mov	rax, QWORD PTR nextchar
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN71@getopt_int

; 739  : 		{
; 740  : 		    optarg = nextchar;

	mov	rax, QWORD PTR nextchar
	mov	QWORD PTR optarg, rax

; 741  : 		    optind++;

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax

; 742  : 		}

	jmp	SHORT $LN72@getopt_int
$LN71@getopt_int:

; 743  : 		else
; 744  : 		    optarg = NULL;

	mov	QWORD PTR optarg, 0
$LN72@getopt_int:

; 745  : 		nextchar = NULL;

	mov	QWORD PTR nextchar, 0

; 746  : 	    }

	jmp	$LN70@getopt_int
$LN69@getopt_int:

; 747  : 	    else
; 748  : 	    {
; 749  : 		/* This is an option that requires an argument.  */
; 750  : 		if (*nextchar != '\0')

	mov	rax, QWORD PTR nextchar
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN73@getopt_int

; 751  : 		{
; 752  : 		    optarg = nextchar;

	mov	rax, QWORD PTR nextchar
	mov	QWORD PTR optarg, rax

; 753  : 		    /* If we end this ARGV-element by taking the rest as an arg,
; 754  : 		       we must advance to the next element now.  */
; 755  : 		    optind++;

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax

; 756  : 		}

	jmp	$LN74@getopt_int
$LN73@getopt_int:

; 757  : 		else if (optind == argc)

	mov	eax, DWORD PTR argc$[rbp]
	cmp	DWORD PTR optind, eax
	jne	$LN75@getopt_int

; 758  : 		{
; 759  : 		    if (print_errors)

	cmp	DWORD PTR print_errors$[rbp], 0
	je	SHORT $LN77@getopt_int

; 760  : 		    {
; 761  : 			/* 1003.2 specifies the format of this message.  */
; 762  : 			fprintf (stderr,

	movsx	eax, BYTE PTR c$8[rbp]
	mov	DWORD PTR tv429[rbp], eax
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR tv431[rbp], rcx
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	ecx, DWORD PTR tv429[rbp]
	mov	r9d, ecx
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR tv431[rbp]
	mov	r8, QWORD PTR [rcx+rdx]
	lea	rdx, OFFSET FLAT:??_C@_0CH@FFGNJLF@?$CFs?3?5option?5requires?5an?5argument@
	mov	rcx, rax
	call	fprintf
$LN77@getopt_int:

; 763  : 				_("%s: option requires an argument -- %c\n"),
; 764  : 				argv[0], c);
; 765  : 		    }
; 766  : 		    optopt = c;

	movsx	eax, BYTE PTR c$8[rbp]
	mov	DWORD PTR optopt, eax

; 767  : 		    if (optstring[0] == ':')

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR optstring$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN78@getopt_int

; 768  : 			c = ':';

	mov	BYTE PTR c$8[rbp], 58			; 0000003aH
	jmp	SHORT $LN79@getopt_int
$LN78@getopt_int:

; 769  : 		    else
; 770  : 			c = '?';

	mov	BYTE PTR c$8[rbp], 63			; 0000003fH
$LN79@getopt_int:

; 771  : 		}

	jmp	SHORT $LN76@getopt_int
$LN75@getopt_int:

; 772  : 		else
; 773  : 		    /* We already incremented `optind' once;
; 774  : 		       increment it again when taking next ARGV-elt as argument.  */
; 775  : 		    optarg = argv[optind++];

	movsxd	rax, DWORD PTR optind
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR optarg, rax
	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax
$LN76@getopt_int:
$LN74@getopt_int:

; 776  : 		nextchar = NULL;

	mov	QWORD PTR nextchar, 0
$LN70@getopt_int:
$LN68@getopt_int:

; 777  : 	    }
; 778  : 	}
; 779  : 	return c;

	movsx	eax, BYTE PTR c$8[rbp]
$LN1@getopt_int:

; 780  :     }
; 781  : }

	lea	rsp, QWORD PTR [rbp+536]
	pop	rdi
	pop	rbp
	ret	0
_getopt_internal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT getopt_int_only
_TEXT	SEGMENT
argc$ = 224
argv$ = 232
options$ = 240
int_options$ = 248
opt_index$ = 256
getopt_int_only PROC					; COMDAT

; 802  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__58AF4E6F_getopt@c
	call	__CheckForDebuggerJustMyCode

; 803  :     return _getopt_internal (argc, argv, options, int_options, opt_index, 1);

	mov	DWORD PTR [rsp+40], 1
	mov	rax, QWORD PTR opt_index$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR int_options$[rbp]
	mov	r8, QWORD PTR options$[rbp]
	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	_getopt_internal

; 804  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
getopt_int_only ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\getopt.c
;	COMDAT getopt_int
_TEXT	SEGMENT
argc$ = 224
argv$ = 232
options$ = 240
int_options$ = 248
opt_index$ = 256
getopt_int PROC						; COMDAT

; 791  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__58AF4E6F_getopt@c
	call	__CheckForDebuggerJustMyCode

; 792  :     return _getopt_internal (argc, argv, options, int_options, opt_index, 0);

	mov	DWORD PTR [rsp+40], 0
	mov	rax, QWORD PTR opt_index$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR int_options$[rbp]
	mov	r8, QWORD PTR options$[rbp]
	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	_getopt_internal

; 793  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
getopt_int ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 248
_Stream$ = 288
_Format$ = 296
fprintf	PROC						; COMDAT

; 837  :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rbp]
	mov	rcx, QWORD PTR _Stream$[rbp]
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rbp], eax

; 842  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 843  :         return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 844  :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:fprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rbp]
	mov	r8, QWORD PTR _Format$[rbp]
	mov	rdx, QWORD PTR _Stream$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A2143F22_corecrt_stdio_config@h
	call	__CheckForDebuggerJustMyCode

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
