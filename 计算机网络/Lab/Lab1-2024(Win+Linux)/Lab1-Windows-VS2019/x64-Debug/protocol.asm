; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33523.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04PCJFHION@help@				; `string'
PUBLIC	??_C@_06HMNHKJD@utopia@				; `string'
PUBLIC	??_C@_05ONANONLM@flood@				; `string'
PUBLIC	??_C@_04CMBNNLNM@ibib@				; `string'
PUBLIC	??_C@_05HPGGOJCM@nolog@				; `string'
PUBLIC	??_C@_05GFCDIDHO@debug@				; `string'
PUBLIC	??_C@_04LPGMAPLE@port@				; `string'
PUBLIC	??_C@_03BMIBANNE@ber@				; `string'
PUBLIC	??_C@_03MGHMBJCF@log@				; `string'
PUBLIC	??_C@_03KAFGPDAP@ttl@				; `string'
msvcjmc	SEGMENT
__6A72211D_concurrencysal@h DB 01H
__CC30173B_sal@h DB 01H
__7EF21AAA_vadefs@h DB 01H
__657088F7_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__A0B61CF9_time@h DB 01H
__D0DFFAC6_winpackagefamily@h DB 01H
__D0D0F397_winapifamily@h DB 01H
__94A3FDDD_sdkddkver@h DB 01H
__6B66097A_excpt@h DB 01H
__3220CA03_stdarg@h DB 01H
__1C9F390F_specstrings_undef@h DB 01H
__36A21E95_specstrings_strict@h DB 01H
__452FE810_sdv_driverspecs@h DB 01H
__30F344B3_driverspecs@h DB 01H
__BD886E18_specstrings@h DB 01H
__5DB64B66_corecrt_wctype@h DB 01H
__B2D2BA86_ctype@h DB 01H
__BF9C347F_kernelspecs@h DB 01H
__79C7FC57_basetsd@h DB 01H
__CDDAF8CA_errno@h DB 01H
__74F97FEA_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__D545DD43_guiddef@h DB 01H
__DF4F952E_pshpack4@h DB 01H
__7FCD0577_poppack@h DB 01H
__DBC2E99C_pshpack2@h DB 01H
__D6556C4A_pshpack8@h DB 01H
__D98457C5_pshpack1@h DB 01H
__614C4572_apiset@h DB 01H
__8500295D_ktmtypes@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__156BD51A_minwindef@h DB 01H
__F9B9A8F7_windef@h DB 01H
__BD2C4590_apisetcconv@h DB 01H
__18251742_minwinbase@h DB 01H
__23611203_apiquery2@h DB 01H
__C914CD48_processenv@h DB 01H
__996311FD_fileapi@h DB 01H
__41AEF397_fileapifromapp@h DB 01H
__65579FF3_debugapi@h DB 01H
__476FCB5A_utilapiset@h DB 01H
__089D2E42_handleapi@h DB 01H
__B16F04F5_errhandlingapi@h DB 01H
__81CCB02F_fibersapi@h DB 01H
__A9B4C5F0_namedpipeapi@h DB 01H
__C209F2C8_profileapi@h DB 01H
__34C22DC8_heapapi@h DB 01H
__8A238485_ioapiset@h DB 01H
__4826BA69_synchapi@h DB 01H
__6A31599C_interlockedapi@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__7BB37CFA_sysinfoapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__6D078C0D_enclaveapi@h DB 01H
__3663CE50_threadpoollegacyapiset@h DB 01H
__E16717D9_threadpoolapiset@h DB 01H
__4A6035CC_jobapi@h DB 01H
__62EEB553_jobapi2@h DB 01H
__9F22E7EF_wow64apiset@h DB 01H
__E86B4A9A_libloaderapi@h DB 01H
__EB536E54_securitybaseapi@h DB 01H
__E915C287_namespaceapi@h DB 01H
__C66F44F2_systemtopologyapi@h DB 01H
__B6175B28_processtopologyapi@h DB 01H
__9E4AD838_securityappcontainer@h DB 01H
__F599FDAE_realtimeapiset@h DB 01H
__D4435474_winerror@h DB 01H
__F94F31E6_timezoneapi@h DB 01H
__B3ED30D4_winbase@h DB 01H
__E9F7D11F_wingdi@h DB 01H
__AC21C382_tvout@h DB 01H
__DB057BA3_winuser@h DB 01H
__A1BAD304_datetimeapi@h DB 01H
__30E2BD27_winnls@h DB 01H
__B7FF4B97_stringapiset@h DB 01H
__66C87297_wincontypes@h DB 01H
__1317218F_consoleapi@h DB 01H
__8D62D26D_consoleapi2@h DB 01H
__8CA0B85A_consoleapi3@h DB 01H
__CE39E65B_wincon@h DB 01H
__F6801ACC_verrsrc@h DB 01H
__1CB844D9_winver@h DB 01H
__D0CFA71C_reason@h DB 01H
__F3D58382_winreg@h DB 01H
__34C28572_wnnc@h DB 01H
__0617DE59_winnetwk@h DB 01H
__93AC9EF8_cderr@h DB 01H
__3AE29FFA_dde@h DB 01H
__48250249_ddeml@h DB 01H
__4605C6DD_dlgs@h DB 01H
__C826BBA2_lzexpand@h DB 01H
__B8DFB118_mmsyscom@h DB 01H
__EDC2A662_mciapi@h DB 01H
__87B17D5B_mmiscapi@h DB 01H
__0C4862FC_mmiscapi2@h DB 01H
__83F5D08C_playsoundapi@h DB 01H
__CA3F1D44_mmeapi@h DB 01H
__BD2270BE_timeapi@h DB 01H
__397CAA2F_joystickapi@h DB 01H
__05A21AEE_mmsystem@h DB 01H
__6E1DF0B6_nb30@h DB 01H
__75098885_rpcdcep@h DB 01H
__D8AC8DD5_rpcdce@h DB 01H
__2F1118EF_rpcnsi@h DB 01H
__0DE10DFC_rpcnterr@h DB 01H
__4497164E_rpcasync@h DB 01H
__06CA6763_rpc@h DB 01H
__C32EC2F2_shellapi@h DB 01H
__B289ECB8_winperf@h DB 01H
__FD938996_bcrypt@h DB 01H
__4E32BFB9_ncrypt@h DB 01H
__815AA9AD_dpapi@h DB 01H
__0B2E95FF_wincrypt@h DB 01H
__288F6C52_winefs@h DB 01H
__B3F2ECA2_rpcnsip@h DB 01H
__AFB43543_rpcsal@h DB 01H
__16A21838_rpcndr@h DB 01H
__5314805F_wtypesbase@h DB 01H
__6EEE3703_wtypes@h DB 01H
__A7113148_winioctl@h DB 01H
__C595A37C_winsmcrd@h DB 01H
__42C56FB7_winscard@h DB 01H
__C4703BCA_prsht@h DB 01H
__D4D77F19_winspool@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__B8895AF3_limits@h DB 01H
__B49664B7_stdlib@h DB 01H
__B47185B4_unknwnbase@h DB 01H
__B64C33F8_objidlbase@h DB 01H
__EA871F04_cguid@h DB 01H
__C78732AB_combaseapi@h DB 01H
__744BF5DA_unknwn@h DB 01H
__66C491E7_objidl@h DB 01H
__A217658B_oaidl@h DB 01H
__8485F416_propidlbase@h DB 01H
__65805CE1_coml2api@h DB 01H
__C7AD586F_oleidl@h DB 01H
__CBE55221_servprov@h DB 01H
__5B1E268A_msxml@h DB 01H
__1B3D3678_urlmon@h DB 01H
__EC5BC72C_propidl@h DB 01H
__0DD0E8F8_objbase@h DB 01H
__6DA674A0_oleauto@h DB 01H
__F7931962_ole2@h DB 01H
__870E9EB1_commdlg@h DB 01H
__A118E6DC_stralign@h DB 01H
__8B10FA9F_winsvc@h DB 01H
__BEDBF511_mcx@h DB 01H
__D3BCC989_ime_cmodes@h DB 01H
__B1694579_imm@h DB 01H
__4D4D253D_windows@h DB 01H
__07EA6B7C_inaddr@h DB 01H
__9ED0251E_winsock@h DB 01H
__A9063C41_corecrt_share@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__2671BD82_corecrt_io@h DB 01H
__9B190114_io@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__64F617E8_types@h DB 01H
__E2B48F07_timeb@h DB 01H
__CF7D97E7_getopt@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__91D68F2D_math@h DB 01H
__7935898B_lprintf@h DB 01H
__7A0070CF_protocol@h DB 01H
__EDD2A947_protocol@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_03KAFGPDAP@ttl@
CONST	SEGMENT
??_C@_03KAFGPDAP@ttl@ DB 'ttl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log@
CONST	SEGMENT
??_C@_03MGHMBJCF@log@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMIBANNE@ber@
CONST	SEGMENT
??_C@_03BMIBANNE@ber@ DB 'ber', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LPGMAPLE@port@
CONST	SEGMENT
??_C@_04LPGMAPLE@port@ DB 'port', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFCDIDHO@debug@
CONST	SEGMENT
??_C@_05GFCDIDHO@debug@ DB 'debug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HPGGOJCM@nolog@
CONST	SEGMENT
??_C@_05HPGGOJCM@nolog@ DB 'nolog', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CMBNNLNM@ibib@
CONST	SEGMENT
??_C@_04CMBNNLNM@ibib@ DB 'ibib', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONANONLM@flood@
CONST	SEGMENT
??_C@_05ONANONLM@flood@ DB 'flood', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HMNHKJD@utopia@
CONST	SEGMENT
??_C@_06HMNHKJD@utopia@ DB 'utopia', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help@
CONST	SEGMENT
??_C@_04PCJFHION@help@ DB 'help', 00H			; `string'
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	get_ms
PUBLIC	protocol_init
PUBLIC	wait_for_event
PUBLIC	enable_network_layer
PUBLIC	disable_network_layer
PUBLIC	get_packet
PUBLIC	put_packet
PUBLIC	recv_frame
PUBLIC	send_frame
PUBLIC	phl_sq_len
PUBLIC	start_timer
PUBLIC	stop_timer
PUBLIC	start_ack_timer
PUBLIC	stop_ack_timer
PUBLIC	station_name
PUBLIC	dbg_event
PUBLIC	dbg_frame
PUBLIC	dbg_warning
PUBLIC	get_timer
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@ ; `string'
PUBLIC	??_C@_01FHEEJDEE@A@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B@				; `string'
PUBLIC	??_C@_03MAMPKPPK@XXX@				; `string'
PUBLIC	??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@ ; `string'
PUBLIC	??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@	; `string'
PUBLIC	??_C@_03JODACOMD@nul@				; `string'
PUBLIC	??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@		; `string'
PUBLIC	??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@ ; `string'
PUBLIC	??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@ ; `string'
PUBLIC	??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@	; `string'
PUBLIC	??_C@_04JLMDILM@?4exe@				; `string'
PUBLIC	??_C@_06GOMLAJLH@?9A?4log@			; `string'
PUBLIC	??_C@_06OIFPHLBJ@?9B?4log@			; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@ ; `string'
PUBLIC	??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0M@OBEILHJM@May?5?58?52024@		; `string'
PUBLIC	??_C@_03EMGHBCAM@4?40@				; `string'
PUBLIC	??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@ ; `string'
PUBLIC	??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@ ; `string'
PUBLIC	??_C@_05KDIEGDNJ@?$CF?41E?6@			; `string'
PUBLIC	??_C@_02NODKCLPH@0?6@				; `string'
PUBLIC	??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@ ; `string'
PUBLIC	??_C@_0BC@BNICANMP@Create?5TCP?5socket@		; `string'
PUBLIC	??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@ ; `string'
PUBLIC	??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@ ; `string'
PUBLIC	??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@ ; `string'
PUBLIC	??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@ ; `string'
PUBLIC	??_C@_06MJLDIBBJ@Done?4?6@			; `string'
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41@			; `string'
PUBLIC	??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@ ; `string'
PUBLIC	??_C@_08OPNBKLNK@Failed?$CB?6@			; `string'
PUBLIC	??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@ ; `string'
PUBLIC	??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@		; `string'
PUBLIC	??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@ ; `string'
PUBLIC	??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@	; `string'
PUBLIC	??_C@_0BB@IAFLKGG@No?5enough?5memory@		; `string'
PUBLIC	??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@	; `string'
PUBLIC	??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@ ; `string'
PUBLIC	??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@ ; `string'
PUBLIC	??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@ ; `string'
PUBLIC	??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@ ; `string'
PUBLIC	??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@		; `string'
PUBLIC	??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@ ; `string'
PUBLIC	??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@ ; `string'
PUBLIC	??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@ ; `string'
PUBLIC	??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@ ; `string'
PUBLIC	??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@	; `string'
PUBLIC	??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@ ; `string'
PUBLIC	??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@ ; `string'
PUBLIC	??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@ ; `string'
PUBLIC	??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_06EJNPPGH@Quit?4?6@			; `string'
PUBLIC	??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@400c000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40bf400000000000
PUBLIC	__real@40e0000000000000
EXTRN	__imp_asctime:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_tolower:PROC
EXTRN	__imp__errno:PROC
EXTRN	memcpy:PROC
EXTRN	strcat:PROC
EXTRN	strcpy:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_strtod:PROC
EXTRN	__WSAFDIsSet:PROC
EXTRN	accept:PROC
EXTRN	bind:PROC
EXTRN	connect:PROC
EXTRN	htons:PROC
EXTRN	inet_addr:PROC
EXTRN	listen:PROC
EXTRN	recv:PROC
EXTRN	select:PROC
EXTRN	send:PROC
EXTRN	setsockopt:PROC
EXTRN	socket:PROC
EXTRN	WSAStartup:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp__ftime64:PROC
EXTRN	getopt_int:PROC
EXTRN	pow:PROC
EXTRN	lprintf:PROC
EXTRN	__v_lprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	optarg:QWORD
EXTRN	optind:DWORD
EXTRN	log_file:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
epoch	DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
head_magic DD	020H DUP (?)
station	DD	01H DUP (?)
mode_ibib DD	01H DUP (?)
mode_flood DD	01H DUP (?)
debug_mask DD	01H DUP (?)
sock	DQ	01H DUP (?)
now	DD	01H DUP (?)
noise	DD	01H DUP (?)
sq	DB	020000H DUP (?)
sq_head	DD	01H DUP (?)
sq_tail	DD	01H DUP (?)
send_bytes_allowed DD 01H DUP (?)
?last_ts@?1??socket_send@@9@9 DD 01H DUP (?)		; `socket_send'::`2'::last_ts
rblk_head DQ	01H DUP (?)
rblk_tail DQ	01H DUP (?)
nbits	DD	01H DUP (?)
timer	DD	081H DUP (?)
network_layer_active DD 01H DUP (?)
rpackets DD	01H DUP (?)
rbytes	DD	01H DUP (?)
?last_ts@?1??network_layer_ready@@9@9 DD 01H DUP (?)	; `network_layer_ready'::`2'::last_ts
layer3_ready DD	01H DUP (?)
?pkt_no@?1??get_packet@@9@9 DD 01H DUP (?)		; `get_packet'::`2'::pkt_no
ts0	DD	01H DUP (?)
?last_ts@?1??put_packet@@9@9 DD 01H DUP (?)		; `put_packet'::`2'::last_ts
sleep_cnt DD	01H DUP (?)
start_ms DD	01H DUP (?)
wakeup_ms DD	01H DUP (?)
busy_cnt DD	01H DUP (?)
bias_cnt DD	01H DUP (?)
	ALIGN	8

rf_head	DQ	01H DUP (?)
rf_tail	DQ	01H DUP (?)
rf_buf	DQ	01H DUP (?)
?last_warn@?BF@??wait_for_event@@9@9 DQ 01H DUP (?)	; `wait_for_event'::`21'::last_warn
foot_magic DD	020H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+54
	DD	imagerel $unwind$localtime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+54
	DD	imagerel $unwind$time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+103
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+191
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+158
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+184
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$socket_init DD imagerel socket_init
	DD	imagerel socket_init+159
	DD	imagerel $unwind$socket_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ms DD imagerel $LN5
	DD	imagerel $LN5+183
	DD	imagerel $unwind$get_ms
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$protocol_init DD imagerel $LN30
	DD	imagerel $LN30+1141
	DD	imagerel $unwind$protocol_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wait_for_event DD imagerel $LN49
	DD	imagerel $LN49+1599
	DD	imagerel $unwind$wait_for_event
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$enable_network_layer DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$enable_network_layer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$disable_network_layer DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$disable_network_layer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_packet DD imagerel $LN12
	DD	imagerel $LN12+273
	DD	imagerel $unwind$get_packet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$put_packet DD imagerel $LN17
	DD	imagerel $LN17+490
	DD	imagerel $unwind$put_packet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recv_frame DD imagerel $LN12
	DD	imagerel $LN12+343
	DD	imagerel $unwind$recv_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_frame DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$send_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$phl_sq_len DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$phl_sq_len
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$start_timer DD imagerel $LN7
	DD	imagerel $LN7+140
	DD	imagerel $unwind$start_timer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stop_timer DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$stop_timer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$start_ack_timer DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$start_ack_timer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stop_ack_timer DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$stop_ack_timer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$station_name DD imagerel $LN7
	DD	imagerel $LN7+122
	DD	imagerel $unwind$station_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbg_event DD imagerel $LN4
	DD	imagerel $LN4+177
	DD	imagerel $unwind$dbg_event
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbg_frame DD imagerel $LN4
	DD	imagerel $LN4+177
	DD	imagerel $unwind$dbg_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dbg_warning DD imagerel $LN4
	DD	imagerel $LN4+177
	DD	imagerel $unwind$dbg_warning
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$magic_init DD imagerel magic_init
	DD	imagerel magic_init+98
	DD	imagerel $unwind$magic_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$magic_check DD imagerel magic_check
	DD	imagerel magic_check+166
	DD	imagerel $unwind$magic_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$config DD imagerel config
	DD	imagerel config+1291
	DD	imagerel $unwind$config
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sq_len DD imagerel sq_len
	DD	imagerel sq_len+70
	DD	imagerel $unwind$sq_len
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_byte DD imagerel send_byte
	DD	imagerel send_byte+216
	DD	imagerel $unwind$send_byte
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_sq_data DD imagerel send_sq_data
	DD	imagerel send_sq_data+150
	DD	imagerel $unwind$send_sq_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$socket_send DD imagerel socket_send
	DD	imagerel socket_send+325
	DD	imagerel $unwind$socket_send
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$socket_recv DD imagerel socket_recv
	DD	imagerel socket_recv+691
	DD	imagerel $unwind$socket_recv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$recv_byte DD imagerel recv_byte
	DD	imagerel recv_byte+183
	DD	imagerel $unwind$recv_byte
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_timer DD imagerel $LN7
	DD	imagerel $LN7+147
	DD	imagerel $unwind$get_timer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scan_timer DD imagerel scan_timer
	DD	imagerel scan_timer+179
	DD	imagerel $unwind$scan_timer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$network_layer_ready DD imagerel network_layer_ready
	DD	imagerel network_layer_ready+261
	DD	imagerel $unwind$network_layer_ready
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$randA DD	imagerel randA
	DD	imagerel randA+72
	DD	imagerel $unwind$randA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$randB DD	imagerel randB
	DD	imagerel randB+72
	DD	imagerel $unwind$randB
pdata	ENDS
;	COMDAT __real@40e0000000000000
CONST	SEGMENT
__real@40e0000000000000 DQ 040e0000000000000r	; 32768
CONST	ENDS
;	COMDAT __real@40bf400000000000
CONST	SEGMENT
__real@40bf400000000000 DQ 040bf400000000000r	; 8000
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@400c000000000000
CONST	SEGMENT
__real@400c000000000000 DQ 0400c000000000000r	; 3.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@
CONST	SEGMENT
??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@ DB 'Memory used'
	DB	' by ''protocol.lib'' is corrupted by your program', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EJNPPGH@Quit?4?6@
CONST	SEGMENT
??_C@_06EJNPPGH@Quit?4?6@ DB 'Quit.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@ DB '+'
	DB	'+++++ Sleep(%d)=%d+%d (cnt %d)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@
CONST	SEGMENT
??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@ DB '-'
	DB	'----- noSleep %d, sleep %d, Elapse %d ticks', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@
CONST	SEGMENT
??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@ DB '='
	DB	'===== CPU BUSY for %d ms (cnt %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@
CONST	SEGMENT
??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@ DB '** W'
	DB	'ARNING: System too busy, sleep %d ms, but be awakened %d ms l'
	DB	'ater', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@
CONST	SEGMENT
??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@ DB 'system select()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@
CONST	SEGMENT
??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@ DB 'rec'
	DB	'v_frame(): %d-byte buffer is too small to save %d-byte receiv'
	DB	'ed frame', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@
CONST	SEGMENT
??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@ DB 'recv_fr'
	DB	'ame(): Receiving Queue is empty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@
CONST	SEGMENT
??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@ DB '.'
	DB	'... %d packets received, %.0f bps, %.2f%%, Err %d (%.1e)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@
CONST	SEGMENT
??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@ DB 'Network Laye'
	DB	'r received a bad packet from data link layer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@
CONST	SEGMENT
??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@ DB 'Bad Packet length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@
CONST	SEGMENT
??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@ DB 'get_pa'
	DB	'cket(): Network layer is not ready for a new packet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@
CONST	SEGMENT
??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@ DB 'start'
	DB	'_timer(): timer No. must be 0~128', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@
CONST	SEGMENT
??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@ DB 'recv_by'
	DB	'te(): Receiving Queue is empty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@
CONST	SEGMENT
??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@ DB 'Impose nois'
	DB	'e on received data, %u/%u=%.1E', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@
CONST	SEGMENT
??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@ DB 'TCP disconnected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IAFLKGG@No?5enough?5memory@
CONST	SEGMENT
??_C@_0BB@IAFLKGG@No?5enough?5memory@ DB 'No enough memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@
CONST	SEGMENT
??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@ DB 'TCP Disconnected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@
CONST	SEGMENT
??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@ DB 'Physical Laye'
	DB	'r Sending Queue overflow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'============================================================='
	DB	'===', 0aH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@
CONST	SEGMENT
??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@ DB 'New epoch: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@
CONST	SEGMENT
??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@ DB 'Station B fa'
	DB	'iled to connect station A', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OPNBKLNK@Failed?$CB?6@
CONST	SEGMENT
??_C@_08OPNBKLNK@Failed?$CB?6@ DB 'Failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@
CONST	SEGMENT
??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@ DB 'Station B is '
	DB	'connecting station A (TCP port %u) ... ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41@ DB '127.0.0.1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJLDIBBJ@Done?4?6@
CONST	SEGMENT
??_C@_06MJLDIBBJ@Done?4?6@ DB 'Done.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@
CONST	SEGMENT
??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@ DB 'Station A fai'
	DB	'led to communicate with station B', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@
CONST	SEGMENT
??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@ DB 'Station A is'
	DB	' waiting for station B on TCP port %u ... ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@
CONST	SEGMENT
??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@ DB 'Station A f'
	DB	'ailed to bind TCP port', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@
CONST	SEGMENT
??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@ DB 'Station A:'
	DB	' Failed to bind TCP port %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BNICANMP@Create?5TCP?5socket@
CONST	SEGMENT
??_C@_0BC@BNICANMP@Create?5TCP?5socket@ DB 'Create TCP socket', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@
CONST	SEGMENT
??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@ DB 'L'
	DB	'og file "%s", TCP port %d, debug mask 0x%02x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NODKCLPH@0?6@
CONST	SEGMENT
??_C@_02NODKCLPH@0?6@ DB '0', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDIEGDNJ@?$CF?41E?6@
CONST	SEGMENT
??_C@_05KDIEGDNJ@?$CF?41E?6@ DB '%.1E', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@
CONST	SEGMENT
??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@ DB 'Chan'
	DB	'nel: %d bps, %d ms propagation delay, bit error rate ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@
CONST	SEGMENT
??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@ DB 'Protocol'
	DB	'.lib, version %s, jiangyanjun0718@bupt.edu.cn', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMGHBCAM@4?40@
CONST	SEGMENT
??_C@_03EMGHBCAM@4?40@ DB '4.0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OBEILHJM@May?5?58?52024@
CONST	SEGMENT
??_C@_0M@OBEILHJM@May?5?58?52024@ DB 'May  8 2024', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'============================================================', 0aH
	DB	'                    Station %s                               '
	DB	0aH, '--------------------------------------------------------'
	DB	'-----', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@
CONST	SEGMENT
??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@ DB 'WARNING: Fa'
	DB	'iled to create log file "%s": %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06OIFPHLBJ@?9B?4log@
CONST	SEGMENT
??_C@_06OIFPHLBJ@?9B?4log@ DB '-B.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GOMLAJLH@?9A?4log@
CONST	SEGMENT
??_C@_06GOMLAJLH@?9A?4log@ DB '-A.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLMDILM@?4exe@
CONST	SEGMENT
??_C@_04JLMDILM@?4exe@ DB '.exe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
CONST	SEGMENT
??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@ DB 0aH, 'FATAL: %s', 0aH, 'A'
	DB	'bort.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@
CONST	SEGMENT
??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@ DB 'Station'
	DB	' name must be ''A'' or ''B''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@
CONST	SEGMENT
??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@ DB 'ERROR: Unsupported'
	DB	' option', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@
CONST	SEGMENT
??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@ DB 'Bad BER %.3f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JODACOMD@nul@
CONST	SEGMENT
??_C@_03JODACOMD@nul@ DB 'nul', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@
CONST	SEGMENT
??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@ DB '?ufind:p:b:l:t:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@
CONST	SEGMENT
??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@ DB 0aH
	DB	'Options : ', 0aH, '    -?, --help : print this', 0aH, '    -u'
	DB	', --utopia : utopia channel (an error-free channel)', 0aH, ' '
	DB	'   -f, --flood : flood traffic', 0aH, '    -i, --ibib  : set '
	DB	'station B layer 3 sender mode as IDLE-BUSY-IDLE-BUSY-...', 0aH
	DB	'    -n, --nolog : do not create log file', 0aH, '    -d, --de'
	DB	'bug=<0-7>: debug mask (bit0:event, bit1:frame, bit2:warning)', 0aH
	DB	'    -p, --port=<port#> : TCP port number (default: %u)', 0aH, ' '
	DB	'   -b, --ber=<ber> : Bit Error Rate (received data only)', 0aH
	DB	'    -l, --log=<filename> : using assigned file as log file', 0aH
	DB	'    -t, --ttl=<seconds> : set time-to-live', 0aH, 0aH, 'i.e.', 0aH
	DB	'    %s -fd3 -b 1e-4 A', 0aH, '    %s --flood --debug=3 --ber='
	DB	'1e-4 A', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@
CONST	SEGMENT
??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@ DB 0aH
	DB	'Usage:', 0aH, '  %s <options> <station-name>', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MAMPKPPK@XXX@
CONST	SEGMENT
??_C@_03MAMPKPPK@XXX@ DB 'XXX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B@
CONST	SEGMENT
??_C@_01HMGJMAIH@B@ DB 'B', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01FHEEJDEE@A@
CONST	SEGMENT
??_C@_01FHEEJDEE@A@ DB 'A', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
ber	DQ	03ee4f8b588e368f1r		; 1e-05
mode_cycle DD	064H
mode_life DD	07fffff00H
mode_tick DD	0fH
mode_seed DD	098bcde1H
port	DW	0e708H
	ORG $+6
intopts	DQ	FLAT:??_C@_04PCJFHION@help@
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	03fH
	ORG $+4
	DQ	FLAT:??_C@_06HMNHKJD@utopia@
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	075H
	ORG $+4
	DQ	FLAT:??_C@_05ONANONLM@flood@
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	066H
	ORG $+4
	DQ	FLAT:??_C@_04CMBNNLNM@ibib@
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	069H
	ORG $+4
	DQ	FLAT:??_C@_05HPGGOJCM@nolog@
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	06eH
	ORG $+4
	DQ	FLAT:??_C@_05GFCDIDHO@debug@
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	064H
	ORG $+4
	DQ	FLAT:??_C@_04LPGMAPLE@port@
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	070H
	ORG $+4
	DQ	FLAT:??_C@_03BMIBANNE@ber@
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	062H
	ORG $+4
	DQ	FLAT:??_C@_03MGHMBJCF@log@
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06cH
	ORG $+4
	DQ	FLAT:??_C@_03KAFGPDAP@ttl@
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	074H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
inform_phl_ready DD 01H
?holdrand@?1??randA@@9@9 DD 065109bc4H			; `randA'::`2'::holdrand
?holdrand@?1??randB@@9@9 DD 01e459090H			; `randB'::`2'::holdrand
_DATA	ENDS
;	COMDAT ??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@
CONST	SEGMENT
??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@ DB 'Windows Socket DLL '
	DB	'Error', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$randB DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$randA DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$network_layer_ready DD 025050f01H
	DD	010a230fH
	DD	07003001fH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scan_timer DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_timer DD 025051201H
	DD	010d2312H
	DD	07006001fH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recv_byte DD 025050f01H
	DD	010a230fH
	DD	070030025H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$socket_recv DD 025050f01H
	DD	010a230fH
	DD	070030031H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$socket_send DD 025050f01H
	DD	010a230fH
	DD	070030029H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_sq_data DD 025051601H
	DD	01112316H
	DD	0700a0021H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_byte DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sq_len DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	039H
	DW	048dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$config DD 035054019H
	DD	01123317H
	DD	0700b00d9H
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	06b0H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
config$rtcName$0 DB 066H
	DB	06eH
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
	ORG $+10
config$rtcVarDesc DD 040H
	DD	0400H
	DQ	FLAT:config$rtcName$0
	ORG $+48
config$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:config$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$magic_check DD 025050f01H
	DD	010a230fH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$magic_init DD 025050f01H
	DD	010a230fH
	DD	070030021H
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	098H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbg_warning DD 025054c19H
	DD	011d2322H
	DD	070160021H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
dbg_warning$rtcName$0 DB 061H
	DB	072H
	DB	067H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+8
dbg_warning$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:dbg_warning$rtcName$0
	ORG $+48
dbg_warning$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:dbg_warning$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	098H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbg_frame DD 025054c19H
	DD	011d2322H
	DD	070160021H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
dbg_frame$rtcName$0 DB 061H
	DB	072H
	DB	067H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+8
dbg_frame$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:dbg_frame$rtcName$0
	ORG $+48
dbg_frame$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:dbg_frame$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	098H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dbg_event DD 025054c19H
	DD	011d2322H
	DD	070160021H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
dbg_event$rtcName$0 DB 061H
	DB	072H
	DB	067H
	DB	05fH
	DB	070H
	DB	074H
	DB	072H
	DB	00H
	ORG $+8
dbg_event$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:dbg_event$rtcName$0
	ORG $+48
dbg_event$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:dbg_event$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$station_name DD 025050f01H
	DD	010a230fH
	DD	07003001fH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stop_ack_timer DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$start_ack_timer DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stop_timer DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$start_timer DD 025051601H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$phl_sq_len DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_frame DD 025051701H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03aH
	DW	013eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recv_frame DD 025054119H
	DD	01122317H
	DD	0700b0049H
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	0238H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
recv_frame$rtcName$0 DB 06dH
	DB	073H
	DB	067H
	DB	00H
	ORG $+12
recv_frame$rtcVarDesc DD 070H
	DD	0100H
	DQ	FLAT:recv_frame$rtcName$0
	ORG $+48
recv_frame$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:recv_frame$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$put_packet DD 035051701H
	DD	01123317H
	DD	0700b002bH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_packet DD 025051301H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$disable_network_layer DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enable_network_layer DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0626H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wait_for_event DD 035053d19H
	DD	010e3313H
	DD	070070103H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0808H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
wait_for_event$rtcName$0 DB 072H
	DB	066H
	DB	064H
	DB	00H
wait_for_event$rtcName$1 DB 077H
	DB	066H
	DB	064H
	DB	00H
wait_for_event$rtcName$2 DB 074H
	DB	06dH
	DB	00H
	ORG $+5
wait_for_event$rtcVarDesc DD 0498H
	DD	08H
	DQ	FLAT:wait_for_event$rtcName$2
	DD	0270H
	DD	0208H
	DQ	FLAT:wait_for_event$rtcName$1
	DD	040H
	DD	0208H
	DQ	FLAT:wait_for_event$rtcName$0
	ORG $+144
wait_for_event$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:wait_for_event$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	039H
	DW	045cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$protocol_init DD 035054019H
	DD	01123317H
	DD	0700b003dH
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	01d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
protocol_init$rtcName$0 DB 06eH
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
	ORG $+3
protocol_init$rtcName$1 DB 074H
	DB	069H
	DB	06dH
	DB	065H
	DB	06fH
	DB	075H
	DB	074H
	DB	05fH
	DB	06dH
	DB	073H
	DB	00H
	ORG $+5
protocol_init$rtcName$2 DB 062H
	DB	075H
	DB	066H
	DB	05fH
	DB	073H
	DB	069H
	DB	07aH
	DB	065H
	DB	00H
	ORG $+3
protocol_init$rtcName$3 DB 06fH
	DB	06eH
	DB	00H
	ORG $+9
protocol_init$rtcVarDesc DD 0104H
	DD	04H
	DQ	FLAT:protocol_init$rtcName$3
	DD	0e4H
	DD	04H
	DQ	FLAT:protocol_init$rtcName$2
	DD	0c4H
	DD	04H
	DQ	FLAT:protocol_init$rtcName$1
	DD	078H
	DD	010H
	DQ	FLAT:protocol_init$rtcName$0
	ORG $+192
protocol_init$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:protocol_init$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02aH
	DB	09eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ms DD 025053119H
	DD	010a230fH
	DD	070030025H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0110H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
get_ms$rtcName$0 DB 074H
	DB	06dH
	DB	00H
	ORG $+13
get_ms$rtcVarDesc DD 028H
	DD	010H
	DQ	FLAT:get_ms$rtcName$0
	ORG $+48
get_ms$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:get_ms$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02aH
	DB	086H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$socket_init DD 025053119H
	DD	010a230fH
	DD	07003005dH
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	02d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
socket_init$rtcName$0 DB 057H
	DB	053H
	DB	041H
	DB	044H
	DB	061H
	DB	074H
	DB	061H
	DB	00H
	ORG $+8
socket_init$rtcVarDesc DD 050H
	DD	0198H
	DQ	FLAT:socket_init$rtcName$0
	ORG $+48
socket_init$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:socket_init$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	09fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 025054c19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 035052201H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 035052201H
	DD	011d3322H
	DD	070160023H
	DD	05015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	045H
	DB	0a6H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 025054c19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 035052201H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time DD	025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$localtime DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT randB
_TEXT	SEGMENT
randB	PROC						; COMDAT

; 627  : {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 628  :     static unsigned int holdrand = 0x1e459090;
; 629  :     return ((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff;

	imul	eax, DWORD PTR ?holdrand@?1??randB@@9@9, 214013 ; 000343fdH
	add	eax, 2531011				; 00269ec3H
	mov	DWORD PTR ?holdrand@?1??randB@@9@9, eax
	mov	eax, DWORD PTR ?holdrand@?1??randB@@9@9
	shr	eax, 16
	and	eax, 32767				; 00007fffH

; 630  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
randB	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT randA
_TEXT	SEGMENT
randA	PROC						; COMDAT

; 621  : {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 622  :     static unsigned int holdrand = 0x65109bc4;
; 623  :     return ((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff;

	imul	eax, DWORD PTR ?holdrand@?1??randA@@9@9, 214013 ; 000343fdH
	add	eax, 2531011				; 00269ec3H
	mov	DWORD PTR ?holdrand@?1??randA@@9@9, eax
	mov	eax, DWORD PTR ?holdrand@?1??randA@@9@9
	shr	eax, 16
	and	eax, 32767				; 00007fffH

; 624  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
randA	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT network_layer_ready
_TEXT	SEGMENT
tv76 = 192
network_layer_ready PROC				; COMDAT

; 594  : {

	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 595  :     static int last_ts = 0;
; 596  : 
; 597  :     if (!network_layer_active)

	cmp	DWORD PTR network_layer_active, 0
	jne	SHORT $LN2@network_la

; 598  :         return 0;

	xor	eax, eax
	jmp	$LN1@network_la
$LN2@network_la:

; 599  : 
; 600  :     if (mode_flood) 

	cmp	DWORD PTR mode_flood, 0
	je	SHORT $LN3@network_la

; 601  :         return 1;

	mov	eax, 1
	jmp	$LN1@network_la
$LN3@network_la:

; 602  : 
; 603  :     if ((now - last_ts) * CHAN_BPS / 8 / 1000 < PKT_LEN * 3 / 4)

	mov	eax, DWORD PTR ?last_ts@?1??network_layer_ready@@9@9
	mov	ecx, DWORD PTR now
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 8000				; 00001f40H
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cmp	eax, 192				; 000000c0H
	jge	SHORT $LN4@network_la

; 604  :         return 0;

	xor	eax, eax
	jmp	$LN1@network_la
$LN4@network_la:

; 605  : 
; 606  :     if (station == 'b') {

	cmp	DWORD PTR station, 98			; 00000062H
	jne	SHORT $LN5@network_la

; 607  :         if (now / 1000 / mode_cycle % 2 != mode_ibib) {

	mov	eax, DWORD PTR now
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	cdq
	idiv	DWORD PTR mode_cycle
	cdq
	and	eax, 1
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR mode_ibib
	je	SHORT $LN6@network_la

; 608  :             if (now - last_ts < 4000 + rand() % 500)

	mov	eax, DWORD PTR ?last_ts@?1??network_layer_ready@@9@9
	mov	ecx, DWORD PTR now
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv76[rbp], eax
	call	QWORD PTR __imp_rand
	cdq
	mov	ecx, 500				; 000001f4H
	idiv	ecx
	mov	eax, edx
	add	eax, 4000				; 00000fa0H
	mov	ecx, DWORD PTR tv76[rbp]
	cmp	ecx, eax
	jge	SHORT $LN7@network_la

; 609  :                 return 0;

	xor	eax, eax
	jmp	SHORT $LN1@network_la
$LN7@network_la:
$LN6@network_la:

; 610  :         }
; 611  :         if (now < CHAN_DELAY + 3 * PKT_LEN * 8000 / CHAN_BPS)

	cmp	DWORD PTR now, 1038			; 0000040eH
	jge	SHORT $LN8@network_la

; 612  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@network_la
$LN8@network_la:
$LN5@network_la:

; 613  :     }
; 614  : 
; 615  :     last_ts = now;

	mov	eax, DWORD PTR now
	mov	DWORD PTR ?last_ts@?1??network_layer_ready@@9@9, eax

; 616  : 
; 617  :     return 1;

	mov	eax, 1
$LN1@network_la:

; 618  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
network_layer_ready ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT scan_timer
_TEXT	SEGMENT
i$ = 4
tv78 = 212
nr$ = 256
scan_timer PROC						; COMDAT

; 565  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 566  :     int i;
; 567  : 
; 568  :     for (i = 0; i < NTIMER; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@scan_timer
$LN2@scan_timer:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@scan_timer:
	cmp	DWORD PTR i$[rbp], 129			; 00000081H
	jge	SHORT $LN3@scan_timer

; 569  :         if (timer[i] && timer[i] <= now) {

	movsxd	rax, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:timer
	cmp	DWORD PTR [rcx+rax*4], 0
	je	SHORT $LN5@scan_timer
	movsxd	rax, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:timer
	mov	edx, DWORD PTR now
	cmp	DWORD PTR [rcx+rax*4], edx
	jg	SHORT $LN5@scan_timer

; 570  :             *nr = i;

	mov	rax, QWORD PTR nr$[rbp]
	mov	ecx, DWORD PTR i$[rbp]
	mov	DWORD PTR [rax], ecx

; 571  :             timer[i] = 0;

	movsxd	rax, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:timer
	mov	DWORD PTR [rcx+rax*4], 0

; 572  :             return i == ACK_TIMER_ID ? ACK_TIMEOUT : DATA_TIMEOUT;

	cmp	DWORD PTR i$[rbp], 128			; 00000080H
	jne	SHORT $LN7@scan_timer
	mov	DWORD PTR tv78[rbp], 4
	jmp	SHORT $LN8@scan_timer
$LN7@scan_timer:
	mov	DWORD PTR tv78[rbp], 3
$LN8@scan_timer:
	mov	eax, DWORD PTR tv78[rbp]
	jmp	SHORT $LN1@scan_timer
$LN5@scan_timer:

; 573  :         }
; 574  :     }

	jmp	SHORT $LN2@scan_timer
$LN3@scan_timer:

; 575  :     return 0;

	xor	eax, eax
$LN1@scan_timer:

; 576  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
scan_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT get_timer
_TEXT	SEGMENT
tv77 = 192
nr$ = 240
get_timer PROC						; COMDAT

; 547  : {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 548  :     if (nr >= ACK_TIMER_ID || timer[nr] == 0)

	cmp	DWORD PTR nr$[rbp], 128			; 00000080H
	jae	SHORT $LN3@get_timer
	mov	eax, DWORD PTR nr$[rbp]
	lea	rcx, OFFSET FLAT:timer
	cmp	DWORD PTR [rcx+rax*4], 0
	jne	SHORT $LN2@get_timer
$LN3@get_timer:

; 549  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@get_timer
$LN2@get_timer:

; 550  :     return timer[nr] > now ? timer[nr] - now : 0;

	mov	eax, DWORD PTR nr$[rbp]
	lea	rcx, OFFSET FLAT:timer
	mov	edx, DWORD PTR now
	cmp	DWORD PTR [rcx+rax*4], edx
	jle	SHORT $LN5@get_timer
	mov	eax, DWORD PTR nr$[rbp]
	lea	rcx, OFFSET FLAT:timer
	mov	edx, DWORD PTR now
	mov	eax, DWORD PTR [rcx+rax*4]
	sub	eax, edx
	mov	DWORD PTR tv77[rbp], eax
	jmp	SHORT $LN6@get_timer
$LN5@get_timer:
	mov	DWORD PTR tv77[rbp], 0
$LN6@get_timer:
	mov	eax, DWORD PTR tv77[rbp]
$LN1@get_timer:

; 551  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
get_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT recv_byte
_TEXT	SEGMENT
ch$ = 4
blk$ = 40
recv_byte PROC						; COMDAT

; 511  : {

	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 512  :     unsigned char ch;
; 513  :     struct BLK *blk = rblk_head;

	mov	rax, QWORD PTR rblk_head
	mov	QWORD PTR blk$[rbp], rax

; 514  : 
; 515  :     if (blk == NULL || blk->commit_ts > now) 

	cmp	QWORD PTR blk$[rbp], 0
	je	SHORT $LN6@recv_byte
	mov	rax, QWORD PTR blk$[rbp]
	mov	ecx, DWORD PTR now
	cmp	DWORD PTR [rax], ecx
	jle	SHORT $LN5@recv_byte
$LN6@recv_byte:
$LN4@recv_byte:

; 516  :         ABORT("recv_byte(): Receiving Queue is empty");

	lea	rdx, OFFSET FLAT:??_C@_0CG@PEJMNMJG@recv_byte?$CI?$CJ?3?5Receiving?5Queue?5is@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@recv_byte
$LN5@recv_byte:

; 517  : 
; 518  :     ch = blk->data[blk->rptr++];

	mov	rax, QWORD PTR blk$[rbp]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR blk$[rbp]
	movzx	eax, BYTE PTR [rcx+rax+24]
	mov	BYTE PTR ch$[rbp], al
	mov	rax, QWORD PTR blk$[rbp]
	mov	eax, DWORD PTR [rax+4]
	inc	eax
	mov	rcx, QWORD PTR blk$[rbp]
	mov	DWORD PTR [rcx+4], eax

; 519  :     if (blk->rptr == blk->wptr) {

	mov	rax, QWORD PTR blk$[rbp]
	mov	rcx, QWORD PTR blk$[rbp]
	mov	ecx, DWORD PTR [rcx+8]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN7@recv_byte

; 520  :         rblk_head = blk->link;

	mov	rax, QWORD PTR blk$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR rblk_head, rax

; 521  :         free(blk);

	mov	rcx, QWORD PTR blk$[rbp]
	call	QWORD PTR __imp_free
$LN7@recv_byte:

; 522  :     } 
; 523  :     
; 524  :     return ch;

	movzx	eax, BYTE PTR ch$[rbp]
$LN8@recv_byte:

; 525  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
recv_byte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT socket_recv
_TEXT	SEGMENT
blk$ = 8
p$ = 40
a$1 = 68
rate$2 = 104
fact$3 = 136
tv224 = 340
tv132 = 344
tv94 = 344
socket_recv PROC					; COMDAT

; 465  : {

	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 466  :     struct BLK *blk;
; 467  :     unsigned char *p;
; 468  : 
; 469  :     blk = (struct BLK *)malloc(sizeof(struct BLK));

	mov	ecx, 272				; 00000110H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR blk$[rbp], rax

; 470  :     if (blk == NULL) 

	cmp	QWORD PTR blk$[rbp], 0
	jne	SHORT $LN5@socket_rec
$LN4@socket_rec:

; 471  :         ABORT("No enough memory");

	lea	rdx, OFFSET FLAT:??_C@_0BB@IAFLKGG@No?5enough?5memory@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@socket_rec
$LN5@socket_rec:

; 472  : 
; 473  :     blk->rptr = 0;

	mov	rax, QWORD PTR blk$[rbp]
	mov	DWORD PTR [rax+4], 0

; 474  :     blk->wptr = recv(sock, (char *)blk->data, BLKSIZE, 0);

	mov	rax, QWORD PTR blk$[rbp]
	add	rax, 24
	xor	r9d, r9d
	mov	r8d, 242				; 000000f2H
	mov	rdx, rax
	mov	rcx, QWORD PTR sock
	call	recv
	mov	rcx, QWORD PTR blk$[rbp]
	mov	DWORD PTR [rcx+8], eax

; 475  :     if (blk->wptr <= 0) {

	mov	rax, QWORD PTR blk$[rbp]
	cmp	DWORD PTR [rax+8], 0
	jg	SHORT $LN6@socket_rec

; 476  :         lprintf("TCP disconnected.\n");

	lea	rcx, OFFSET FLAT:??_C@_0BD@CKCCJIIP@TCP?5disconnected?4?6@
	call	lprintf

; 477  :         exit(0);

	xor	ecx, ecx
	call	QWORD PTR __imp_exit
$LN6@socket_rec:

; 478  :     }
; 479  :     nbits += blk->wptr * 4;

	mov	rax, QWORD PTR blk$[rbp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR nbits
	lea	eax, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR nbits, eax

; 480  : 
; 481  :     /* Impose noise */
; 482  :     if (ber != 0.0) {

	movsd	xmm0, QWORD PTR ber
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	jp	SHORT $LN15@socket_rec
	je	$LN7@socket_rec
$LN15@socket_rec:

; 483  :         int a;
; 484  :         double rate, fact;
; 485  : 
; 486  :         rate = (double)noise / nbits;

	cvtsi2sd xmm0, DWORD PTR noise
	mov	eax, DWORD PTR nbits
	cvtsi2sd xmm1, rax
	divsd	xmm0, xmm1
	movsd	QWORD PTR rate$2[rbp], xmm0

; 487  :         fact = rate > ber ? 3.5 : 6.0;

	movsd	xmm0, QWORD PTR rate$2[rbp]
	comisd	xmm0, QWORD PTR ber
	jbe	SHORT $LN13@socket_rec
	movsd	xmm0, QWORD PTR __real@400c000000000000
	movsd	QWORD PTR tv94[rbp], xmm0
	jmp	SHORT $LN14@socket_rec
$LN13@socket_rec:
	movsd	xmm0, QWORD PTR __real@4018000000000000
	movsd	QWORD PTR tv94[rbp], xmm0
$LN14@socket_rec:
	movsd	xmm0, QWORD PTR tv94[rbp]
	movsd	QWORD PTR fact$3[rbp], xmm0

; 488  :         a = (int)((1.0 - pow(1.0 - ber, fact * blk->wptr)) * (RAND_MAX + 1.0) + 0.5);

	mov	rax, QWORD PTR blk$[rbp]
	cvtsi2sd xmm0, DWORD PTR [rax+8]
	movsd	xmm1, QWORD PTR fact$3[rbp]
	mulsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, QWORD PTR ber
	movsd	QWORD PTR tv132[rbp], xmm1
	movaps	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv132[rbp]
	call	pow
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	subsd	xmm1, xmm0
	movaps	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@40e0000000000000
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR a$1[rbp], eax

; 489  :         if (rand() <= a) {

	call	QWORD PTR __imp_rand
	cmp	eax, DWORD PTR a$1[rbp]
	jg	$LN8@socket_rec

; 490  :             p = &blk->data[rand() % blk->wptr];

	call	QWORD PTR __imp_rand
	cdq
	mov	rcx, QWORD PTR blk$[rbp]
	idiv	DWORD PTR [rcx+8]
	mov	eax, edx
	cdqe
	mov	rcx, QWORD PTR blk$[rbp]
	lea	rax, QWORD PTR [rcx+rax+24]
	mov	QWORD PTR p$[rbp], rax

; 491  :             if (*p & 0x0f) {

	mov	rax, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rax]
	and	eax, 15
	test	eax, eax
	je	SHORT $LN9@socket_rec

; 492  :                 *p ^= 1 << (rand() % 8);

	call	QWORD PTR __imp_rand
	cdq
	and	edx, 7
	add	eax, edx
	and	eax, 7
	sub	eax, edx
	mov	ecx, 1
	mov	DWORD PTR tv224[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv224[rbp]
	shl	eax, cl
	mov	rcx, QWORD PTR p$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	xor	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR p$[rbp]
	mov	BYTE PTR [rcx], al

; 493  :                 noise++;

	mov	eax, DWORD PTR noise
	inc	eax
	mov	DWORD PTR noise, eax

; 494  :                 dbg_warning("Impose noise on received data, %u/%u=%.1E\n", noise, nbits, (double)noise / nbits);

	cvtsi2sd xmm0, DWORD PTR noise
	mov	eax, DWORD PTR nbits
	cvtsi2sd xmm1, rax
	divsd	xmm0, xmm1
	movaps	xmm3, xmm0
	movq	r9, xmm3
	mov	r8d, DWORD PTR nbits
	mov	edx, DWORD PTR noise
	lea	rcx, OFFSET FLAT:??_C@_0CL@JGOGPNDK@Impose?5noise?5on?5received?5data?0?5@
	call	dbg_warning
$LN9@socket_rec:
$LN8@socket_rec:
$LN7@socket_rec:

; 495  :             }
; 496  :         }
; 497  :     }
; 498  : 
; 499  :     blk->commit_ts = now + CHAN_DELAY - 10;

	mov	eax, DWORD PTR now
	add	eax, 260				; 00000104H
	mov	rcx, QWORD PTR blk$[rbp]
	mov	DWORD PTR [rcx], eax

; 500  :     blk->link = NULL; 

	mov	rax, QWORD PTR blk$[rbp]
	mov	QWORD PTR [rax+16], 0

; 501  : 
; 502  :     if (rblk_head == NULL) 

	cmp	QWORD PTR rblk_head, 0
	jne	SHORT $LN10@socket_rec

; 503  :         rblk_head = rblk_tail = blk;

	mov	rax, QWORD PTR blk$[rbp]
	mov	QWORD PTR rblk_tail, rax
	mov	rax, QWORD PTR rblk_tail
	mov	QWORD PTR rblk_head, rax
	jmp	SHORT $LN11@socket_rec
$LN10@socket_rec:

; 504  :     else {
; 505  :         rblk_tail->link = blk;

	mov	rax, QWORD PTR rblk_tail
	mov	rcx, QWORD PTR blk$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 506  :         rblk_tail = blk;

	mov	rax, QWORD PTR blk$[rbp]
	mov	QWORD PTR rblk_tail, rax
$LN11@socket_rec:
$LN12@socket_rec:

; 507  :     }
; 508  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
socket_recv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT socket_send
_TEXT	SEGMENT
n$ = 4
send_tail$ = 36
send_bytes$ = 68
socket_send PROC					; COMDAT

; 421  : {

	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 422  :     static int last_ts = 0;
; 423  :     int n, send_tail = sq_head, send_bytes;

	mov	eax, DWORD PTR sq_head
	mov	DWORD PTR send_tail$[rbp], eax

; 424  : 
; 425  :     if (last_ts == 0) 

	cmp	DWORD PTR ?last_ts@?1??socket_send@@9@9, 0
	jne	SHORT $LN2@socket_sen

; 426  :         last_ts = now;

	mov	eax, DWORD PTR now
	mov	DWORD PTR ?last_ts@?1??socket_send@@9@9, eax
$LN2@socket_sen:

; 427  : 
; 428  :     if (now <= last_ts) 

	mov	eax, DWORD PTR ?last_ts@?1??socket_send@@9@9
	cmp	DWORD PTR now, eax
	jg	SHORT $LN3@socket_sen

; 429  :         return;

	jmp	$LN1@socket_sen
$LN3@socket_sen:

; 430  : 
; 431  :     send_bytes_allowed = (now - last_ts) * CHAN_BPS / 8 / 1000 * 2;

	mov	eax, DWORD PTR ?last_ts@?1??socket_send@@9@9
	mov	ecx, DWORD PTR now
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, eax, 8000				; 00001f40H
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	shl	eax, 1
	mov	DWORD PTR send_bytes_allowed, eax

; 432  :     n = sq_len();

	call	sq_len
	mov	DWORD PTR n$[rbp], eax

; 433  :     if (n > send_bytes_allowed)

	mov	eax, DWORD PTR send_bytes_allowed
	cmp	DWORD PTR n$[rbp], eax
	jle	SHORT $LN4@socket_sen

; 434  :         n = send_bytes_allowed;

	mov	eax, DWORD PTR send_bytes_allowed
	mov	DWORD PTR n$[rbp], eax
$LN4@socket_sen:

; 435  :     sq_inc(send_tail, n);

	mov	eax, DWORD PTR n$[rbp]
	mov	ecx, DWORD PTR send_tail$[rbp]
	add	ecx, eax
	mov	eax, ecx
	cdq
	and	edx, 131071				; 0001ffffH
	add	eax, edx
	and	eax, 131071				; 0001ffffH
	sub	eax, edx
	mov	DWORD PTR send_tail$[rbp], eax

; 436  : 
; 437  :     if (send_tail >= sq_head) 

	mov	eax, DWORD PTR sq_head
	cmp	DWORD PTR send_tail$[rbp], eax
	jl	SHORT $LN5@socket_sen

; 438  :         send_bytes = send_sq_data(sq_head, send_tail);

	mov	edx, DWORD PTR send_tail$[rbp]
	mov	ecx, DWORD PTR sq_head
	call	send_sq_data
	mov	DWORD PTR send_bytes$[rbp], eax
	jmp	SHORT $LN6@socket_sen
$LN5@socket_sen:

; 439  :     else {
; 440  :         send_bytes = send_sq_data(sq_head, SQ_SIZE);

	mov	edx, 131072				; 00020000H
	mov	ecx, DWORD PTR sq_head
	call	send_sq_data
	mov	DWORD PTR send_bytes$[rbp], eax

; 441  :         send_bytes += send_sq_data(0, send_tail);

	mov	edx, DWORD PTR send_tail$[rbp]
	xor	ecx, ecx
	call	send_sq_data
	mov	ecx, DWORD PTR send_bytes$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR send_bytes$[rbp], eax
$LN6@socket_sen:

; 442  :     }
; 443  : 
; 444  :     sq_inc(sq_head, send_bytes);

	mov	eax, DWORD PTR send_bytes$[rbp]
	mov	ecx, DWORD PTR sq_head
	add	ecx, eax
	mov	eax, ecx
	cdq
	and	edx, 131071				; 0001ffffH
	add	eax, edx
	and	eax, 131071				; 0001ffffH
	sub	eax, edx
	mov	DWORD PTR sq_head, eax

; 445  :     send_bytes_allowed -= send_bytes;

	mov	eax, DWORD PTR send_bytes$[rbp]
	mov	ecx, DWORD PTR send_bytes_allowed
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR send_bytes_allowed, eax

; 446  : 
; 447  :     last_ts = now;

	mov	eax, DWORD PTR now
	mov	DWORD PTR ?last_ts@?1??socket_send@@9@9, eax
$LN1@socket_sen:

; 448  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
socket_send ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT send_sq_data
_TEXT	SEGMENT
ret$ = 4
start$ = 256
end1$ = 264
send_sq_data PROC					; COMDAT

; 405  : {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 406  :     int ret;
; 407  : 
; 408  :     if (start >= end1) 

	mov	eax, DWORD PTR end1$[rbp]
	cmp	DWORD PTR start$[rbp], eax
	jb	SHORT $LN2@send_sq_da

; 409  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@send_sq_da
$LN2@send_sq_da:

; 410  : 
; 411  :     ret = send(sock, (char *)&sq[start], end1 - start, 0);

	mov	eax, DWORD PTR start$[rbp]
	mov	ecx, DWORD PTR end1$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR start$[rbp]
	lea	rdx, OFFSET FLAT:sq
	add	rdx, rcx
	mov	rcx, rdx
	xor	r9d, r9d
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR sock
	call	send
	mov	DWORD PTR ret$[rbp], eax

; 412  :     if (ret <= 0) {

	cmp	DWORD PTR ret$[rbp], 0
	jg	SHORT $LN3@send_sq_da

; 413  :         lprintf("TCP Disconnected.\n");

	lea	rcx, OFFSET FLAT:??_C@_0BD@KCOHKGBB@TCP?5Disconnected?4?6@
	call	lprintf

; 414  :         exit(0);

	xor	ecx, ecx
	call	QWORD PTR __imp_exit
$LN3@send_sq_da:

; 415  :     }
; 416  : 
; 417  :     return ret;

	mov	eax, DWORD PTR ret$[rbp]
$LN1@send_sq_da:
$LN4@send_sq_da:

; 418  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
send_sq_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT send_byte
_TEXT	SEGMENT
byte$ = 224
send_byte PROC						; COMDAT

; 375  : {

	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 376  :     inform_phl_ready = 1;

	mov	DWORD PTR inform_phl_ready, 1

; 377  : 
; 378  :     if (send_bytes_allowed && sq_head == sq_tail) {

	cmp	DWORD PTR send_bytes_allowed, 0
	je	SHORT $LN5@send_byte
	mov	eax, DWORD PTR sq_tail
	cmp	DWORD PTR sq_head, eax
	jne	SHORT $LN5@send_byte

; 379  :         send(sock, (char *)&byte, 1, 0);

	xor	r9d, r9d
	mov	r8d, 1
	lea	rdx, QWORD PTR byte$[rbp]
	mov	rcx, QWORD PTR sock
	call	send

; 380  :         send_bytes_allowed--;

	mov	eax, DWORD PTR send_bytes_allowed
	dec	eax
	mov	DWORD PTR send_bytes_allowed, eax

; 381  :         return;

	jmp	SHORT $LN1@send_byte
$LN5@send_byte:

; 382  :     }
; 383  : 
; 384  :     if (sq_len() == SQ_SIZE - 1)

	call	sq_len
	cmp	eax, 131071				; 0001ffffH
	jne	SHORT $LN6@send_byte
$LN4@send_byte:

; 385  :         ABORT("Physical Layer Sending Queue overflow");

	lea	rdx, OFFSET FLAT:??_C@_0CG@MBEEEGJE@Physical?5Layer?5Sending?5Queue?5ov@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@send_byte
$LN6@send_byte:

; 386  : 
; 387  :     sq[sq_tail] = byte;

	movsxd	rax, DWORD PTR sq_tail
	lea	rcx, OFFSET FLAT:sq
	movzx	edx, BYTE PTR byte$[rbp]
	mov	BYTE PTR [rcx+rax], dl

; 388  :     sq_inc(sq_tail, 1);

	mov	eax, DWORD PTR sq_tail
	inc	eax
	cdq
	and	edx, 131071				; 0001ffffH
	add	eax, edx
	and	eax, 131071				; 0001ffffH
	sub	eax, edx
	mov	DWORD PTR sq_tail, eax
$LN1@send_byte:
$LN7@send_byte:

; 389  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
send_byte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT sq_len
_TEXT	SEGMENT
sq_len	PROC						; COMDAT

; 365  : {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 366  :     return (sq_tail + SQ_SIZE - sq_head) % SQ_SIZE;

	mov	eax, DWORD PTR sq_tail
	add	eax, 131072				; 00020000H
	sub	eax, DWORD PTR sq_head
	cdq
	and	edx, 131071				; 0001ffffH
	add	eax, edx
	and	eax, 131071				; 0001ffffH
	sub	eax, edx

; 367  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
sq_len	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT config
_TEXT	SEGMENT
fname$ = 16
opt$ = 1060
tv149 = 1652
tv87 = 1652
tv180 = 1656
__$ArrayPad$ = 1664
argc$ = 1712
argv$ = 1720
config	PROC						; COMDAT

; 137  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 1736				; 000006c8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rdi, QWORD PTR [rsp+48]
	mov	ecx, 278				; 00000116H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+1768]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 138  : 	char fname[1024];
; 139  : 	int opt;
; 140  : 
; 141  : 	if (argc < 2) {

	cmp	DWORD PTR argc$[rbp], 2
	jge	SHORT $LN9@config
$usage$36:

; 142  : 	usage:
; 143  : 		printf("\nUsage:\n  %s <options> <station-name>\n", argv[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:??_C@_0CH@NDPJCFCA@?6Usage?3?6?5?5?$CFs?5?$DMoptions?$DO?5?$DMstation@
	call	printf

; 144  : 		printf(

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR argv$[rbp]
	mov	r9, QWORD PTR [rdx+rax]
	mov	rax, QWORD PTR argv$[rbp]
	mov	r8, QWORD PTR [rax+rcx]
	mov	edx, 59144				; 0000e708H
	lea	rcx, OFFSET FLAT:??_C@_0CFO@JFDGIOEB@?6Options?5?3?5?6?5?5?5?5?9?$DP?0?5?9?9help?5?3?5pr@
	call	printf

; 145  : 			"\nOptions : \n"
; 146  : 			"    -?, --help : print this\n"
; 147  : 			"    -u, --utopia : utopia channel (an error-free channel)\n"
; 148  : 			"    -f, --flood : flood traffic\n"
; 149  : 			"    -i, --ibib  : set station B layer 3 sender mode as IDLE-BUSY-IDLE-BUSY-...\n"
; 150  : 			"    -n, --nolog : do not create log file\n"
; 151  : 			"    -d, --debug=<0-7>: debug mask (bit0:event, bit1:frame, bit2:warning)\n"
; 152  : 			"    -p, --port=<port#> : TCP port number (default: %u)\n"
; 153  : 			"    -b, --ber=<ber> : Bit Error Rate (received data only)\n"
; 154  : 			"    -l, --log=<filename> : using assigned file as log file\n"
; 155  : 			"    -t, --ttl=<seconds> : set time-to-live\n"
; 156  : 			"\n"
; 157  : 			"i.e.\n"
; 158  : 			"    %s -fd3 -b 1e-4 A\n"
; 159  : 			"    %s --flood --debug=3 --ber=1e-4 A\n"
; 160  : 			"\n",
; 161  : 			DEFAULT_PORT, argv[0], argv[0]);
; 162  : 		exit(0);

	xor	ecx, ecx
	call	QWORD PTR __imp_exit
$LN9@config:

; 163  : 	}
; 164  : 
; 165  : 	strcpy(fname, "");

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR fname$[rbp]
	call	strcpy
$LN2@config:

; 166  : 
; 167  : 	while ((opt = getopt_long(argc, argv, OPT_SHORT, intopts, NULL)) != -1) {

	mov	QWORD PTR [rsp+32], 0
	lea	r9, OFFSET FLAT:intopts
	lea	r8, OFFSET FLAT:??_C@_0BA@BCMIMHDL@?$DPufind?3p?3b?3l?3t?3@
	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	getopt_int
	mov	DWORD PTR opt$[rbp], eax
	cmp	DWORD PTR opt$[rbp], -1
	je	$LN3@config

; 168  : 		switch (opt) {

	mov	eax, DWORD PTR opt$[rbp]
	mov	DWORD PTR tv87[rbp], eax
	mov	eax, DWORD PTR tv87[rbp]
	sub	eax, 63					; 0000003fH
	mov	DWORD PTR tv87[rbp], eax
	cmp	DWORD PTR tv87[rbp], 54			; 00000036H
	ja	$LN21@config
	movsxd	rax, DWORD PTR tv87[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN34@config[rcx+rax]
	mov	eax, DWORD PTR $LN35@config[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN10@config:

; 169  : 		case '?':
; 170  : 			goto usage;

	jmp	$usage$36
$LN11@config:

; 171  : 
; 172  : 		case 'u':
; 173  : 			ber = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR ber, xmm0

; 174  : 			break;

	jmp	$LN4@config
$LN12@config:

; 175  : 
; 176  : 		case 'f':
; 177  : 			mode_flood = 1;

	mov	DWORD PTR mode_flood, 1

; 178  : 			break;

	jmp	$LN4@config
$LN13@config:

; 179  : 
; 180  : 		case 'i':
; 181  : 			mode_ibib = 1;

	mov	DWORD PTR mode_ibib, 1

; 182  : 			break;

	jmp	$LN4@config
$LN14@config:

; 183  : 
; 184  : 		case 'n':
; 185  : 			strcpy(fname, "nul");

	lea	rdx, OFFSET FLAT:??_C@_03JODACOMD@nul@
	lea	rcx, QWORD PTR fname$[rbp]
	call	strcpy

; 186  : 			break;

	jmp	$LN4@config
$LN15@config:

; 187  : 
; 188  : 		case 'd':
; 189  : 			debug_mask = atoi(optarg);

	mov	rcx, QWORD PTR optarg
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR debug_mask, eax

; 190  : 			break;

	jmp	$LN4@config
$LN16@config:

; 191  : 
; 192  : 		case 'p':
; 193  : 			port = (unsigned short)atoi(optarg);

	mov	rcx, QWORD PTR optarg
	call	QWORD PTR __imp_atoi
	mov	WORD PTR port, ax

; 194  : 			break;

	jmp	$LN4@config
$LN17@config:

; 195  : 
; 196  : 		case 'b':
; 197  : 			ber = strtod(optarg, 0);

	xor	edx, edx
	mov	rcx, QWORD PTR optarg
	call	QWORD PTR __imp_strtod
	movsd	QWORD PTR ber, xmm0

; 198  : 			if (ber >= 1.0) {

	movsd	xmm0, QWORD PTR ber
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jb	SHORT $LN18@config

; 199  : 				printf("Bad BER %.3f\n", ber);

	movsd	xmm1, QWORD PTR ber
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_0O@FLHBDPFK@Bad?5BER?5?$CF?43f?6@
	call	printf

; 200  : 				goto usage;

	jmp	$usage$36
$LN18@config:

; 201  : 			}
; 202  : 			break;

	jmp	SHORT $LN4@config
$LN19@config:

; 203  : 
; 204  : 		case 'l':
; 205  : 			strcpy(fname, optarg);

	mov	rdx, QWORD PTR optarg
	lea	rcx, QWORD PTR fname$[rbp]
	call	strcpy

; 206  : 			break;

	jmp	SHORT $LN4@config
$LN20@config:

; 207  : 
; 208  : 		case 't':
; 209  : 			mode_life = atoi(optarg) * 1000; /* ms */

	mov	rcx, QWORD PTR optarg
	call	QWORD PTR __imp_atoi
	imul	eax, eax, 1000				; 000003e8H
	mov	DWORD PTR mode_life, eax

; 210  : 			break;

	jmp	SHORT $LN4@config
$LN21@config:

; 211  : 
; 212  : 		default:
; 213  : 			printf("ERROR: Unsupported option\n");

	lea	rcx, OFFSET FLAT:??_C@_0BL@EAKIOEBM@ERROR?3?5Unsupported?5option?6@
	call	printf

; 214  : 			goto usage;

	jmp	$usage$36
$LN4@config:

; 215  : 		}
; 216  : 	}

	jmp	$LN2@config
$LN3@config:

; 217  : 
; 218  : 	if (optind == argc) 

	mov	eax, DWORD PTR argc$[rbp]
	cmp	DWORD PTR optind, eax
	jne	SHORT $LN22@config

; 219  : 		goto usage;

	jmp	$usage$36
$LN22@config:

; 220  : 
; 221  : 	station = tolower(argv[optind++][0]);

	movsxd	rax, DWORD PTR optind
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [rdx+rax*8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tv149[rbp], al
	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax
	movsx	eax, BYTE PTR tv149[rbp]
	mov	ecx, eax
	call	QWORD PTR __imp_tolower
	mov	DWORD PTR station, eax

; 222  : 	if (station != 'a' && station != 'b')

	cmp	DWORD PTR station, 97			; 00000061H
	je	SHORT $LN23@config
	cmp	DWORD PTR station, 98			; 00000062H
	je	SHORT $LN23@config
$LN8@config:

; 223  : 		ABORT("Station name must be 'A' or 'B'");

	lea	rdx, OFFSET FLAT:??_C@_0CA@IILCIIDD@Station?5name?5must?5be?5?8A?8?5or?5?8B?8@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN8@config
$LN23@config:

; 224  : 
; 225  : 	if (fname[0] == 0) {

	mov	eax, 1
	imul	rax, rax, 0
	movsx	eax, BYTE PTR fname$[rbp+rax]
	test	eax, eax
	jne	$LN24@config

; 226  : 		strcpy(fname, argv[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, QWORD PTR fname$[rbp]
	call	strcpy

; 227  : 		if (stricmp(fname + strlen(fname) - 4, ".exe") == 0)

	lea	rcx, QWORD PTR fname$[rbp]
	call	strlen
	lea	rax, QWORD PTR fname$[rbp+rax-4]
	lea	rdx, OFFSET FLAT:??_C@_04JLMDILM@?4exe@
	mov	rcx, rax
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN25@config

; 228  : 			*(fname + strlen(fname) - 4) = 0;

	lea	rcx, QWORD PTR fname$[rbp]
	call	strlen
	mov	BYTE PTR fname$[rbp+rax-4], 0
$LN25@config:

; 229  : 		strcat(fname, station == 'a' ? "-A.log" : "-B.log");

	cmp	DWORD PTR station, 97			; 00000061H
	jne	SHORT $LN32@config
	lea	rax, OFFSET FLAT:??_C@_06GOMLAJLH@?9A?4log@
	mov	QWORD PTR tv180[rbp], rax
	jmp	SHORT $LN33@config
$LN32@config:
	lea	rax, OFFSET FLAT:??_C@_06OIFPHLBJ@?9B?4log@
	mov	QWORD PTR tv180[rbp], rax
$LN33@config:
	mov	rdx, QWORD PTR tv180[rbp]
	lea	rcx, QWORD PTR fname$[rbp]
	call	strcat
$LN24@config:

; 230  : 	}
; 231  : 
; 232  : 	if (stricmp(fname, "nul") == 0)

	lea	rdx, OFFSET FLAT:??_C@_03JODACOMD@nul@
	lea	rcx, QWORD PTR fname$[rbp]
	call	QWORD PTR __imp__stricmp
	test	eax, eax
	jne	SHORT $LN26@config

; 233  : 		log_file = NULL;

	mov	QWORD PTR log_file, 0
	jmp	SHORT $LN27@config
$LN26@config:

; 234  : 	else if ((log_file = fopen(fname, "w")) == NULL) 

	lea	rdx, OFFSET FLAT:??_C@_01NOFIACDB@w@
	lea	rcx, QWORD PTR fname$[rbp]
	call	QWORD PTR __imp_fopen
	mov	QWORD PTR log_file, rax
	cmp	QWORD PTR log_file, 0
	jne	SHORT $LN28@config

; 235  : 		printf("WARNING: Failed to create log file \"%s\": %s\n", fname, strerror(errno));

	call	QWORD PTR __imp__errno
	mov	ecx, DWORD PTR [rax]
	call	QWORD PTR __imp_strerror
	mov	r8, rax
	lea	rdx, QWORD PTR fname$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CN@PDGAEBAI@WARNING?3?5Failed?5to?5create?5log?5f@
	call	printf
$LN28@config:
$LN27@config:

; 236  : 
; 237  : 	lprintf(

	call	station_name
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0LL@OOBLHPFO@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	call	lprintf

; 238  : 		"=============================================================\n"
; 239  : 		"                    Station %s                               \n"
; 240  : 		"-------------------------------------------------------------\n",
; 241  : 		station_name());
; 242  : 
; 243  : 	lprintf("Protocol.lib, version %s, jiangyanjun0718@bupt.edu.cn\n", VERSION, __DATE__);

	lea	r8, OFFSET FLAT:??_C@_0M@OBEILHJM@May?5?58?52024@
	lea	rdx, OFFSET FLAT:??_C@_03EMGHBCAM@4?40@
	lea	rcx, OFFSET FLAT:??_C@_0DH@PFKHDMOI@Protocol?4lib?0?5version?5?$CFs?0?5jiang@
	call	lprintf

; 244  : 	lprintf("Channel: %d bps, %d ms propagation delay, bit error rate ", CHAN_BPS, CHAN_DELAY);

	mov	r8d, 270				; 0000010eH
	mov	edx, 8000				; 00001f40H
	lea	rcx, OFFSET FLAT:??_C@_0DK@PBDLHNIJ@Channel?3?5?$CFd?5bps?0?5?$CFd?5ms?5propagat@
	call	lprintf

; 245  : 	if (ber > 0.0)

	movsd	xmm0, QWORD PTR ber
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN29@config

; 246  : 		lprintf("%.1E\n", ber);

	movsd	xmm1, QWORD PTR ber
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:??_C@_05KDIEGDNJ@?$CF?41E?6@
	call	lprintf
	jmp	SHORT $LN30@config
$LN29@config:

; 247  : 	else
; 248  : 		lprintf("0\n");

	lea	rcx, OFFSET FLAT:??_C@_02NODKCLPH@0?6@
	call	lprintf
$LN30@config:

; 249  : 	lprintf("Log file \"%s\", TCP port %d, debug mask 0x%02x\n", fname, port, debug_mask);

	movzx	eax, WORD PTR port
	mov	r9d, DWORD PTR debug_mask
	mov	r8d, eax
	lea	rdx, QWORD PTR fname$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CP@GAAMDCJO@Log?5file?5?$CC?$CFs?$CC?0?5TCP?5port?5?$CFd?0?5deb@
	call	lprintf
$LN31@config:

; 250  : }

	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:config$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+1688]
	pop	rdi
	pop	rbp
	ret	0
	npad	2
$LN35@config:
	DD	$LN10@config
	DD	$LN17@config
	DD	$LN15@config
	DD	$LN12@config
	DD	$LN13@config
	DD	$LN19@config
	DD	$LN14@config
	DD	$LN16@config
	DD	$LN20@config
	DD	$LN11@config
	DD	$LN21@config
$LN34@config:
	DB	0
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	10
	DB	1
	DB	10
	DB	2
	DB	10
	DB	3
	DB	10
	DB	10
	DB	4
	DB	10
	DB	10
	DB	5
	DB	10
	DB	6
	DB	10
	DB	7
	DB	10
	DB	10
	DB	10
	DB	8
	DB	9
config	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT magic_check
_TEXT	SEGMENT
i$ = 4
magic_check PROC					; COMDAT

; 907  : {

	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 908  :     int i;
; 909  : 
; 910  :     for (i = 0; i < NMAGIC; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@magic_chec
$LN2@magic_chec:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@magic_chec:
	cmp	DWORD PTR i$[rbp], 32			; 00000020H
	jge	SHORT $LN3@magic_chec

; 911  : 		if (head_magic[i] != HEAD_MAGIC)

	movsxd	rax, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:head_magic
	cmp	DWORD PTR [rcx+rax*4], -1515854821	; a5a5e41bH
	je	SHORT $LN11@magic_chec

; 912  : 			goto exit;

	jmp	SHORT $exit$14
$LN11@magic_chec:

; 913  :     }

	jmp	SHORT $LN2@magic_chec
$LN3@magic_chec:

; 914  : 
; 915  :     for (i = 0; i < NMAGIC; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN7@magic_chec
$LN5@magic_chec:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN7@magic_chec:
	cmp	DWORD PTR i$[rbp], 32			; 00000020H
	jge	SHORT $LN6@magic_chec

; 916  : 		if (foot_magic[i] != FOOT_MAGIC)

	movsxd	rax, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:foot_magic
	cmp	DWORD PTR [rcx+rax*4], -183346598	; f5125a5aH
	je	SHORT $LN12@magic_chec

; 917  : 			goto exit;

	jmp	SHORT $exit$14
$LN12@magic_chec:

; 918  :     }

	jmp	SHORT $LN5@magic_chec
$LN6@magic_chec:

; 919  : 	return;

	jmp	SHORT $LN1@magic_chec
$exit$14:
$LN10@magic_chec:

; 920  : 
; 921  : exit:
; 922  : 	ABORT("Memory used by 'protocol.lib' is corrupted by your program");

	lea	rdx, OFFSET FLAT:??_C@_0DL@CPEPDBM@Memory?5used?5by?5?8protocol?4lib?8?5i@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@magic_chec
$LN1@magic_chec:
$LN13@magic_chec:

; 923  : 
; 924  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
magic_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT magic_init
_TEXT	SEGMENT
i$ = 4
magic_init PROC						; COMDAT

; 898  : {

	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 899  :     int i;
; 900  :     for (i = 0; i < NMAGIC; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@magic_init
$LN2@magic_init:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@magic_init:
	cmp	DWORD PTR i$[rbp], 32			; 00000020H
	jge	SHORT $LN3@magic_init

; 901  :         head_magic[i] = HEAD_MAGIC;

	movsxd	rax, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:head_magic
	mov	DWORD PTR [rcx+rax*4], -1515854821	; a5a5e41bH

; 902  :         foot_magic[i] = FOOT_MAGIC;;

	movsxd	rax, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:foot_magic
	mov	DWORD PTR [rcx+rax*4], -183346598	; f5125a5aH

; 903  :     }

	jmp	SHORT $LN2@magic_init
$LN3@magic_init:

; 904  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
magic_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT dbg_warning
_TEXT	SEGMENT
arg_ptr$ = 8
__$ArrayPad$ = 216
fmt$ = 256
dbg_warning PROC					; COMDAT

; 708  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 10
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 709  : 	va_list arg_ptr;
; 710  : 
; 711  : 	if (debug_mask & DBG_WARNING) {

	mov	eax, DWORD PTR debug_mask
	and	eax, 4
	test	eax, eax
	je	SHORT $LN2@dbg_warnin

; 712  : 		va_start(arg_ptr, fmt);

	lea	rax, QWORD PTR fmt$[rbp+8]
	mov	QWORD PTR arg_ptr$[rbp], rax

; 713  : 		__v_lprintf(fmt, arg_ptr);

	mov	rdx, QWORD PTR arg_ptr$[rbp]
	mov	rcx, QWORD PTR fmt$[rbp]
	call	__v_lprintf

; 714  : 		va_end(arg_ptr);

	mov	QWORD PTR arg_ptr$[rbp], 0
$LN2@dbg_warnin:

; 715  : 	}
; 716  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:dbg_warning$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
dbg_warning ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT dbg_frame
_TEXT	SEGMENT
arg_ptr$ = 8
__$ArrayPad$ = 216
fmt$ = 256
dbg_frame PROC						; COMDAT

; 697  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 10
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 698  : 	va_list arg_ptr;
; 699  : 
; 700  : 	if (debug_mask & DBG_FRAME) {

	mov	eax, DWORD PTR debug_mask
	and	eax, 2
	test	eax, eax
	je	SHORT $LN2@dbg_frame

; 701  : 		va_start(arg_ptr, fmt);

	lea	rax, QWORD PTR fmt$[rbp+8]
	mov	QWORD PTR arg_ptr$[rbp], rax

; 702  : 		__v_lprintf(fmt, arg_ptr);

	mov	rdx, QWORD PTR arg_ptr$[rbp]
	mov	rcx, QWORD PTR fmt$[rbp]
	call	__v_lprintf

; 703  : 		va_end(arg_ptr);

	mov	QWORD PTR arg_ptr$[rbp], 0
$LN2@dbg_frame:

; 704  : 	}
; 705  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:dbg_frame$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
dbg_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT dbg_event
_TEXT	SEGMENT
arg_ptr$ = 8
__$ArrayPad$ = 216
fmt$ = 256
dbg_event PROC						; COMDAT

; 686  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 10
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 687  : 	va_list arg_ptr;
; 688  : 
; 689  : 	if (debug_mask & DBG_FRAME) {

	mov	eax, DWORD PTR debug_mask
	and	eax, 2
	test	eax, eax
	je	SHORT $LN2@dbg_event

; 690  : 		va_start(arg_ptr, fmt);

	lea	rax, QWORD PTR fmt$[rbp+8]
	mov	QWORD PTR arg_ptr$[rbp], rax

; 691  : 		__v_lprintf(fmt, arg_ptr);

	mov	rdx, QWORD PTR arg_ptr$[rbp]
	mov	rcx, QWORD PTR fmt$[rbp]
	call	__v_lprintf

; 692  : 		va_end(arg_ptr);

	mov	QWORD PTR arg_ptr$[rbp], 0
$LN2@dbg_event:

; 693  : 	}
; 694  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:dbg_event$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
dbg_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT station_name
_TEXT	SEGMENT
tv67 = 192
tv66 = 200
station_name PROC					; COMDAT

; 116  : {

$LN7:
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 117  :     return (char *)(station == 'a' ? "A" : station == 'b' ? "B" : "XXX");

	cmp	DWORD PTR station, 97			; 00000061H
	jne	SHORT $LN5@station_na
	lea	rax, OFFSET FLAT:??_C@_01FHEEJDEE@A@
	mov	QWORD PTR tv67[rbp], rax
	jmp	SHORT $LN6@station_na
$LN5@station_na:
	cmp	DWORD PTR station, 98			; 00000062H
	jne	SHORT $LN3@station_na
	lea	rax, OFFSET FLAT:??_C@_01HMGJMAIH@B@
	mov	QWORD PTR tv66[rbp], rax
	jmp	SHORT $LN4@station_na
$LN3@station_na:
	lea	rax, OFFSET FLAT:??_C@_03MAMPKPPK@XXX@
	mov	QWORD PTR tv66[rbp], rax
$LN4@station_na:
	mov	rax, QWORD PTR tv66[rbp]
	mov	QWORD PTR tv67[rbp], rax
$LN6@station_na:
	mov	rax, QWORD PTR tv67[rbp]

; 118  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
station_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT stop_ack_timer
_TEXT	SEGMENT
stop_ack_timer PROC					; COMDAT

; 560  : {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 561  :     timer[ACK_TIMER_ID] = 0;

	mov	eax, 4
	imul	rax, rax, 128				; 00000080H
	lea	rcx, OFFSET FLAT:timer
	mov	DWORD PTR [rcx+rax], 0

; 562  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
stop_ack_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT start_ack_timer
_TEXT	SEGMENT
ms$ = 224
start_ack_timer PROC					; COMDAT

; 554  : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 555  :     if (timer[ACK_TIMER_ID] == 0)

	mov	eax, 4
	imul	rax, rax, 128				; 00000080H
	lea	rcx, OFFSET FLAT:timer
	cmp	DWORD PTR [rcx+rax], 0
	jne	SHORT $LN2@start_ack_

; 556  :         timer[ACK_TIMER_ID] = now + ms;

	mov	eax, DWORD PTR ms$[rbp]
	mov	ecx, DWORD PTR now
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, 4
	imul	rcx, rcx, 128				; 00000080H
	lea	rdx, OFFSET FLAT:timer
	mov	DWORD PTR [rdx+rcx], eax
$LN2@start_ack_:

; 557  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
start_ack_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT stop_timer
_TEXT	SEGMENT
nr$ = 224
stop_timer PROC						; COMDAT

; 541  : {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 542  :     if (nr < ACK_TIMER_ID) 

	cmp	DWORD PTR nr$[rbp], 128			; 00000080H
	jae	SHORT $LN2@stop_timer

; 543  :         timer[nr] = 0;

	mov	eax, DWORD PTR nr$[rbp]
	lea	rcx, OFFSET FLAT:timer
	mov	DWORD PTR [rcx+rax*4], 0
$LN2@stop_timer:

; 544  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
stop_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT start_timer
_TEXT	SEGMENT
nr$ = 224
ms$ = 232
start_timer PROC					; COMDAT

; 534  : {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 535  :     if (nr >= ACK_TIMER_ID) 

	cmp	DWORD PTR nr$[rbp], 128			; 00000080H
	jb	SHORT $LN5@start_time
$LN4@start_time:

; 536  :         ABORT("start_timer(): timer No. must be 0~128");

	lea	rdx, OFFSET FLAT:??_C@_0CH@CAFPDCFE@start_timer?$CI?$CJ?3?5timer?5No?4?5must?5b@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@start_time
$LN5@start_time:

; 537  :     timer[nr] = now + phl_sq_len() * 8000 / CHAN_BPS + ms;

	call	phl_sq_len
	imul	eax, eax, 8000				; 00001f40H
	cdq
	mov	ecx, 8000				; 00001f40H
	idiv	ecx
	mov	ecx, DWORD PTR now
	add	ecx, eax
	mov	eax, ecx
	add	eax, DWORD PTR ms$[rbp]
	mov	ecx, DWORD PTR nr$[rbp]
	lea	rdx, OFFSET FLAT:timer
	mov	DWORD PTR [rdx+rcx*4], eax
$LN6@start_time:

; 538  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
start_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT phl_sq_len
_TEXT	SEGMENT
phl_sq_len PROC						; COMDAT

; 370  : {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 371  :     return sq_len();

	call	sq_len

; 372  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
phl_sq_len ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT send_frame
_TEXT	SEGMENT
i$ = 4
frame$ = 256
len$ = 264
send_frame PROC						; COMDAT

; 392  : {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 393  :     int i;
; 394  : 
; 395  :     send_byte(0xff);

	mov	cl, 255					; 000000ffH
	call	send_byte

; 396  :     
; 397  :     for (i = 0; i < len; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@send_frame
$LN2@send_frame:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@send_frame:
	mov	eax, DWORD PTR len$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jge	SHORT $LN3@send_frame

; 398  :         send_byte(frame[i] & 0x0f);

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR frame$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 15
	movzx	ecx, al
	call	send_byte

; 399  :         send_byte((frame[i] & 0xf0) >> 4);

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR frame$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 240				; 000000f0H
	sar	eax, 4
	movzx	ecx, al
	call	send_byte

; 400  :     }

	jmp	SHORT $LN2@send_frame
$LN3@send_frame:

; 401  :     send_byte(0xff);

	mov	cl, 255					; 000000ffH
	call	send_byte

; 402  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
send_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT recv_frame
_TEXT	SEGMENT
len$ = 4
next$ = 40
msg$ = 80
__$ArrayPad$ = 536
buf$ = 576
size$ = 584
recv_frame PROC						; COMDAT

; 735  : {

$LN12:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 584				; 00000248H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+616]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 736  :     int len;
; 737  :     struct RCV_FRAME *next;
; 738  :     char msg[256];
; 739  : 
; 740  :     if (rf_head == NULL) 

	cmp	QWORD PTR rf_head, 0
	jne	SHORT $LN8@recv_frame
$LN4@recv_frame:

; 741  :         ABORT("recv_frame(): Receiving Queue is empty");

	lea	rdx, OFFSET FLAT:??_C@_0CH@CPPJMHNF@recv_frame?$CI?$CJ?3?5Receiving?5Queue?5i@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@recv_frame
$LN8@recv_frame:

; 742  : 
; 743  :     len = rf_head->len;

	mov	rax, QWORD PTR rf_head
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR len$[rbp], eax

; 744  : 
; 745  :     if (size < len) { 

	mov	eax, DWORD PTR len$[rbp]
	cmp	DWORD PTR size$[rbp], eax
	jge	SHORT $LN9@recv_frame

; 746  :         sprintf(msg, "recv_frame(): %d-byte buffer is too small to save %d-byte received frame", size, len);

	mov	r9d, DWORD PTR len$[rbp]
	mov	r8d, DWORD PTR size$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_0EJ@CHMOPKBB@recv_frame?$CI?$CJ?3?5?$CFd?9byte?5buffer?5is@
	lea	rcx, QWORD PTR msg$[rbp]
	call	sprintf
$LN7@recv_frame:

; 747  :         ABORT(msg);

	lea	rdx, QWORD PTR msg$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@recv_frame
$LN9@recv_frame:

; 748  :     }
; 749  :     
; 750  :     memcpy(buf, rf_head->frame, len);

	movsxd	rax, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR rf_head
	add	rcx, 8
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR buf$[rbp]
	call	memcpy

; 751  : 
; 752  :     next = rf_head->link;

	mov	rax, QWORD PTR rf_head
	mov	rax, QWORD PTR [rax+2056]
	mov	QWORD PTR next$[rbp], rax

; 753  :     if (next == NULL) 

	cmp	QWORD PTR next$[rbp], 0
	jne	SHORT $LN10@recv_frame

; 754  :         rf_tail = NULL;

	mov	QWORD PTR rf_tail, 0
$LN10@recv_frame:

; 755  :     free(rf_head); 

	mov	rcx, QWORD PTR rf_head
	call	QWORD PTR __imp_free

; 756  :     rf_head = next;

	mov	rax, QWORD PTR next$[rbp]
	mov	QWORD PTR rf_head, rax

; 757  : 
; 758  :     return len;

	mov	eax, DWORD PTR len$[rbp]
$LN11@recv_frame:

; 759  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:recv_frame$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+552]
	pop	rdi
	pop	rbp
	ret	0
recv_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT put_packet
_TEXT	SEGMENT
i$ = 4
my_rand$ = 40
bps$1 = 72
tv76 = 276
tv65 = 280
packet$ = 320
len$ = 328
put_packet PROC						; COMDAT

; 658  : {

$LN17:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 344				; 00000158H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 659  :     static int last_ts = 0;
; 660  :     int i, (*my_rand)(void) = station == 'a' ? randB : randA;

	cmp	DWORD PTR station, 97			; 00000061H
	jne	SHORT $LN15@put_packet
	lea	rax, OFFSET FLAT:randB
	mov	QWORD PTR tv65[rbp], rax
	jmp	SHORT $LN16@put_packet
$LN15@put_packet:
	lea	rax, OFFSET FLAT:randA
	mov	QWORD PTR tv65[rbp], rax
$LN16@put_packet:
	mov	rax, QWORD PTR tv65[rbp]
	mov	QWORD PTR my_rand$[rbp], rax

; 661  : 
; 662  :     if (len != PKT_LEN) 

	cmp	DWORD PTR len$[rbp], 256		; 00000100H
	je	SHORT $LN11@put_packet
$LN4@put_packet:

; 663  :         ABORT("Bad Packet length");

	lea	rdx, OFFSET FLAT:??_C@_0BC@GHOLIPDG@Bad?5Packet?5length@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@put_packet
$LN11@put_packet:

; 664  : 
; 665  :     for (i = 2; i < PKT_LEN; i++) {

	mov	DWORD PTR i$[rbp], 2
	jmp	SHORT $LN7@put_packet
$LN5@put_packet:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN7@put_packet:
	cmp	DWORD PTR i$[rbp], 256			; 00000100H
	jge	SHORT $LN6@put_packet

; 666  :         if (packet[i] != next_char()) 

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR packet$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv76[rbp], eax
	call	QWORD PTR my_rand$[rbp]
	and	eax, 255				; 000000ffH
	movzx	eax, al
	mov	ecx, DWORD PTR tv76[rbp]
	cmp	ecx, eax
	je	SHORT $LN12@put_packet
$LN10@put_packet:

; 667  :             ABORT("Network Layer received a bad packet from data link layer");

	lea	rdx, OFFSET FLAT:??_C@_0DJ@HBLDLIOC@Network?5Layer?5received?5a?5bad?5pa@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@put_packet
$LN12@put_packet:

; 668  :     }

	jmp	SHORT $LN5@put_packet
$LN6@put_packet:

; 669  :     rpackets++;

	mov	eax, DWORD PTR rpackets
	inc	eax
	mov	DWORD PTR rpackets, eax

; 670  :     rbytes += len;

	mov	eax, DWORD PTR len$[rbp]
	mov	ecx, DWORD PTR rbytes
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR rbytes, eax

; 671  : 
; 672  :     if (now - last_ts > 2000 && now > ts0 + 2000) {

	mov	eax, DWORD PTR ?last_ts@?1??put_packet@@9@9
	mov	ecx, DWORD PTR now
	sub	ecx, eax
	mov	eax, ecx
	cmp	eax, 2000				; 000007d0H
	jle	$LN13@put_packet
	mov	eax, DWORD PTR ts0
	add	eax, 2000				; 000007d0H
	cmp	DWORD PTR now, eax
	jle	$LN13@put_packet

; 673  :         double bps;
; 674  :         bps = (double)rbytes * 8 * 1000 / (now - ts0);

	cvtsi2sd xmm0, DWORD PTR rbytes
	mulsd	xmm0, QWORD PTR __real@4020000000000000
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	mov	eax, DWORD PTR ts0
	mov	ecx, DWORD PTR now
	sub	ecx, eax
	mov	eax, ecx
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	movsd	QWORD PTR bps$1[rbp], xmm0

; 675  :         lprintf(".... %d packets received, %.0f bps, %.2f%%, Err %d (%.1e)\n", 

	cvtsi2sd xmm0, DWORD PTR noise
	mov	eax, DWORD PTR nbits
	cvtsi2sd xmm1, rax
	divsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR bps$1[rbp]
	divsd	xmm1, QWORD PTR __real@40bf400000000000
	mulsd	xmm1, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR [rsp+40], xmm0
	mov	eax, DWORD PTR noise
	mov	DWORD PTR [rsp+32], eax
	movaps	xmm3, xmm1
	movq	r9, xmm3
	movsd	xmm2, QWORD PTR bps$1[rbp]
	movq	r8, xmm2
	mov	edx, DWORD PTR rpackets
	lea	rcx, OFFSET FLAT:??_C@_0DL@HCJDDPB@?4?4?4?4?5?$CFd?5packets?5received?0?5?$CF?40f?5@
	call	lprintf

; 676  :             rpackets, bps, bps / CHAN_BPS * 100, noise, (double)noise/nbits);
; 677  :         last_ts = now;

	mov	eax, DWORD PTR now
	mov	DWORD PTR ?last_ts@?1??put_packet@@9@9, eax
$LN13@put_packet:
$LN14@put_packet:

; 678  :     }
; 679  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
put_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT get_packet
_TEXT	SEGMENT
i$ = 4
len$ = 36
my_rand$ = 72
tv81 = 276
tv65 = 280
packet$ = 320
get_packet PROC						; COMDAT

; 637  : {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 638  :     static int pkt_no = 0;
; 639  :     int i, len;
; 640  :     int (*my_rand)(void) = station == 'a' ? randA : randB;

	cmp	DWORD PTR station, 97			; 00000061H
	jne	SHORT $LN10@get_packet
	lea	rax, OFFSET FLAT:randA
	mov	QWORD PTR tv65[rbp], rax
	jmp	SHORT $LN11@get_packet
$LN10@get_packet:
	lea	rax, OFFSET FLAT:randB
	mov	QWORD PTR tv65[rbp], rax
$LN11@get_packet:
	mov	rax, QWORD PTR tv65[rbp]
	mov	QWORD PTR my_rand$[rbp], rax

; 641  : 
; 642  :     if (!layer3_ready)

	cmp	DWORD PTR layer3_ready, 0
	jne	SHORT $LN8@get_packet
$LN4@get_packet:

; 643  :         ABORT("get_packet(): Network layer is not ready for a new packet");

	lea	rdx, OFFSET FLAT:??_C@_0DK@KEEFNOJP@get_packet?$CI?$CJ?3?5Network?5layer?5is?5@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@get_packet
$LN8@get_packet:

; 644  :     
; 645  :     len = PKT_LEN;

	mov	DWORD PTR len$[rbp], 256		; 00000100H

; 646  :     for (i = 2; i < len; i++)

	mov	DWORD PTR i$[rbp], 2
	jmp	SHORT $LN7@get_packet
$LN5@get_packet:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN7@get_packet:
	mov	eax, DWORD PTR len$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jge	SHORT $LN6@get_packet

; 647  :         packet[i] = next_char();

	call	QWORD PTR my_rand$[rbp]
	and	eax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR packet$[rbp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN5@get_packet
$LN6@get_packet:

; 648  :     *(unsigned short *)packet = (station - 'a' + 1) * 10000 + (pkt_no++ % 10000);

	mov	eax, DWORD PTR station
	sub	eax, 96					; 00000060H
	imul	eax, eax, 10000				; 00002710H
	mov	DWORD PTR tv81[rbp], eax
	mov	eax, DWORD PTR ?pkt_no@?1??get_packet@@9@9
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	mov	eax, edx
	mov	ecx, DWORD PTR tv81[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR packet$[rbp]
	mov	WORD PTR [rcx], ax
	mov	eax, DWORD PTR ?pkt_no@?1??get_packet@@9@9
	inc	eax
	mov	DWORD PTR ?pkt_no@?1??get_packet@@9@9, eax

; 649  : 
; 650  :     layer3_ready = 0;

	mov	DWORD PTR layer3_ready, 0

; 651  : 
; 652  :     return len;

	mov	eax, DWORD PTR len$[rbp]
$LN9@get_packet:

; 653  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
get_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT disable_network_layer
_TEXT	SEGMENT
disable_network_layer PROC				; COMDAT

; 589  : {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 590  :     network_layer_active = 0;

	mov	DWORD PTR network_layer_active, 0

; 591  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
disable_network_layer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT enable_network_layer
_TEXT	SEGMENT
enable_network_layer PROC				; COMDAT

; 584  : {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 585  :     network_layer_active = 1;

	mov	DWORD PTR network_layer_active, 1

; 586  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
enable_network_layer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT wait_for_event
_TEXT	SEGMENT
rfd$ = 16
wfd$ = 576
tm$ = 1128
event$ = 1156
n$ = 1188
i$ = 1220
nfds$ = 1252
ch$ = 1284
ms0$6 = 1316
t$7 = 1348
ticks$8 = 1380
ms$9 = 1412
__$ArrayPad$ = 2008
arg$ = 2048
wait_for_event PROC					; COMDAT

; 762  : {

$LN49:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 2072				; 00000818H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rdi, QWORD PTR [rsp+48]
	mov	ecx, 362				; 0000016aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+2104]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode
$LN2@wait_for_e:

; 763  :     fd_set rfd, wfd;
; 764  :     struct timeval tm;
; 765  :     int event, n, i, nfds;
; 766  :     unsigned char ch;
; 767  : 
; 768  :     for (;;) {
; 769  : 
; 770  :         now = get_ms();

	call	get_ms
	mov	DWORD PTR now, eax

; 771  :      
; 772  :         /* commit received socket data */
; 773  :         if (rblk_head && rblk_head->commit_ts <= now) {

	cmp	QWORD PTR rblk_head, 0
	je	$LN17@wait_for_e
	mov	rax, QWORD PTR rblk_head
	mov	ecx, DWORD PTR now
	cmp	DWORD PTR [rax], ecx
	jg	$LN17@wait_for_e

; 774  :             n = rblk_head->wptr - rblk_head->rptr;

	mov	rax, QWORD PTR rblk_head
	mov	rcx, QWORD PTR rblk_head
	mov	ecx, DWORD PTR [rcx+4]
	mov	eax, DWORD PTR [rax+8]
	sub	eax, ecx
	mov	DWORD PTR n$[rbp], eax

; 775  :             
; 776  :             if (ts0 == 0) {

	cmp	DWORD PTR ts0, 0
	jne	SHORT $LN18@wait_for_e

; 777  :                 ts0 = now;

	mov	eax, DWORD PTR now
	mov	DWORD PTR ts0, eax

; 778  :                 if (ts0 >= n / 2)

	mov	eax, DWORD PTR n$[rbp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR ts0, eax
	jl	SHORT $LN19@wait_for_e

; 779  :                     ts0 -= n / 2;

	mov	eax, DWORD PTR n$[rbp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR ts0
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ts0, eax
$LN19@wait_for_e:
$LN18@wait_for_e:

; 780  :             }
; 781  : 
; 782  :             for (i = 0; i < n; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN7@wait_for_e
$LN5@wait_for_e:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN7@wait_for_e:
	mov	eax, DWORD PTR n$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jge	$LN6@wait_for_e

; 783  :                 ch = recv_byte();

	call	recv_byte
	mov	BYTE PTR ch$[rbp], al

; 784  :                 if (ch == 0xff) {

	movzx	eax, BYTE PTR ch$[rbp]
	cmp	eax, 255				; 000000ffH
	jne	$LN20@wait_for_e

; 785  :                     if (rf_buf == NULL) 

	cmp	QWORD PTR rf_buf, 0
	jne	SHORT $LN22@wait_for_e

; 786  :                         rf_buf = (struct RCV_FRAME *)calloc(1, sizeof(struct RCV_FRAME));

	mov	edx, 2064				; 00000810H
	mov	ecx, 1
	call	QWORD PTR __imp_calloc
	mov	QWORD PTR rf_buf, rax
	jmp	SHORT $LN23@wait_for_e
$LN22@wait_for_e:

; 787  :                     else {
; 788  :                         if (rf_buf->len > 0) {

	mov	rax, QWORD PTR rf_buf
	cmp	DWORD PTR [rax], 0
	jle	SHORT $LN24@wait_for_e

; 789  :                             if (rf_head == NULL) 

	cmp	QWORD PTR rf_head, 0
	jne	SHORT $LN25@wait_for_e

; 790  :                                 rf_head = rf_tail = rf_buf;

	mov	rax, QWORD PTR rf_buf
	mov	QWORD PTR rf_tail, rax
	mov	rax, QWORD PTR rf_tail
	mov	QWORD PTR rf_head, rax
	jmp	SHORT $LN26@wait_for_e
$LN25@wait_for_e:

; 791  :                             else {
; 792  :                                 rf_tail->link = rf_buf;

	mov	rax, QWORD PTR rf_tail
	mov	rcx, QWORD PTR rf_buf
	mov	QWORD PTR [rax+2056], rcx

; 793  :                                 rf_tail = rf_buf;

	mov	rax, QWORD PTR rf_buf
	mov	QWORD PTR rf_tail, rax
$LN26@wait_for_e:

; 794  :                             }
; 795  :                             rf_buf = NULL;

	mov	QWORD PTR rf_buf, 0
$LN24@wait_for_e:
$LN23@wait_for_e:

; 796  :                         }
; 797  :                     }

	jmp	$LN21@wait_for_e
$LN20@wait_for_e:

; 798  :                 } else if (rf_buf && rf_buf->len < sizeof(rf_buf->frame)) {

	cmp	QWORD PTR rf_buf, 0
	je	$LN27@wait_for_e
	mov	rax, QWORD PTR rf_buf
	movsxd	rax, DWORD PTR [rax]
	cmp	rax, 2048				; 00000800H
	jae	$LN27@wait_for_e

; 799  :                     if (rf_buf->state == 0) {

	mov	rax, QWORD PTR rf_buf
	cmp	DWORD PTR [rax+4], 0
	jne	SHORT $LN28@wait_for_e

; 800  :                         rf_buf->frame[rf_buf->len] = ch;

	mov	rax, QWORD PTR rf_buf
	movsxd	rax, DWORD PTR [rax]
	mov	rcx, QWORD PTR rf_buf
	movzx	edx, BYTE PTR ch$[rbp]
	mov	BYTE PTR [rcx+rax+8], dl

; 801  :                         rf_buf->state = 1;

	mov	rax, QWORD PTR rf_buf
	mov	DWORD PTR [rax+4], 1

; 802  :                     } else {

	jmp	SHORT $LN29@wait_for_e
$LN28@wait_for_e:

; 803  :                         rf_buf->frame[rf_buf->len] |= (ch << 4) ^ (ch & 0xf0);

	mov	rax, QWORD PTR rf_buf
	movsxd	rax, DWORD PTR [rax]
	movzx	ecx, BYTE PTR ch$[rbp]
	shl	ecx, 4
	movzx	edx, BYTE PTR ch$[rbp]
	and	edx, 240				; 000000f0H
	xor	ecx, edx
	mov	rdx, QWORD PTR rf_buf
	movzx	eax, BYTE PTR [rdx+rax+8]
	or	eax, ecx
	mov	rcx, QWORD PTR rf_buf
	movsxd	rcx, DWORD PTR [rcx]
	mov	rdx, QWORD PTR rf_buf
	mov	BYTE PTR [rdx+rcx+8], al

; 804  :                         rf_buf->len++;

	mov	rax, QWORD PTR rf_buf
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR rf_buf
	mov	DWORD PTR [rcx], eax

; 805  :                         rf_buf->state = 0;

	mov	rax, QWORD PTR rf_buf
	mov	DWORD PTR [rax+4], 0
$LN29@wait_for_e:
$LN27@wait_for_e:
$LN21@wait_for_e:

; 806  :                     }
; 807  :                 }
; 808  :             }

	jmp	$LN5@wait_for_e
$LN6@wait_for_e:

; 809  : 
; 810  :             if (rf_head)

	cmp	QWORD PTR rf_head, 0
	je	SHORT $LN30@wait_for_e

; 811  :                 return FRAME_RECEIVED;

	mov	eax, 2
	jmp	$LN1@wait_for_e
$LN30@wait_for_e:
$LN17@wait_for_e:

; 812  :         }
; 813  :         
; 814  :         /* test socket send/receive */
; 815  :         tm.tv_sec = tm.tv_usec = 0;

	mov	DWORD PTR tm$[rbp+4], 0
	mov	eax, DWORD PTR tm$[rbp+4]
	mov	DWORD PTR tm$[rbp], eax

; 816  :         FD_ZERO(&rfd);

	mov	DWORD PTR rfd$[rbp], 0

; 817  :         FD_ZERO(&wfd);

	mov	DWORD PTR wfd$[rbp], 0
$LN10@wait_for_e:

; 818  :         FD_SET(sock, &rfd);

	cmp	DWORD PTR rfd$[rbp], 64			; 00000040H
	jae	SHORT $LN31@wait_for_e
	mov	eax, DWORD PTR rfd$[rbp]
	mov	rcx, QWORD PTR sock
	mov	QWORD PTR rfd$[rbp+rax*8+8], rcx
	mov	eax, DWORD PTR rfd$[rbp]
	inc	eax
	mov	DWORD PTR rfd$[rbp], eax
$LN31@wait_for_e:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@wait_for_e
$LN13@wait_for_e:

; 819  :         FD_SET(sock, &wfd);

	cmp	DWORD PTR wfd$[rbp], 64			; 00000040H
	jae	SHORT $LN32@wait_for_e
	mov	eax, DWORD PTR wfd$[rbp]
	mov	rcx, QWORD PTR sock
	mov	QWORD PTR wfd$[rbp+rax*8+8], rcx
	mov	eax, DWORD PTR wfd$[rbp]
	inc	eax
	mov	DWORD PTR wfd$[rbp], eax
$LN32@wait_for_e:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN13@wait_for_e

; 820  : 
; 821  :         nfds = (int)(sock + 1);

	mov	rax, QWORD PTR sock
	inc	rax
	mov	DWORD PTR nfds$[rbp], eax

; 822  :         if (select(nfds, &rfd, &wfd, 0, &tm) < 0) 

	lea	rax, QWORD PTR tm$[rbp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	lea	r8, QWORD PTR wfd$[rbp]
	lea	rdx, QWORD PTR rfd$[rbp]
	mov	ecx, DWORD PTR nfds$[rbp]
	call	select
	test	eax, eax
	jge	SHORT $LN33@wait_for_e
$LN16@wait_for_e:

; 823  :             ABORT("system select()");

	lea	rdx, OFFSET FLAT:??_C@_0BA@BALGGGKL@system?5select?$CI?$CJ@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN16@wait_for_e
$LN33@wait_for_e:

; 824  :          
; 825  :         /* socket send */
; 826  :         if (FD_ISSET(sock, &wfd)) 

	lea	rdx, QWORD PTR wfd$[rbp]
	mov	rcx, QWORD PTR sock
	call	__WSAFDIsSet
	test	eax, eax
	je	SHORT $LN34@wait_for_e

; 827  :             socket_send();

	call	socket_send
$LN34@wait_for_e:

; 828  : 
; 829  :         /* socket receive */
; 830  :         if (FD_ISSET(sock, &rfd)) 

	lea	rdx, QWORD PTR rfd$[rbp]
	mov	rcx, QWORD PTR sock
	call	__WSAFDIsSet
	test	eax, eax
	je	SHORT $LN35@wait_for_e

; 831  :             socket_recv();

	call	socket_recv
$LN35@wait_for_e:

; 832  : 
; 833  :         /* network layer event */
; 834  :         if (network_layer_ready()) {

	call	network_layer_ready
	test	eax, eax
	je	SHORT $LN36@wait_for_e

; 835  :             layer3_ready = 1;

	mov	DWORD PTR layer3_ready, 1

; 836  :             return NETWORK_LAYER_READY;

	xor	eax, eax
	jmp	$LN1@wait_for_e
$LN36@wait_for_e:

; 837  :         }
; 838  : 
; 839  :         /* check all timers */
; 840  :         if ((event = scan_timer(arg)) != 0)

	mov	rcx, QWORD PTR arg$[rbp]
	call	scan_timer
	mov	DWORD PTR event$[rbp], eax
	cmp	DWORD PTR event$[rbp], 0
	je	SHORT $LN37@wait_for_e

; 841  :             return event;

	mov	eax, DWORD PTR event$[rbp]
	jmp	$LN1@wait_for_e
$LN37@wait_for_e:

; 842  : 
; 843  :         /* physical layer event */
; 844  :         if (inform_phl_ready && phl_sq_len()  < PHL_SQ_LEVEL) {

	cmp	DWORD PTR inform_phl_ready, 0
	je	SHORT $LN38@wait_for_e
	call	phl_sq_len
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN38@wait_for_e

; 845  :             inform_phl_ready = 0;

	mov	DWORD PTR inform_phl_ready, 0

; 846  :             return PHYSICAL_LAYER_READY;

	mov	eax, 1
	jmp	$LN1@wait_for_e
$LN38@wait_for_e:

; 847  :         }
; 848  : 
; 849  :         /* delay 'mode_tick' ms */
; 850  :         if (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN39@wait_for_e

; 851  :             int ms0, t;
; 852  :             static time_t last_warn;
; 853  :             ms0 = get_ms();

	call	get_ms
	mov	DWORD PTR ms0$6[rbp], eax

; 854  :             magic_check();

	call	magic_check

; 855  :             Sleep(mode_tick);

	mov	ecx, DWORD PTR mode_tick
	call	QWORD PTR __imp_Sleep

; 856  :             t = get_ms() - ms0;

	call	get_ms
	sub	eax, DWORD PTR ms0$6[rbp]
	mov	DWORD PTR t$7[rbp], eax

; 857  :             if (t > mode_tick + 50 && time(0) > last_warn + 1) {

	mov	eax, DWORD PTR mode_tick
	add	eax, 50					; 00000032H
	cmp	DWORD PTR t$7[rbp], eax
	jle	SHORT $LN41@wait_for_e
	xor	ecx, ecx
	call	time
	mov	rcx, QWORD PTR ?last_warn@?BF@??wait_for_event@@9@9
	inc	rcx
	cmp	rax, rcx
	jle	SHORT $LN41@wait_for_e

; 858  :                 lprintf("** WARNING: System too busy, sleep %d ms, but be awakened %d ms later\n", 

	mov	r8d, DWORD PTR t$7[rbp]
	mov	edx, DWORD PTR mode_tick
	lea	rcx, OFFSET FLAT:??_C@_0EH@DPLMEMFI@?$CK?$CK?5WARNING?3?5System?5too?5busy?0?5sl@
	call	lprintf

; 859  :                     mode_tick, t);
; 860  :                 last_warn = time(0);

	xor	ecx, ecx
	call	time
	mov	QWORD PTR ?last_warn@?BF@??wait_for_event@@9@9, rax
$LN41@wait_for_e:

; 861  :             }
; 862  :         } else {

	jmp	$LN40@wait_for_e
$LN39@wait_for_e:

; 863  :             int ticks, ms;
; 864  : 
; 865  :             sleep_cnt++;

	mov	eax, DWORD PTR sleep_cnt
	inc	eax
	mov	DWORD PTR sleep_cnt, eax

; 866  : 
; 867  :             ms = get_ms();

	call	get_ms
	mov	DWORD PTR ms$9[rbp], eax

; 868  :             if (start_ms == 0)

	cmp	DWORD PTR start_ms, 0
	jne	SHORT $LN42@wait_for_e

; 869  :                 start_ms = ms;

	mov	eax, DWORD PTR ms$9[rbp]
	mov	DWORD PTR start_ms, eax
	jmp	$LN43@wait_for_e
$LN42@wait_for_e:

; 870  :             else if (ms - wakeup_ms > 1) {

	mov	eax, DWORD PTR wakeup_ms
	mov	ecx, DWORD PTR ms$9[rbp]
	sub	ecx, eax
	mov	eax, ecx
	cmp	eax, 1
	jle	SHORT $LN44@wait_for_e

; 871  :                 ticks = (ms - start_ms) / mode_tick;

	mov	eax, DWORD PTR start_ms
	mov	ecx, DWORD PTR ms$9[rbp]
	sub	ecx, eax
	mov	eax, ecx
	cdq
	idiv	DWORD PTR mode_tick
	mov	DWORD PTR ticks$8[rbp], eax

; 872  :                 lprintf("====== CPU BUSY for %d ms (cnt %d)\n", ms - wakeup_ms, ++busy_cnt);

	mov	eax, DWORD PTR busy_cnt
	inc	eax
	mov	DWORD PTR busy_cnt, eax
	mov	eax, DWORD PTR wakeup_ms
	mov	ecx, DWORD PTR ms$9[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	r8d, DWORD PTR busy_cnt
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0CE@JJJPNBIE@?$DN?$DN?$DN?$DN?$DN?$DN?5CPU?5BUSY?5for?5?$CFd?5ms?5?$CIcnt?5@
	call	lprintf

; 873  :                 lprintf("------ noSleep %d, sleep %d, Elapse %d ticks\n", ticks - sleep_cnt, sleep_cnt, ticks);

	mov	eax, DWORD PTR sleep_cnt
	mov	ecx, DWORD PTR ticks$8[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	r9d, DWORD PTR ticks$8[rbp]
	mov	r8d, DWORD PTR sleep_cnt
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0CO@HPAFFNIF@?9?9?9?9?9?9?5noSleep?5?$CFd?0?5sleep?5?$CFd?0?5El@
	call	lprintf
$LN44@wait_for_e:
$LN43@wait_for_e:

; 874  :             }
; 875  : 
; 876  :             magic_check();

	call	magic_check

; 877  :             ms = get_ms();

	call	get_ms
	mov	DWORD PTR ms$9[rbp], eax

; 878  :             Sleep(mode_tick);

	mov	ecx, DWORD PTR mode_tick
	call	QWORD PTR __imp_Sleep

; 879  :             wakeup_ms = get_ms();

	call	get_ms
	mov	DWORD PTR wakeup_ms, eax

; 880  : 
; 881  :             ms = wakeup_ms - ms;

	mov	eax, DWORD PTR ms$9[rbp]
	mov	ecx, DWORD PTR wakeup_ms
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ms$9[rbp], eax

; 882  :             if (ms > mode_tick + 1 || ms < mode_tick - 1) 

	mov	eax, DWORD PTR mode_tick
	inc	eax
	cmp	DWORD PTR ms$9[rbp], eax
	jg	SHORT $LN46@wait_for_e
	mov	eax, DWORD PTR mode_tick
	dec	eax
	cmp	DWORD PTR ms$9[rbp], eax
	jge	SHORT $LN45@wait_for_e
$LN46@wait_for_e:

; 883  :                 lprintf("++++++ Sleep(%d)=%d+%d (cnt %d)\n", mode_tick, mode_tick, ms - mode_tick, ++bias_cnt);

	mov	eax, DWORD PTR bias_cnt
	inc	eax
	mov	DWORD PTR bias_cnt, eax
	mov	eax, DWORD PTR mode_tick
	mov	ecx, DWORD PTR ms$9[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR bias_cnt
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR mode_tick
	mov	edx, DWORD PTR mode_tick
	lea	rcx, OFFSET FLAT:??_C@_0CB@FDBFIEAB@?$CL?$CL?$CL?$CL?$CL?$CL?5Sleep?$CI?$CFd?$CJ?$DN?$CFd?$CL?$CFd?5?$CIcnt?5?$CFd?$CJ@
	call	lprintf
$LN45@wait_for_e:
$LN40@wait_for_e:

; 884  :         }
; 885  : 
; 886  :         if (now > mode_life) {

	mov	eax, DWORD PTR mode_life
	cmp	DWORD PTR now, eax
	jle	SHORT $LN47@wait_for_e

; 887  :             lprintf("Quit.\n");

	lea	rcx, OFFSET FLAT:??_C@_06EJNPPGH@Quit?4?6@
	call	lprintf

; 888  :             exit(0);

	xor	ecx, ecx
	call	QWORD PTR __imp_exit
$LN47@wait_for_e:

; 889  :         }
; 890  :     }

	jmp	$LN2@wait_for_e
$LN1@wait_for_e:
$LN48@wait_for_e:

; 891  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:wait_for_event$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+2024]
	pop	rdi
	pop	rbp
	ret	0
wait_for_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT protocol_init
_TEXT	SEGMENT
admin_sock$ = 8
i$ = 36
name$ = 72
newtime$7 = 120
timeout_ms$8 = 148
buf_size$9 = 180
on$10 = 212
__$ArrayPad$ = 424
argc$ = 464
argv$ = 472
protocol_init PROC					; COMDAT

; 255  : {

$LN30:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 488				; 000001e8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rdi, QWORD PTR [rsp+48]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+520]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 256  : 	SOCKET admin_sock;
; 257  : 	int i;
; 258  :     struct sockaddr_in name;
; 259  : 
; 260  : 	socket_init();

	call	socket_init

; 261  : 	magic_init();

	call	magic_init

; 262  : 
; 263  : 	config(argc, argv);

	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	config

; 264  :   
; 265  :     if (station == 'a') {

	cmp	DWORD PTR station, 97			; 00000061H
	jne	$LN20@protocol_i

; 266  : 
; 267  :         srand(mode_seed ^ 97209);

	mov	eax, DWORD PTR mode_seed
	xor	eax, 97209				; 00017bb9H
	mov	ecx, eax
	call	QWORD PTR __imp_srand

; 268  : 
; 269  :         name.sin_family = AF_INET;

	mov	eax, 2
	mov	WORD PTR name$[rbp], ax

; 270  :         name.sin_addr.s_addr = INADDR_ANY;

	mov	DWORD PTR name$[rbp+4], 0

; 271  :         name.sin_port = htons(port);

	movzx	ecx, WORD PTR port
	call	htons
	mov	WORD PTR name$[rbp+2], ax

; 272  : 
; 273  :         admin_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	mov	r8d, 6
	mov	edx, 1
	mov	ecx, 2
	call	socket
	mov	QWORD PTR admin_sock$[rbp], rax

; 274  :         if (admin_sock < 0) 

	cmp	QWORD PTR admin_sock$[rbp], 0
	jae	SHORT $LN21@protocol_i
$LN4@protocol_i:

; 275  :             ABORT("Create TCP socket");

	lea	rdx, OFFSET FLAT:??_C@_0BC@BNICANMP@Create?5TCP?5socket@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@protocol_i
$LN21@protocol_i:

; 276  :         if (bind(admin_sock, (struct sockaddr *)&name, sizeof(name)) < 0) {

	mov	r8d, 16
	lea	rdx, QWORD PTR name$[rbp]
	mov	rcx, QWORD PTR admin_sock$[rbp]
	call	bind
	test	eax, eax
	jge	SHORT $LN22@protocol_i

; 277  :             lprintf("Station A: Failed to bind TCP port %u", port);

	movzx	eax, WORD PTR port
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0CG@EDILHNLG@Station?5A?3?5Failed?5to?5bind?5TCP?5p@
	call	lprintf
$LN7@protocol_i:

; 278  :             ABORT("Station A failed to bind TCP port");

	lea	rdx, OFFSET FLAT:??_C@_0CC@NKIOICIE@Station?5A?5failed?5to?5bind?5TCP?5po@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@protocol_i
$LN22@protocol_i:

; 279  :         }
; 280  : 
; 281  :         listen(admin_sock, 5);

	mov	edx, 5
	mov	rcx, QWORD PTR admin_sock$[rbp]
	call	listen

; 282  : 
; 283  :         lprintf("Station A is waiting for station B on TCP port %u ... ", port);

	movzx	eax, WORD PTR port
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0DH@DFJHKIDF@Station?5A?5is?5waiting?5for?5statio@
	call	lprintf

; 284  :         fflush(stdout);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush

; 285  : 
; 286  :         sock = accept(admin_sock, 0, 0);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR admin_sock$[rbp]
	call	accept
	mov	QWORD PTR sock, rax

; 287  :         if (sock < 0) 

	cmp	QWORD PTR sock, 0
	jae	SHORT $LN23@protocol_i
$LN10@protocol_i:

; 288  :             ABORT("Station A failed to communicate with station B");

	lea	rdx, OFFSET FLAT:??_C@_0CP@DAEGFDNO@Station?5A?5failed?5to?5communicate@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@protocol_i
$LN23@protocol_i:

; 289  :         lprintf("Done.\n");

	lea	rcx, OFFSET FLAT:??_C@_06MJLDIBBJ@Done?4?6@
	call	lprintf

; 290  : 
; 291  :         recv(sock, (char *)&epoch, sizeof(epoch), 0);

	xor	r9d, r9d
	mov	r8d, 8
	lea	rdx, OFFSET FLAT:epoch
	mov	rcx, QWORD PTR sock
	call	recv
$LN20@protocol_i:

; 292  :     }
; 293  : 
; 294  :     if (station == 'b') {

	cmp	DWORD PTR station, 98			; 00000062H
	jne	$LN24@protocol_i

; 295  : 
; 296  :         srand(mode_seed ^ 18231);

	mov	eax, DWORD PTR mode_seed
	xor	eax, 18231				; 00004737H
	mov	ecx, eax
	call	QWORD PTR __imp_srand

; 297  : 
; 298  :         sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	mov	r8d, 6
	mov	edx, 1
	mov	ecx, 2
	call	socket
	mov	QWORD PTR sock, rax

; 299  :         if (sock < 0) 

	cmp	QWORD PTR sock, 0
	jae	SHORT $LN25@protocol_i
$LN13@protocol_i:

; 300  :             ABORT("Create TCP socket");

	lea	rdx, OFFSET FLAT:??_C@_0BC@BNICANMP@Create?5TCP?5socket@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN13@protocol_i
$LN25@protocol_i:

; 301  : 
; 302  :         name.sin_family = AF_INET;

	mov	eax, 2
	mov	WORD PTR name$[rbp], ax

; 303  :         name.sin_addr.s_addr = inet_addr("127.0.0.1");

	lea	rcx, OFFSET FLAT:??_C@_09PFCHIMEP@127?40?40?41@
	call	inet_addr
	mov	DWORD PTR name$[rbp+4], eax

; 304  :         name.sin_port = htons((short)port);

	movzx	ecx, WORD PTR port
	call	htons
	mov	WORD PTR name$[rbp+2], ax

; 305  : 
; 306  :         for (i = 0; i < 60; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN16@protocol_i
$LN14@protocol_i:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN16@protocol_i:
	cmp	DWORD PTR i$[rbp], 60			; 0000003cH
	jge	SHORT $LN15@protocol_i

; 307  :             lprintf("Station B is connecting station A (TCP port %u) ... ", port);

	movzx	eax, WORD PTR port
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0DF@BAEEODFP@Station?5B?5is?5connecting?5station@
	call	lprintf

; 308  :             fflush(stdout);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	call	QWORD PTR __imp_fflush

; 309  : 
; 310  :             if (connect(sock, (struct sockaddr *)&name, sizeof(struct sockaddr_in)) < 0) {

	mov	r8d, 16
	lea	rdx, QWORD PTR name$[rbp]
	mov	rcx, QWORD PTR sock
	call	connect
	test	eax, eax
	jge	SHORT $LN26@protocol_i

; 311  :                 lprintf("Failed!\n");

	lea	rcx, OFFSET FLAT:??_C@_08OPNBKLNK@Failed?$CB?6@
	call	lprintf

; 312  :                 Sleep(2000);

	mov	ecx, 2000				; 000007d0H
	call	QWORD PTR __imp_Sleep

; 313  :             } else {

	jmp	SHORT $LN27@protocol_i
$LN26@protocol_i:

; 314  :                 lprintf("Done.\n");

	lea	rcx, OFFSET FLAT:??_C@_06MJLDIBBJ@Done?4?6@
	call	lprintf

; 315  :                 break;

	jmp	SHORT $LN15@protocol_i
$LN27@protocol_i:

; 316  :             }
; 317  :         }

	jmp	SHORT $LN14@protocol_i
$LN15@protocol_i:

; 318  :         if (i == 6)

	cmp	DWORD PTR i$[rbp], 6
	jne	SHORT $LN28@protocol_i
$LN19@protocol_i:

; 319  :             ABORT("Station B failed to connect station A");

	lea	rdx, OFFSET FLAT:??_C@_0CG@NOKOMEPL@Station?5B?5failed?5to?5connect?5sta@
	lea	rcx, OFFSET FLAT:??_C@_0BD@MHJEOPEJ@?6FATAL?3?5?$CFs?6Abort?4?6@
	call	lprintf
	xor	ecx, ecx
	call	QWORD PTR __imp_exit
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN19@protocol_i
$LN28@protocol_i:

; 320  : 
; 321  :         time(&epoch);

	lea	rcx, OFFSET FLAT:epoch
	call	time

; 322  :         send(sock, (char *)&epoch, sizeof(epoch), 0);

	xor	r9d, r9d
	mov	r8d, 8
	lea	rdx, OFFSET FLAT:epoch
	mov	rcx, QWORD PTR sock
	call	send
$LN24@protocol_i:

; 323  :     }
; 324  : 
; 325  :     {
; 326  :         struct tm *newtime;
; 327  :         newtime = localtime(&epoch);

	lea	rcx, OFFSET FLAT:epoch
	call	localtime
	mov	QWORD PTR newtime$7[rbp], rax

; 328  :         lprintf("New epoch: %s", asctime(newtime));

	mov	rcx, QWORD PTR newtime$7[rbp]
	call	QWORD PTR __imp_asctime
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0O@IAJMGODG@New?5epoch?3?5?$CFs@
	call	lprintf

; 329  :         lprintf("=================================================================\n\n");

	lea	rcx, OFFSET FLAT:??_C@_0EE@KFDNKAKK@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	call	lprintf

; 330  :     }
; 331  : 
; 332  :     /* socket options */
; 333  :     {
; 334  :         int timeout_ms = 10; 

	mov	DWORD PTR timeout_ms$8[rbp], 10

; 335  :         int buf_size = 1024 * 64;

	mov	DWORD PTR buf_size$9[rbp], 65536	; 00010000H

; 336  :         int on = 1;

	mov	DWORD PTR on$10[rbp], 1

; 337  : 
; 338  :         setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&timeout_ms, sizeof(int));

	mov	DWORD PTR [rsp+32], 4
	lea	r9, QWORD PTR timeout_ms$8[rbp]
	mov	r8d, 4101				; 00001005H
	mov	edx, 65535				; 0000ffffH
	mov	rcx, QWORD PTR sock
	call	setsockopt

; 339  :         setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout_ms, sizeof(int));

	mov	DWORD PTR [rsp+32], 4
	lea	r9, QWORD PTR timeout_ms$8[rbp]
	mov	r8d, 4102				; 00001006H
	mov	edx, 65535				; 0000ffffH
	mov	rcx, QWORD PTR sock
	call	setsockopt

; 340  : 
; 341  :         setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *)&buf_size, sizeof(int));

	mov	DWORD PTR [rsp+32], 4
	lea	r9, QWORD PTR buf_size$9[rbp]
	mov	r8d, 4098				; 00001002H
	mov	edx, 65535				; 0000ffffH
	mov	rcx, QWORD PTR sock
	call	setsockopt

; 342  :         setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *)&buf_size, sizeof(int));

	mov	DWORD PTR [rsp+32], 4
	lea	r9, QWORD PTR buf_size$9[rbp]
	mov	r8d, 4097				; 00001001H
	mov	edx, 65535				; 0000ffffH
	mov	rcx, QWORD PTR sock
	call	setsockopt

; 343  : 
; 344  :         setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof(on));   

	mov	DWORD PTR [rsp+32], 4
	lea	r9, QWORD PTR on$10[rbp]
	mov	r8d, 1
	mov	edx, 6
	mov	rcx, QWORD PTR sock
	call	setsockopt

; 345  :     }   
; 346  : 
; 347  :     get_ms();

	call	get_ms
$LN29@protocol_i:

; 348  : }

	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:protocol_init$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+440]
	pop	rdi
	pop	rbp
	ret	0
protocol_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT get_ms
_TEXT	SEGMENT
tm$ = 8
tv70 = 232
__$ArrayPad$ = 240
get_ms	PROC						; COMDAT

; 36   : {

$LN5:
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 37   : 	struct _timeb tm;
; 38   : 
; 39   : 	_ftime(&tm);

	lea	rcx, QWORD PTR tm$[rbp]
	call	QWORD PTR __imp__ftime64

; 40   : 
; 41   : 	return (unsigned int)(epoch ? (tm.time - epoch) * 1000 + tm.millitm : 0);

	cmp	QWORD PTR epoch, 0
	je	SHORT $LN3@get_ms
	mov	rax, QWORD PTR epoch
	mov	rcx, QWORD PTR tm$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	imul	rax, rax, 1000				; 000003e8H
	movzx	ecx, WORD PTR tm$[rbp+8]
	add	rax, rcx
	mov	QWORD PTR tv70[rbp], rax
	jmp	SHORT $LN4@get_ms
$LN3@get_ms:
	mov	QWORD PTR tv70[rbp], 0
$LN4@get_ms:
	mov	eax, DWORD PTR tv70[rbp]

; 42   : }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:get_ms$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
get_ms	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Users\SevenGrass\Documents\WILLIAMZHANG\ComputerNetwork\Lab\Lab1-2024(Win+Linux)\Lab1-Windows-VS2019\protocol.c
;	COMDAT socket_init
_TEXT	SEGMENT
wVersionRequested$ = 4
WSAData$ = 48
status$ = 484
__$ArrayPad$ = 696
socket_init PROC					; COMDAT

; 22   : {

	push	rbp
	push	rdi
	sub	rsp, 744				; 000002e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 130				; 00000082H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__EDD2A947_protocol@c
	call	__CheckForDebuggerJustMyCode

; 23   :     WORD wVersionRequested;
; 24   :     WSADATA WSAData;
; 25   : 	int status;
; 26   : 
; 27   :     wVersionRequested = MAKEWORD(1,1);

	mov	eax, 257				; 00000101H
	mov	WORD PTR wVersionRequested$[rbp], ax

; 28   :     status = WSAStartup(wVersionRequested, &WSAData);

	lea	rdx, QWORD PTR WSAData$[rbp]
	movzx	ecx, WORD PTR wVersionRequested$[rbp]
	call	WSAStartup
	mov	DWORD PTR status$[rbp], eax

; 29   :     if (status != 0) {

	cmp	DWORD PTR status$[rbp], 0
	je	SHORT $LN2@socket_ini

; 30   :         printf("Windows Socket DLL Error\n");

	lea	rcx, OFFSET FLAT:??_C@_0BK@FDEBLBFC@Windows?5Socket?5DLL?5Error?6@
	call	printf

; 31   : 	    exit(0);

	xor	ecx, ecx
	call	QWORD PTR __imp_exit
$LN2@socket_ini:
$LN3@socket_ini:

; 32   :     }
; 33   : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:socket_init$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+712]
	pop	rdi
	pop	rbp
	ret	0
socket_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 248
_Buffer$ = 288
_Format$ = 296
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rbp]
	mov	rcx, QWORD PTR _Buffer$[rbp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rbp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 1779 :         return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 1780 :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:sprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rbp]
	mov	r8, QWORD PTR _Format$[rbp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rbp]
	call	_vsnprintf_l

; 1460 :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 4
tv74 = 212
_Buffer$ = 256
_BufferCount$ = 264
_Format$ = 272
_Locale$ = 280
_ArgList$ = 288
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 280				; 00000118H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rbp]
	mov	r8, QWORD PTR _BufferCount$[rbp]
	mov	rdx, QWORD PTR _Buffer$[rbp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rbp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rbp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rbp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rbp]
	mov	DWORD PTR tv74[rbp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rbp]

; 1397 :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 248
_Format$ = 288
printf	PROC						; COMDAT

; 956  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 18
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rbp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rbp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 963  :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:printf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6DFAE8B8_stdio@h
	call	__CheckForDebuggerJustMyCode

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rbp]
	mov	r8, QWORD PTR _Format$[rbp]
	mov	rdx, QWORD PTR _Stream$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A2143F22_corecrt_stdio_config@h
	call	__CheckForDebuggerJustMyCode

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 224
time	PROC						; COMDAT

; 521  :         {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A0B61CF9_time@h
	call	__CheckForDebuggerJustMyCode

; 522  :             return _time64(_Time);

	mov	rcx, QWORD PTR _Time$[rbp]
	call	QWORD PTR __imp__time64

; 523  :         }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\time.h
;	COMDAT localtime
_TEXT	SEGMENT
_Time$ = 224
localtime PROC						; COMDAT

; 498  :         {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A0B61CF9_time@h
	call	__CheckForDebuggerJustMyCode

; 499  :             return _localtime64(_Time);

	mov	rcx, QWORD PTR _Time$[rbp]
	call	QWORD PTR __imp__localtime64

; 500  :         }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
localtime ENDP
_TEXT	ENDS
END
