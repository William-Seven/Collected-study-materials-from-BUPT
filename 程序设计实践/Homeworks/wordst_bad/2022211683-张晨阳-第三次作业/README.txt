第三次作业——性能
学号：2022211683
姓名：张晨阳

测试文件：bible.txt
《圣经》（The Holy Bible, King James Version）

wordst_bad.cpp测试结果说明：
命令：time ./bad bible.txt

测试用的文本的单词数量: 795227
文本所含的不同单词的数量: 12870
排名前三的单词及其数量：
the: 64309
and: 51762
of: 34846

十次平均执行时间：
real    0m0.742s
user    0m0.574s
sys     0m0.059s

wordst_good.cpp测试结果说明：
命令：time ./good bible.txt

测试用的文本的单词数量: 795227
文本所含的不同单词的数量: 12870
排名前三的单词及其数量：
the: 64309
and: 51762
of: 34846

十次平均执行时间：
real    0m0.307s
user    0m0.149s
sys     0m0.060s

性能提高比例：(0.742-0.307)/0.742=58.5%

性能优化：
1. 替换 std::map 为 std::unordered_map
优化内容：将 std::map 替换为 std::unordered_map，利用哈希表实现单词统计。
优化依据：
std::map 的插入和查找复杂度是 O(logn)，而 std::unordered_map 的平均复杂度为 O(1)。
对于大规模文本文件，单词种类多时，哈希表的性能优于基于红黑树的有序映射。

2. 移除动态内存分配
优化内容：直接将 WordInfo 内嵌到 std::unordered_map 的值中，避免使用动态分配的 WordInfo* 指针。
优化依据：
使用指针时，频繁的动态内存分配（new 和 delete）会导致内存管理的额外开销。
内嵌结构体 WordInfo 使单词统计逻辑更简单，同时提高了运行效率，减少了内存碎片化。

3. 改进排序逻辑
优化内容：改用 std::partial_sort 或 std::priority_queue，仅排序前 3 名单词，而非对所有单词进行完全排序。
优化依据：
原始代码中使用 std::sort 对所有单词排序，复杂度为 O(nlogn)。
如果只需要前 3 名的单词，std::partial_sort 的复杂度为 O(n+klogk)，其中 k=3。当单词数量 n 较大时，效率显著提升。

4. 限制行号记录数量
优化内容：修改 WordInfo 中的行号记录逻辑，只存储前 20 个行号。
优化依据：
在行号较多的情况下，存储所有行号会消耗大量内存。
输出时只展示前 20 个行号，因此限制存储的行号数量可以降低内存占用，避免不必要的冗余操作。

5. 合并统计和打印逻辑
优化内容：在 printStatis 中将总单词数量、唯一单词数量的统计和输出排名等操作整合到一次遍历中完成。
优化依据：
原始代码中统计总单词数量和唯一单词数量时，分别额外遍历了 std::map，增加了运行时间。
将统计任务合并到一次遍历中减少了不必要的重复操作。