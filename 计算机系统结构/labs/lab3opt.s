.text
main:
    ADDIU $r1, $r0, A      # 将向量A的地址加载到寄存器$r1
    ADDIU $r2, $r0, B      # 将向量B的地址加载到寄存器$r2
    ADDIU $r3, $r0, ans    # 将结果存储的地址加载到寄存器$r3
    ADDIU $r4, $r0, n      # 将向量维度n的地址加载到寄存器$r4
    LW $r4, 0($r4)         # 从内存中加载向量维度n的值到寄存器$r4
    ADDIU $r5, $r0, 0      # 初始化循环索引i为0，存储在寄存器$r5
    ADDIU $r6, $r0, 0      # 初始化结果寄存器$r6为0，用于存储点积结果

loop:
    LW $r7, 0($r1)         # 从向量A中加载第i个元素（A[i]）到寄存器$r7
    LW $r8, 0($r2)         # 从向量B中加载第i个元素（B[i]）到寄存器$r8

    MUL $r9, $r7, $r8      # 计算A[i] * B[i]，结果存储在寄存器$r9

    ADDI $r1, $r1, 4       # 移动到向量A的下一个元素，4字节为一个整数的大小
    ADDI $r2, $r2, 4       # 移动到向量B的下一个元素，同样是4字节
    ADDI $r5, $r5, 1       # 索引i加1

    ADD $r6, $r6, $r9      # 将计算的A[i] * B[i]的结果累加到寄存器$r6中，得到点积结果

    BNE $r5, $r4, loop     # 如果索引i不等于向量维度n，继续循环，执行下一次迭代

    SW $r6, 0($r3)         # 将点积结果存储到内存地址ans中

    # 结束程序
    TEQ $r0, $r0           # 比较寄存器$r0与自身，作为程序结束的标志

# 数据部分
.data
    A: .word 1, 2, 3, 4, 5, 6, 7, 8, 9, 10  # 向量A的元素
    B: .word 10, 9, 8, 7, 6, 5, 4, 3, 2, 1  # 向量B的元素
    n: .word 10                           # 向量的维度n
    ans: .word 0                          # 存储点积结果的内存地址
