判断题 10 个
单选题 10 个
简答题
应用题（类似白盒黑盒的题目）
综合题
# 第一章、软件工程概述
## 软件的定义
- 程序的定义：程序 = 算法 + 数据结构
- **软件的定义**：程序、数据及其相关文档的完整集合

## 软件发展和软件危机
- 软件危机：软件开发的**高成本**与软件产品的**低质量**之间的矛盾

## 软件工程的概念
- 软件工程的三要素：**方法、工具、过程**
- **软件工程的目标**：在**给定成本和时间**的前提下，开发出满足用户需求且具有**正确性、可用性**等因素的软件产品。
- 软件工程项目三个基本目标：合理的进度、有限的经费、一定的质量

# 第二章、软件生命周期模型
## 软件生命周期概念
- 软件生命周期六个基本步骤：**制定计划 P、需求分析 D、软件设计 D、程序编码 D、软件测试 C、运行维护 A**。
## 传统软件生命周期模型
打印的笔记
### 瀑布模型
所有其他软件生命周期模型的基础


9 个生命周期模型（重点掌握瀑布模型、原型方法）
需要知道每种模型的特点

RUP、敏捷开发
RUP 非常适合大型的、需要反复明确需求的
**初始阶段、细化阶段、构造阶段、移交阶段**
- 初始阶段：软件目标里程碑。
- 细化阶段：体系结构里程碑。
- 构造阶段：运行能力里程碑。
- 移交阶段：产品发布里程碑。
敏捷开发相对于瀑布模型（大量文档）来说的、敏捷宣言、极限编程

# 第三章、软件需求分析
## 需求分析
定义、建立哪些模型？**数据模型、功能模型、行为模型**

需求分析的几个步骤：需求获取（用户需求说明书：用自然语言描述的粗略的需求）、需求定义（软件规格说明书）、需求确认

# 第四章、面向对象分析（重点）
UML 图——五类视图：用例视图、逻辑视图、进程视图、构件视图、部署视图

**用例图**、**类图**（类与类的 5 种关系）、对象图（类图的具象化）、交互图（**顺序图**（时间轴）、协作图（标号））、状态图、活动图

## 类图
![](Attachments/Pasted%20image%2020250618170519.png)



## 领域模型
完整的领域模型包括：类图+活动图


## 系统顺序图



## 操作契约 
后置条件从三个角度描述：
- 对象的创建和删除
- 对象之间的关系的建立或消除
- 对象属性值的修改
# 第五章、软件设计
软件概要设计：
- **制定设计规范。**
- **软件系统结构的总体设计。**
- 处理方式设计（性能设计）。
- 数据结构设计。
- 可靠性设计（质量设计）。
- 界面设计（需求的直接表达方式）。
- **编写软件概要设计说明书**（最终结果）
- 概要设计评审。

模块化的设计：
模块 (module) 定义：整个软件可被划分成若干个**可单独命名且可编址组成部分**，这些部分称之为模块。
模块具有如下三个基本属性：
- 功能：实现什么功能，做什么事情。
- 逻辑：描述模块内部怎么做。
- 状态：该模块使用时的环境和条件。


信息隐藏原则


内聚、耦合（七种内聚特点、七种耦合特点）

模块的内聚性：内聚性越高，模块功能独立性越强。
模块的耦合性：耦合性越高，模块间联系越紧密，独立性越弱。应当避免高耦合。
![](Attachments/Pasted%20image%2020250618183558.png)
![](Attachments/Pasted%20image%2020250618183612.png)

# 第六章、面向对象设计（重点）
以需求分析阶段的**用例模型**和**领域模型**为基础，运用 UML 构建软件系统结构，通过一系列设计模型说明用例的实现过程。
用例实现方案：6
1. 创建动态结构（有哪些对象+如何交互来响应系统实现）（协作图/顺序图）（建议画顺序图——简单）（画协作图：GRASP（信息专家、控制器（创建者逐渐被替代）））
   谁拥有处理数据的信息——信息专家
   把界面传来的系统时间分发给信息专家——控制器——让界面的类和服务类耦合减小
   先到控制器（用例控制器）->信息专家（DBFacade（如果要访问数据库，画这个类））
2. 创建静态结构
   根据动态结构的图画出设计类图

七个面向对象设计原则
- **单一职责原则**：引起一个类**变化的原因**（职责）应该只有一个。
- **开闭原则**：类、模块、函数可以扩展，但不能修改原有代码（Open for extension，Closed for modification）。
- **里氏替换原则**：子类应当可以替换父类，并出现在父类能够出现的任何地方。
- **依赖倒置原则**：
    - 高层模块不应依赖于底层模块，二者都应依赖于抽象。抽象不应依赖于细节，细节应该依赖于抽象。
    - 程序中所有依赖关系都应终止于抽象类或接口。
- **接口隔离原则**：若一个服务类为多个客户类提供不同服务，则服务类针对每个不同服务都应该有一个接口。
- **组合/聚合复用原则**：在一个新对象里面使用一些已有对象，使之成为新对象的一部分。新对象通过向已有对象委托（delegate）一部分职责而达到复用已有对象的目的。（不要继承，要组合/聚合）
- **迪米特法则**：最少知识原则。一个对象应当尽可能少地了解其他对象。（对象只与 this、本对象方法中的参量、当前对象实例直接引用的对象、对象实例聚集中的其他元素、当前对象创建的对象通信）

# 第九章、软件实现、测试和维护
## 软件实现
源程序除了质量要求之外，为了后期代码的维护和修改，还必须提高可阅读性，达到源程序文档化。
- 标识符命名：模块名（类名及方法名），变量/常量名
    - 名称需标示清楚具体含义，采用前缀后缀增加可阅读性。
    - 使用专业术语（业务词汇），避免与编码语言关键字冲突。
    - 注意大小写及长度。
- 源程序布局：
    - 编码之前定义统一的编码规范。
    - 规定合理的注释、缩进、空格、空行等方式。
- 程序注释：
    - 序言性注释：位于代码之前，说明该模块（类及方法）具体作用。包括：
        - 程序标题：模块名称。
        - 模块描述：该模块的功能和目的说明。
        - 主要算法（可选）：说明采用的算法结构。
        - 接口说明：说明该模块与其他模块的调用关系。
        - 开发简历：创建者、创建时间。修改者、修改时间、修改内容。版本。
    - 功能性注释：对于程序体中复杂难于理解的程序结构进行局部说明。
## 软件测试
- **单元测试**
  集中对用源代码实现的每一个程序单元进行测试。
- **集成测试**
  根据设计规定的软件体系结构，把已测试过的模块组装起来，在组装过程中，检查程序结构组装的正确性。
- **确认测试**
  检查已实现的软件是否满足了需求规格说明中确定了的各种需求，以及软件配置是否完全、正确。
- **系统测试**
  把已经经过确认的软件纳入实际运行环境中，与其它系统成份组合在一起进行测试。
- **验收测试**
  系统测试后可以正式投入试运行，一段时间后系统各方面均已满足需求，这时需对系统进行验收测试。验收测试是一个形式意义上的工作，选择用户最为关心的核心功能确认即可。
![](Attachments/Pasted%20image%2020250617140426.png)

### 黑盒测试 (一般用于集成测试、系统测试、验收测试)
功能测试，指在不考虑程序内部结构和内部特征的情况下，根据软件产品的功能设计规格说明，在计算机上进行测试，以证实每个实现了的功能是否符合要求。

主要错误：
功能错误或遗漏。
输入和输出接口的正确性。
数据结构或外部信息访问错误。
性能要求满足情况。
初始化或终止性错误。

- **等价类划分** 书 P 268
 > 按区间、数值集合、布尔值等规则将**输入空间**划分为**有效等价类**与**无效等价类**，使用等价类的一个或几个代表值进行测试
 > 步骤：
 >> 1. 划分等价类，包括**有效等价类**与**无效等价类**
 >> 2. 对所有有效等价类和无效等价类进行顺序**编号**
 >> 3. 设计测试用例，尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤，直到全部有效等价类均被覆盖到为止
 >> 4. 设计测试用例，每次只覆盖一个无效等价类，重复这一步骤，直到全部无效等价类均被覆盖到为止

- **边界值分析**
 > 对等价类划分的补充。使用对于等价类而言稍高于其边界值或低于其边界值的一些特殊情况进行测试。
### 白盒测试 (一般单元测试)
结构测试，指根据软件产品的内部工作过程，在计算机上进行测试，以证实每种内部操作是否符合设计规格要求，所有内部成分是否已经过检查。

白盒测试方法主要对程序模块进行如下检查：
- 程序模块所有独立执行路径至少测试一次。
- 所有逻辑判定分支至少测试一次。
- 循环边界和运行界限内执行情况。
- 程序内部数据结构的有效性。

![](Attachments/Pasted%20image%2020250617140713.png)

逻辑覆盖：逻辑覆盖是一程序内部的逻辑结构为基础设计的测试用例技术。
- 语句覆盖：使得每一个可执行语句至少执行一次。语句覆盖发现不了判断中逻辑运算中出现的错误，是最弱的逻辑覆盖准则。
- 判定覆盖：使得程序中每个判断的取真分支和取假分支至少经历一次，又称为分支覆盖。判定覆盖还不能保证一定查出在判断的条件中存在的错误，因此需要更强的逻辑覆盖准则检验判断内部条件。
- 条件覆盖：使得程序中每个判断的每个条件的可能取值至少执行一次。
- 判定+条件覆盖：使得判断中每个条件的所有可能取值至少执行一次，同时每个判断的所有可能判断结果取值至少执行一次。采用判定-条件覆盖，逻辑表达式中的错误不一定能够查得出来。
- 条件组合覆盖：使得每个判断的所有可能的条件取值组合至少执行一次。需要将多重条件判断分解成有多个基本判断组成的流程图。
- 路径覆盖：设计足够的测试用例，覆盖程序中所有可能的路径。**这种测试仍然无法满足条件组合覆盖某些条件，也并非是完善的测试方法。在实际的测试用例设计过程中需要综合以上 6 种测试方法去设计测试用例。以路径覆盖为主，辅助其他 5 种方法。**

- **基本路径测试**
 > 基本路径测试步骤：
 >> 1. 导出程序流程图的拓扑结构-流图 (程序图)
 >>> **控制流图的转换：**
 >>> 顺序结构的多个结点可以合并为一个结点。
 >>> 在选择或多分支结构中，分支的汇聚处应有一个虚拟汇聚结点。
 >>> 边和结点圈定的范围叫做区域，当对区域计数时，图形外的范围也应记为一个区域。
 >>> 如果判断中的条件表达式是由一个或多个逻辑运算符连接的复合条件表达式，则需要改为一系列只有单个条件的嵌套的判断。
 >>> ![](Attachments/Pasted%20image%2020250617144936.png)
 >> 计算流图 G 的**环路复杂度** V (G)
 >>> 等于控制流图中的区域数，包括封闭区域和开放区域。
 >>> 设 E 为控制流图的边数，N 为图的结点数，则环路复杂度定义为 $V(G)=E−N+2$。
 >>> 设 P 为控制流图中的判定结点数，则有$V(G)=P+1$
 >> 确定只包含独立路径的基本路径集
 >>> 指**程序控制流图**中，从入口到出口的至少经历一个从未走过的边的不同路径的集合。
 >> 设计测试用例


## 软件维护
软件维护：定义 +四种类型（会判断）
- **改正性维护**：为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用而进行的诊断和改正错误的过程
- **适应性维护**：为了使软件适应外部环境或数据环境的变化，而去修改软件的过程
- **完善性维护**：为了满足用户对软件提出**新的功能与性能要求**而去修改和再开发软件的过程
- **预防性维护**：采用先进的软件工程方法对需要维护的软件或软件中的某一部分(重新)进行设计、编制和测试

